diff -ruN gfx2orig/share/grafx2/gfx2def.ini grafx2/share/grafx2/gfx2def.ini
--- gfx2orig/share/grafx2/gfx2def.ini	2010-03-21 17:13:31.000000000 -0500
+++ grafx2/share/grafx2/gfx2def.ini	2022-03-20 20:19:34.116495316 -0500
@@ -1,359 +1,359 @@
-###### GrafX2 initialization file ###### Fichier d'initialisation de GrafX2 ##
-#                                     #                                      #                                                                          #
-# You may modify this file with any   # Vous pouvez modifier ce fichier avec #
-# standard ASCII text editor.         # n'importe quel éditeur de texte      #
-#                                     # ASCII standard.                      #
-#                                     #                                      #
-# Comments are preceded by ';' or     # Les commentaires sont précédés par   #
-# '#'.                                # ';' ou '#'.                          #
-#                                     #                                      #
-# Options are not case sensitive and  # Les options ne sont pas sensibles à  #
-# spaces are ignored.                 # la casse et les espaces sont ignorés.#
-#                                     #                                      #
-# You must not change the order of    # Vous ne devez pas changer l'ordre    #
-# the sections and their options.     # des sections et de leurs options.    #
-# You must not delete or put into     # Vous ne devez pas effacer ou mettre  #
-# comment any section nor option.     # en commentaire une section ou option.#
-#                                     #                                      #
-# Each option is preceded by a        # Chaque option est précédée par un    #
-# comment which explains its meaning. # commentaire qui explique sa fonction.#
-#                                     #                                      #
-##############################################################################
-
-
-
-[MOUSE]                               # [SOURIS]
-
-  ; The sensitivity of the mouse can  | La sensibilité de la souris peut
-  ; take values from 1 to 4. The      | prendre des valeurs de 1 à 4. Plus
-  ; smaller values, the faster.       | les valeurs sont petites, plus c'est
-  ; This only takes effect in         | rapide. Ce paramétrage n'est utilisé
-  ; fullscreen modes.                 | que dans les modes "plein écran".
-  ;                                   | 
-  X_sensitivity = 1	; (default 1)
-  Y_sensitivity = 1	; (default 1)
-
-  ; Unused setting, only kept for compatibility.
-  X_correction_factor = 0	; (default 0)
-  Y_correction_factor = 0	; (default 0)
-
-  ; Aspect of the main cursor (cross) | Aspect du curseur principal (croix)
-  ; 1: Solid                          | 1: Solide
-  ; 2: Transparent                    | 2: Transparent
-  ; 3: Thin (solid)                   | 3: Fin (solide)
-  Cursor_aspect = 1	; (default 1)
-
-[MENU]                                # [MENU]
-
-  ; Colors of the menus (the black    | Couleurs des menus (la couleur noire
-  ; and the white colors cannot be    | et la couleur blanche ne peuvent pas
-  ; modified).                        | être modifiées).
-  ; Values are in {Red,Green,Blue}    | Les valeurs sont dans l'ordre {Rouge,
-  ; order and are between 0 and 63.   | Vert,Bleu} et vont de 0 à 63.
-  Light_color = 42,42,42	; (default 42,42,42)
-  Dark_color  = 27,27,27	; (default 27,27,27)
-  ;
-  ;  Light_color = 24,25,30	; \_ Nightmare
-  ;  Dark_color  = 13,14,19	; /
-  ;
-  ;  Light_color = 10,45,28	; \_ Forest
-  ;  Dark_color  =  5,27,12	; /
-  ;
-  ;  Light_color = 48,41,26	; \_ Gold
-  ;  Dark_color  = 26,22,15	; /
-  ;
-  ;  Light_color = 10,40,55	; \_ Oceanic
-  ;  Dark_color  = 10,20,32	; /
-
-  ; Aspect ratio and size of the      | Proportion des menus et de la barre
-  ; menus and the tool-bar.           | d'outils.
-  ; Possible values:                  | Valeurs possibles:
-  ; 0: Do not adapt (pixels are not   | 0: Ne pas adapter (les pixels ne sont
-  ;    stretched)                     |    pas étirés)
-  ; 1: Adapt the menus and the tool-  | 1: Adapter les menus et la barre
-  ;    bar according to the resolution|    d'outils suivant la résolution
-  ; 2: Slightly adapt the ratio of    | 2: Adapter légèrement les proportions
-  ;    the menus and tool-bar         |    des menus et de la barre d'outils
-  ; -1:Do not adapt (like 0)          | -1:Ne pas adapter (comme 0)
-  ; -2:Stretch by x2 maximum          | -2:Etire au double de taille si possible
-  ; -3:Stretch by x3 maximum          | -3:Etire au triple de taille si possible  
-  ; -4:Stretch by x4 maximum          | -3:Etire au quadruple de taille si
-  ;                                   |    possible.
-  Menu_ratio = -2	; (default -2)
-
-[FILE_SELECTOR]                       # [SELECTEUR_DE_FICHIERS]
-
-  ; Show hidden files and             | Afficher les fichiers et répertoires
-  ; directories (values are 'yes' or  | cachés (les valeurs sont 'yes' ou
-  ; 'no').                            | 'no').
-  Show_hidden_files       = no	; (default 'no')
-  Show_hidden_directories = no	; (default 'no')
-
-  ; Delay before displaying a preview | Délai avant d'afficher une preview
-  ; in file-selectors (in 18.2th of   | dans les sélecteurs de fichiers (en
-  ; second). Possible values range    | 18.2èmes de seconde) Les valeurs
-  ; from 1 to 256.                    | possibles vont de 1 à 256.
-  Preview_delay = 8	; (default 8)
-
-  ; Maximize the preview of the       | Maximiser la preview des images pour
-  ; pictures so that it is as big as  | qu'elle soit aussi grande que
-  ; possible. If you're not in the    | possible.
-  ; same resolution as the picture's  | Si vous n'êtes pas dans la même réso-
-  ; one, it can try to correct the    | lution que celle de l'image, cela peut
-  ; aspect ratio, but if the picture  | essayer de corriger les proportions,
-  ; does not fill the whole screen,   | mais si l'image ne prend pas tout
-  ; it can be worse.                  | l'écran, cela peut être pire.
-  Maximize_preview = no	; (default 'no')
-
-  ; This option is used to place the  | Cette option est utilisée pour placer
-  ; selection bar on a filename by    | la barre de sélection sur un nom de
-  ; typing its first letters.         | fichier en tapant ses 1ères lettres.
-  ; For example, if you want to find  | Par exemple, si vous voulez trouver le
-  ; the "PICTURE.PKM" in a directory  | fichier "PICTURE.PKM" dans un réper-
-  ; that also contains "PALETTE.PAL", | toire contenant également le fichier
-  ; you'll just have to type P and I. | "PALETTE.PAL", vous n'aurez qu'à taper
-  ; The different values of "FFF"     | P puis I.
-  ; indicate if you want to find the  | Les different valeurs de "FFF"
-  ; name in both files and directories| indiquent si vous voulez trouvez le nom
-  ; or just in only one of these:     | dans les fichiers ET les répertoires ou
-  ; 0: files and directories          | simplement dans l'un OU l'autre.
-  ; 1: files only                     | 0: fichiers et répertoires
-  ; 2: directories only               | 1: fichiers seulement
-  ;                                   | 2: répertoires seulement
-  Find_file_fast = 0	; (default 0)
-
-
-[LOADING]                             # [CHARGEMENT]
-
-  ; Automatically set the resolution  | Passer automatiquement dans la bonne
-  ; when loading a picture.           | résolution lors du chargement d'une
-  ; You should set this value to      | image.
-  ; 'yes' after disabling the video   | Vous devriez définir cette option à
-  ; modes that are not supported by   | 'yes' après avoir inhibé les modes
-  ; your video card or monitor.       | vidéo qui ne sont pas supportés par
-  ;                                   | votre matériel.
-  Auto_set_resolution = no	; (default 'no')
-
-  ; If the variable above is set to   | Si la variable ci-dessus est à 'yes',
-  ; 'yes', this one tells if you want | celle-ci indique si vous voulez
-  ; to set the resolution according   | définir la résolution suivant:
-  ; to:                               | 1: les dimensions de "l'écran
-  ; 1: the internal "original screen" |    d'origine" internes à l'image
-  ;    dimensions of the picture      | 2: les véritables dimensions de
-  ; 2: the actual dimensions of the   |    l'image
-  ;    picture                        |
-  Set_resolution_according_to = 1	; (default 1)
-
-  ; If you load a picture with a      | Si vous chargez une image ayant une
-  ; palette of less than 256 colors,  | palette de moins de 256 couleurs,
-  ; this option defines if you want   | cette option indique si vous souhaitez
-  ; to clear the palette or to keep   | effacer la palette ou bien conserver
-  ; the colors of the previous        | les couleurs de l'image précédente qui
-  ; picture that are over the number  | se situent au-delà du nombre de la
-  ; of colors of the new picture.     | nouvelle image.
-  ; For example, if you load a        | Par exemple, si vous chargez une image
-  ; 32-color picture, the colors 32   | de 32 couleurs, les couleurs 32 à 255
-  ; to 255 will be set to black if    | seront passées en noir si cette option
-  ; this option is set to 'yes', or   | est à 'yes', ou bien elles resteront
-  ; they will be kept unchanged if    | inchangées si elle est à 'no'.
-  ; this option is set to 'no'.       |
-  Clear_palette = yes	; (default 'yes')
-
-
-[MISCELLANEOUS]                       # [DIVERS]
-
-  ; Draw the limits of the picture.   | Afficher les limites de l'image
-  Draw_limits = yes	; (default 'yes')
-
-  ; Adjust the brush grabbing in      | Ajuster la capture de brosse en mode
-  ; "grid" mode.                      | "grille".
-  Adjust_brush_pick = yes	; (default 'yes')
-
-  ; Coordinates:                      | Coordonnées:
-  ; 1: Relative                       | 1: Relatives
-  ; 2: Absolute                       | 2: Absolues
-  Coordinates = 1	; (default 1)
-
-  ; Create a backup file when saving. | Créer un fichier backup lors des
-  ;                                   | sauvegardes.
-  Backup = no	; (default 'no')
-
-  ; Number of pages stored in memory  | Nombre de pages stockées en mémoire
-  ; for "undoing".                    | destinées à annuler les dernières
-  ; Values are between 1 and 99.      | modifications. Valeurs entre 1 et 99.
-  Undo_pages = 10	; (default 10)
-
-  ; Speed of the scroll-bars (in VBLs | Vitesse des barre de défilement (en
-  ; waited) while clicking with the   | VBLs attendus) lorsque l'un des
-  ; left or right button of the mouse.| boutons de la souris est enfoncé.
-  ; Values can be between 1 and 255.  | Les valeurs sont comprises entre 1 et
-  ; The bigger values, the slower.    | 255. Plus elles sont grandes, plus
-  ;                                   | c'est lent.
-  Gauges_scrolling_speed_Left  = 10	; (default 10)
-  Gauges_scrolling_speed_Right = 3	; (default 3)
-
-  ; Automatically save the configu-   | Enregistre automatiquement la configu-
-  ; ration when exiting the program.  | ration lorsqu'on quitte le programme.
-  Auto_save = yes	; (default 'yes')
-
-  ; Maximum number of vertices used   | Nombre maximum de vertex utilisés dans
-  ; in filled polygons and polyforms, | les polygônes et polyformes pleins, et
-  ; and lasso. Possible values range  | le lasso. Les valeurs possibles vont
-  ; from 2 to 16384.                  | de 2 à 16384.
-  ; Each vertex takes 4 bytes.        | Chaque vertex prend 4 octets.
-  Vertices_per_polygon = 1024	; (default 1024)
-
-  ; Automatically zoom into the       | Zoomer automatiquement la zone pointée
-  ; pointed area when you press the   | par la souris lorsque vous appuyez sur
-  ; short-key of the Magnifier button | la touche de raccourci de la loupe.
-  ; while being above the picture.    |
-  Fast_zoom = yes	; (default 'yes')
-
-  ; Separate the colors in the tool-  | Séparer les couleurs dans la barre
-  ; bar by a black squaring.          | d'outils par un quadrillage noir.
-  Separate_colors = no	; (default 'no')
-
-  ; Initial value of the feedback for | Valeur initiale du "feedback" pour les
-  ; the drawing modes (cf. docs).     | modes de dessin (cf. docs).
-  FX_feedback = yes	; (default 'yes')
-
-  ; When you reduce the palette or    | Si vous réduisez la palette ou "zappez"
-  ; "zap" some colors out of it, it is| quelques couleurs, il est possible
-  ; possible that there are not enough| qu'il ne reste pas assez de couleurs
-  ; colors left to draw the menus.    | pour afficher les menus. Mettre cette
-  ; Switching the following variable  | variable à 'yes' ramènera automatiquent
-  ; on will bring back the colors of  | les couleurs du menu s'il reste moins
-  ; the menu if there are less than 4 | de 4 couleurs après une "réduction" ou
-  ; colors left after "reducing" or   | un "zapping".
-  ; "zapping".                        |
-  Safety_colors = yes	; (default 'yes')
-
-  ; Display a message at startup      | Afficher un message au démarrage
-  ; telling the version number of the | indiquant le numéro de version du
-  ; program.                          | programme.
-  Opening_message = yes	; (default 'yes')
-
-  ; Take the Stencil into account when| Prendre le Stencil en compte lorsqu'on
-  ; clearing the image.               | efface l'image.
-  Clear_with_stencil = yes	; (default 'yes')
-
-  ; Directly set the discontinuous    | Passer automatiquement en mode de
-  ; freehand drawing mode after brush | dessin discontinu après la prise d'une
-  ; grabbing.                         | brosse.
-  Auto_discontinuous = no	; (default 'no')
-
-  ; Save the screen dimensions in GIF | Sauver les dimensions de l'écran dans
-  ; files. If you want to read these  | les fichiers GIF. Si vous voulez lire
-  ; files with Photoshop or Alchemy,  | ces fichiers avec Photoshop ou Alchemy,
-  ; and maybe some other programs, you| et peut-être d'autres programmes, vous
-  ; must set this option to 'no'.     | devez mettre cette option à 'no'.
-  Save_screen_size_in_GIF = no	; (default 'no')
-
-  ; Automaticaly count the number of  | Compter automatiquement le nombre de
-  ; different colors used when opening| couleurs différentes utilisées lors de
-  ; the palette editor window. (Set it| d'ouverture de la fenêtre d'édition de
-  ; to 'no' if you have a slow PC or  | la palette. (Mettez-le à 'no' si vous
-  ; if you edit huge pictures)        | avez un PC lent ou bien si vous éditez
-  ;                                   | d'énormes images).
-  Auto_nb_colors_used = yes     ; (default 'yes')
-
-  ; Default video mode at startup     | Mode vidéo par défaut au
-  ; (see the list by running the      | démarrage (voir la liste en lançant
-  ; program with argument "/?".       | le programme avec l'option "/?".
-  Default_video_mode = window	; (default 'window')
-
-  ; Window dimensions. The program    | Dimensions de la fenêtre en mode 
-  ; remembers the last window size.   | fenêtré.
-  Default_window_size = 640,480 ; (default '640,480')
-
-  ; This setting allows you merge successive mouse movements into a single
-  ; mouse movement. You should only use it if you are using a mouse which
-  ; reports at 200Hz or more, and you experience lag when using discontinuous
-  ; hand-drawing with large brushes (this tool tries to paste the brush and
-  ; update the screen on each new mouse position) In this case, set this to 2
-  ; or more, to ignore some intermediate mouse reports when a more recent one
-  ; is present.
-  ; Note that with a value superior to 1, you lose precision with continuous
-  ; hand-drawing, as intermediate mouse positions are skipped.
-  Merge_movement = 0 ; (default 0)
-
-  ; Number of columns in the palette of the menu bar. Can be any number from
-  ; 1 to 256. If there is not enough room, the program will display less
-  ; columns. But your preference will be kept, and as soon as there is more
-  ; space in the screen, more columns will be shown.
-  ; 
-  Palette_Cells_X = 8; (Default 8)
-  
-  ; Number of lines in the palette of the menu. Can be any number from
-  ; 1 to 16. The menu can always display the number of lines you request.
-  ; 
-  Palette_Cells_Y = 8; (Default 8)
-
-  ; Bookmarked directories. Leave the directory blank for unused ones.
-  ;
-  Bookmark_label = 
-  Bookmark_directory = 
-
-  Bookmark_label = 
-  Bookmark_directory = 
-
-  Bookmark_label =
-  Bookmark_directory = 
-
-  Bookmark_label = 
-  Bookmark_directory = 
-
-  ; In the classic layout, the palette in the menu has colors from left to
-  ; right. If you prefer the colors ordered top to bottom, set this option
-  ; to YES.
-  ; 
-  Palette_vertical = NO; (Default NO)
-
-  ; The program remembers the last window position, if the
-  ; OS isn't able to do it by itself. (ie: Windows)
-  Window_position = 9999,9999; (Default 9999,9999 which means: NA)
-
-  ; This is the time (in milliseconds) between two clicks for Grafx2 to
-  ; recognize a double-click. Double-click is used mostly in the palette
-  ; area of the menu: double-click a color to open the palette.
-  Double_click_speed = 500; (Default 500)
-
-  ; When you press two digit keys in rapid succession (ex: 3 8), Grafx2
-  ; sets transparency to 38% (instead of 30% then 80%). This setting
-  ; allows you to set the maximum delay between two keypresses for
-  ; GrafX2 to recognize them as a combo.
-  Double_key_speed = 500; (Default 500)
-
-  ; Name of the skinfile you want to  | Nom du fichier skin que vous voulez
-  ; use.                              | utiliser.
-  ; Default : (empty to let the program choose)
-  Skin_file = 
-
-  ; Name of the font file (8x8) you   | Nom du fichier police de caractère
-  ; want to use.                      | 8x8 utilisée dans les menus.
-  ; Default : (empty to let the program choose)
-  Font_file = 
-
-  ; This determines the color value for the grid. Each pixel of 
-  ; the grid will be displayed by XOR-ing the original color with
-  ; the value of this setting.
-  ; For example, if you always paint 16-color images, you can set it
-  ; to 16 so the color of the grid are 16 for 0, 17 for 1, etc.
-  ; Then you can set colors 16-31 as lighter/darker variants
-  ; of your original palette, resulting in a pretty grid !
-  ;
-  ; Valid values are 1 to 255. 
-  Grid_XOR_color = 255; (Default 255)
-
-  ; This records the last pixel ratio used, to restore it on start.
-  ; Valid values are from 0 to 7 for: Simple, Wide, Tall, Double,
-  ; Triple, Wide2, Tall2, Quadruple.
-  ;
-  Pixel_ratio = 0; (Default 0)
-
-  ; This records the visibility of toolbars, to restore them on start.
-  ; It's a bitfield, where 1=Status, 2=Layers, 4=Tools
-  ;
-  Menubars_visible = 255; (Default 255)
-  
-  ; end of configuration
+###### GrafX2 initialization file ###### Fichier d'initialisation de GrafX2 ##
+#                                     #                                      #                                                                          #
+# You may modify this file with any   # Vous pouvez modifier ce fichier avec #
+# standard ASCII text editor.         # n'importe quel Ã©diteur de texte      #
+#                                     # ASCII standard.                      #
+#                                     #                                      #
+# Comments are preceded by ';' or     # Les commentaires sont prÃ©cÃ©dÃ©s par   #
+# '#'.                                # ';' ou '#'.                          #
+#                                     #                                      #
+# Options are not case sensitive and  # Les options ne sont pas sensibles Ã   #
+# spaces are ignored.                 # la casse et les espaces sont ignorÃ©s.#
+#                                     #                                      #
+# You must not change the order of    # Vous ne devez pas changer l'ordre    #
+# the sections and their options.     # des sections et de leurs options.    #
+# You must not delete or put into     # Vous ne devez pas effacer ou mettre  #
+# comment any section nor option.     # en commentaire une section ou option.#
+#                                     #                                      #
+# Each option is preceded by a        # Chaque option est prÃ©cÃ©dÃ©e par un    #
+# comment which explains its meaning. # commentaire qui explique sa fonction.#
+#                                     #                                      #
+##############################################################################
+
+
+
+[MOUSE]                               # [SOURIS]
+
+  ; The sensitivity of the mouse can  | La sensibilitÃ© de la souris peut
+  ; take values from 1 to 4. The      | prendre des valeurs de 1 Ã  4. Plus
+  ; smaller values, the faster.       | les valeurs sont petites, plus c'est
+  ; This only takes effect in         | rapide. Ce paramÃ©trage n'est utilisÃ©
+  ; fullscreen modes.                 | que dans les modes "plein Ã©cran".
+  ;                                   | 
+  X_sensitivity = 1	; (default 1)
+  Y_sensitivity = 1	; (default 1)
+
+  ; Unused setting, only kept for compatibility.
+  X_correction_factor = 0	; (default 0)
+  Y_correction_factor = 0	; (default 0)
+
+  ; Aspect of the main cursor (cross) | Aspect du curseur principal (croix)
+  ; 1: Solid                          | 1: Solide
+  ; 2: Transparent                    | 2: Transparent
+  ; 3: Thin (solid)                   | 3: Fin (solide)
+  Cursor_aspect = 1	; (default 1)
+
+[MENU]                                # [MENU]
+
+  ; Colors of the menus (the black    | Couleurs des menus (la couleur noire
+  ; and the white colors cannot be    | et la couleur blanche ne peuvent pas
+  ; modified).                        | Ãªtre modifiÃ©es).
+  ; Values are in {Red,Green,Blue}    | Les valeurs sont dans l'ordre {Rouge,
+  ; order and are between 0 and 63.   | Vert,Bleu} et vont de 0 Ã  63.
+  Light_color = 42,42,42	; (default 42,42,42)
+  Dark_color  = 27,27,27	; (default 27,27,27)
+  ;
+  ;  Light_color = 24,25,30	; \_ Nightmare
+  ;  Dark_color  = 13,14,19	; /
+  ;
+  ;  Light_color = 10,45,28	; \_ Forest
+  ;  Dark_color  =  5,27,12	; /
+  ;
+  ;  Light_color = 48,41,26	; \_ Gold
+  ;  Dark_color  = 26,22,15	; /
+  ;
+  ;  Light_color = 10,40,55	; \_ Oceanic
+  ;  Dark_color  = 10,20,32	; /
+
+  ; Aspect ratio and size of the      | Proportion des menus et de la barre
+  ; menus and the tool-bar.           | d'outils.
+  ; Possible values:                  | Valeurs possibles:
+  ; 0: Do not adapt (pixels are not   | 0: Ne pas adapter (les pixels ne sont
+  ;    stretched)                     |    pas Ã©tirÃ©s)
+  ; 1: Adapt the menus and the tool-  | 1: Adapter les menus et la barre
+  ;    bar according to the resolution|    d'outils suivant la rÃ©solution
+  ; 2: Slightly adapt the ratio of    | 2: Adapter lÃ©gÃ¨rement les proportions
+  ;    the menus and tool-bar         |    des menus et de la barre d'outils
+  ; -1:Do not adapt (like 0)          | -1:Ne pas adapter (comme 0)
+  ; -2:Stretch by x2 maximum          | -2:Etire au double de taille si possible
+  ; -3:Stretch by x3 maximum          | -3:Etire au triple de taille si possible  
+  ; -4:Stretch by x4 maximum          | -3:Etire au quadruple de taille si
+  ;                                   |    possible.
+  Menu_ratio = -2	; (default -2)
+
+[FILE_SELECTOR]                       # [SELECTEUR_DE_FICHIERS]
+
+  ; Show hidden files and             | Afficher les fichiers et rÃ©pertoires
+  ; directories (values are 'yes' or  | cachÃ©s (les valeurs sont 'yes' ou
+  ; 'no').                            | 'no').
+  Show_hidden_files       = no	; (default 'no')
+  Show_hidden_directories = no	; (default 'no')
+
+  ; Delay before displaying a preview | DÃ©lai avant d'afficher une preview
+  ; in file-selectors (in 18.2th of   | dans les sÃ©lecteurs de fichiers (en
+  ; second). Possible values range    | 18.2Ã¨mes de seconde) Les valeurs
+  ; from 1 to 256.                    | possibles vont de 1 Ã  256.
+  Preview_delay = 8	; (default 8)
+
+  ; Maximize the preview of the       | Maximiser la preview des images pour
+  ; pictures so that it is as big as  | qu'elle soit aussi grande que
+  ; possible. If you're not in the    | possible.
+  ; same resolution as the picture's  | Si vous n'Ãªtes pas dans la mÃªme rÃ©so-
+  ; one, it can try to correct the    | lution que celle de l'image, cela peut
+  ; aspect ratio, but if the picture  | essayer de corriger les proportions,
+  ; does not fill the whole screen,   | mais si l'image ne prend pas tout
+  ; it can be worse.                  | l'Ã©cran, cela peut Ãªtre pire.
+  Maximize_preview = no	; (default 'no')
+
+  ; This option is used to place the  | Cette option est utilisÃ©e pour placer
+  ; selection bar on a filename by    | la barre de sÃ©lection sur un nom de
+  ; typing its first letters.         | fichier en tapant ses 1Ã¨res lettres.
+  ; For example, if you want to find  | Par exemple, si vous voulez trouver le
+  ; the "PICTURE.PKM" in a directory  | fichier "PICTURE.PKM" dans un rÃ©per-
+  ; that also contains "PALETTE.PAL", | toire contenant Ã©galement le fichier
+  ; you'll just have to type P and I. | "PALETTE.PAL", vous n'aurez qu'Ã  taper
+  ; The different values of "FFF"     | P puis I.
+  ; indicate if you want to find the  | Les different valeurs de "FFF"
+  ; name in both files and directories| indiquent si vous voulez trouvez le nom
+  ; or just in only one of these:     | dans les fichiers ET les rÃ©pertoires ou
+  ; 0: files and directories          | simplement dans l'un OU l'autre.
+  ; 1: files only                     | 0: fichiers et rÃ©pertoires
+  ; 2: directories only               | 1: fichiers seulement
+  ;                                   | 2: rÃ©pertoires seulement
+  Find_file_fast = 0	; (default 0)
+
+
+[LOADING]                             # [CHARGEMENT]
+
+  ; Automatically set the resolution  | Passer automatiquement dans la bonne
+  ; when loading a picture.           | rÃ©solution lors du chargement d'une
+  ; You should set this value to      | image.
+  ; 'yes' after disabling the video   | Vous devriez dÃ©finir cette option Ã 
+  ; modes that are not supported by   | 'yes' aprÃ¨s avoir inhibÃ© les modes
+  ; your video card or monitor.       | vidÃ©o qui ne sont pas supportÃ©s par
+  ;                                   | votre matÃ©riel.
+  Auto_set_resolution = no	; (default 'no')
+
+  ; If the variable above is set to   | Si la variable ci-dessus est Ã  'yes',
+  ; 'yes', this one tells if you want | celle-ci indique si vous voulez
+  ; to set the resolution according   | dÃ©finir la rÃ©solution suivant:
+  ; to:                               | 1: les dimensions de "l'Ã©cran
+  ; 1: the internal "original screen" |    d'origine" internes Ã  l'image
+  ;    dimensions of the picture      | 2: les vÃ©ritables dimensions de
+  ; 2: the actual dimensions of the   |    l'image
+  ;    picture                        |
+  Set_resolution_according_to = 1	; (default 1)
+
+  ; If you load a picture with a      | Si vous chargez une image ayant une
+  ; palette of less than 256 colors,  | palette de moins de 256 couleurs,
+  ; this option defines if you want   | cette option indique si vous souhaitez
+  ; to clear the palette or to keep   | effacer la palette ou bien conserver
+  ; the colors of the previous        | les couleurs de l'image prÃ©cÃ©dente qui
+  ; picture that are over the number  | se situent au-delÃ  du nombre de la
+  ; of colors of the new picture.     | nouvelle image.
+  ; For example, if you load a        | Par exemple, si vous chargez une image
+  ; 32-color picture, the colors 32   | de 32 couleurs, les couleurs 32 Ã  255
+  ; to 255 will be set to black if    | seront passÃ©es en noir si cette option
+  ; this option is set to 'yes', or   | est Ã  'yes', ou bien elles resteront
+  ; they will be kept unchanged if    | inchangÃ©es si elle est Ã  'no'.
+  ; this option is set to 'no'.       |
+  Clear_palette = yes	; (default 'yes')
+
+
+[MISCELLANEOUS]                       # [DIVERS]
+
+  ; Draw the limits of the picture.   | Afficher les limites de l'image
+  Draw_limits = yes	; (default 'yes')
+
+  ; Adjust the brush grabbing in      | Ajuster la capture de brosse en mode
+  ; "grid" mode.                      | "grille".
+  Adjust_brush_pick = yes	; (default 'yes')
+
+  ; Coordinates:                      | CoordonnÃ©es:
+  ; 1: Relative                       | 1: Relatives
+  ; 2: Absolute                       | 2: Absolues
+  Coordinates = 1	; (default 1)
+
+  ; Create a backup file when saving. | CrÃ©er un fichier backup lors des
+  ;                                   | sauvegardes.
+  Backup = no	; (default 'no')
+
+  ; Number of pages stored in memory  | Nombre de pages stockÃ©es en mÃ©moire
+  ; for "undoing".                    | destinÃ©es Ã  annuler les derniÃ¨res
+  ; Values are between 1 and 99.      | modifications. Valeurs entre 1 et 99.
+  Undo_pages = 10	; (default 10)
+
+  ; Speed of the scroll-bars (in VBLs | Vitesse des barre de dÃ©filement (en
+  ; waited) while clicking with the   | VBLs attendus) lorsque l'un des
+  ; left or right button of the mouse.| boutons de la souris est enfoncÃ©.
+  ; Values can be between 1 and 255.  | Les valeurs sont comprises entre 1 et
+  ; The bigger values, the slower.    | 255. Plus elles sont grandes, plus
+  ;                                   | c'est lent.
+  Gauges_scrolling_speed_Left  = 10	; (default 10)
+  Gauges_scrolling_speed_Right = 3	; (default 3)
+
+  ; Automatically save the configu-   | Enregistre automatiquement la configu-
+  ; ration when exiting the program.  | ration lorsqu'on quitte le programme.
+  Auto_save = yes	; (default 'yes')
+
+  ; Maximum number of vertices used   | Nombre maximum de vertex utilisÃ©s dans
+  ; in filled polygons and polyforms, | les polygÃ´nes et polyformes pleins, et
+  ; and lasso. Possible values range  | le lasso. Les valeurs possibles vont
+  ; from 2 to 16384.                  | de 2 Ã  16384.
+  ; Each vertex takes 4 bytes.        | Chaque vertex prend 4 octets.
+  Vertices_per_polygon = 1024	; (default 1024)
+
+  ; Automatically zoom into the       | Zoomer automatiquement la zone pointÃ©e
+  ; pointed area when you press the   | par la souris lorsque vous appuyez sur
+  ; short-key of the Magnifier button | la touche de raccourci de la loupe.
+  ; while being above the picture.    |
+  Fast_zoom = yes	; (default 'yes')
+
+  ; Separate the colors in the tool-  | SÃ©parer les couleurs dans la barre
+  ; bar by a black squaring.          | d'outils par un quadrillage noir.
+  Separate_colors = no	; (default 'no')
+
+  ; Initial value of the feedback for | Valeur initiale du "feedback" pour les
+  ; the drawing modes (cf. docs).     | modes de dessin (cf. docs).
+  FX_feedback = yes	; (default 'yes')
+
+  ; When you reduce the palette or    | Si vous rÃ©duisez la palette ou "zappez"
+  ; "zap" some colors out of it, it is| quelques couleurs, il est possible
+  ; possible that there are not enough| qu'il ne reste pas assez de couleurs
+  ; colors left to draw the menus.    | pour afficher les menus. Mettre cette
+  ; Switching the following variable  | variable Ã  'yes' ramÃ¨nera automatiquent
+  ; on will bring back the colors of  | les couleurs du menu s'il reste moins
+  ; the menu if there are less than 4 | de 4 couleurs aprÃ¨s une "rÃ©duction" ou
+  ; colors left after "reducing" or   | un "zapping".
+  ; "zapping".                        |
+  Safety_colors = yes	; (default 'yes')
+
+  ; Display a message at startup      | Afficher un message au dÃ©marrage
+  ; telling the version number of the | indiquant le numÃ©ro de version du
+  ; program.                          | programme.
+  Opening_message = yes	; (default 'yes')
+
+  ; Take the Stencil into account when| Prendre le Stencil en compte lorsqu'on
+  ; clearing the image.               | efface l'image.
+  Clear_with_stencil = yes	; (default 'yes')
+
+  ; Directly set the discontinuous    | Passer automatiquement en mode de
+  ; freehand drawing mode after brush | dessin discontinu aprÃ¨s la prise d'une
+  ; grabbing.                         | brosse.
+  Auto_discontinuous = no	; (default 'no')
+
+  ; Save the screen dimensions in GIF | Sauver les dimensions de l'Ã©cran dans
+  ; files. If you want to read these  | les fichiers GIF. Si vous voulez lire
+  ; files with Photoshop or Alchemy,  | ces fichiers avec Photoshop ou Alchemy,
+  ; and maybe some other programs, you| et peut-Ãªtre d'autres programmes, vous
+  ; must set this option to 'no'.     | devez mettre cette option Ã  'no'.
+  Save_screen_size_in_GIF = no	; (default 'no')
+
+  ; Automaticaly count the number of  | Compter automatiquement le nombre de
+  ; different colors used when opening| couleurs diffÃ©rentes utilisÃ©es lors de
+  ; the palette editor window. (Set it| d'ouverture de la fenÃªtre d'Ã©dition de
+  ; to 'no' if you have a slow PC or  | la palette. (Mettez-le Ã  'no' si vous
+  ; if you edit huge pictures)        | avez un PC lent ou bien si vous Ã©ditez
+  ;                                   | d'Ã©normes images).
+  Auto_nb_colors_used = yes     ; (default 'yes')
+
+  ; Default video mode at startup     | Mode vidÃ©o par dÃ©faut au
+  ; (see the list by running the      | dÃ©marrage (voir la liste en lanÃ§ant
+  ; program with argument "/?".       | le programme avec l'option "/?".
+  Default_video_mode = window	; (default 'window')
+
+  ; Window dimensions. The program    | Dimensions de la fenÃªtre en mode 
+  ; remembers the last window size.   | fenÃªtrÃ©.
+  Default_window_size = 320,200 ; (default '640,480')
+
+  ; This setting allows you merge successive mouse movements into a single
+  ; mouse movement. You should only use it if you are using a mouse which
+  ; reports at 200Hz or more, and you experience lag when using discontinuous
+  ; hand-drawing with large brushes (this tool tries to paste the brush and
+  ; update the screen on each new mouse position) In this case, set this to 2
+  ; or more, to ignore some intermediate mouse reports when a more recent one
+  ; is present.
+  ; Note that with a value superior to 1, you lose precision with continuous
+  ; hand-drawing, as intermediate mouse positions are skipped.
+  Merge_movement = 0 ; (default 0)
+
+  ; Number of columns in the palette of the menu bar. Can be any number from
+  ; 1 to 256. If there is not enough room, the program will display less
+  ; columns. But your preference will be kept, and as soon as there is more
+  ; space in the screen, more columns will be shown.
+  ; 
+  Palette_Cells_X = 8; (Default 8)
+  
+  ; Number of lines in the palette of the menu. Can be any number from
+  ; 1 to 16. The menu can always display the number of lines you request.
+  ; 
+  Palette_Cells_Y = 8; (Default 8)
+
+  ; Bookmarked directories. Leave the directory blank for unused ones.
+  ;
+  Bookmark_label = 
+  Bookmark_directory = 
+
+  Bookmark_label = 
+  Bookmark_directory = 
+
+  Bookmark_label =
+  Bookmark_directory = 
+
+  Bookmark_label = 
+  Bookmark_directory = 
+
+  ; In the classic layout, the palette in the menu has colors from left to
+  ; right. If you prefer the colors ordered top to bottom, set this option
+  ; to YES.
+  ; 
+  Palette_vertical = NO; (Default NO)
+
+  ; The program remembers the last window position, if the
+  ; OS isn't able to do it by itself. (ie: Windows)
+  Window_position = 9999,9999; (Default 9999,9999 which means: NA)
+
+  ; This is the time (in milliseconds) between two clicks for Grafx2 to
+  ; recognize a double-click. Double-click is used mostly in the palette
+  ; area of the menu: double-click a color to open the palette.
+  Double_click_speed = 500; (Default 500)
+
+  ; When you press two digit keys in rapid succession (ex: 3 8), Grafx2
+  ; sets transparency to 38% (instead of 30% then 80%). This setting
+  ; allows you to set the maximum delay between two keypresses for
+  ; GrafX2 to recognize them as a combo.
+  Double_key_speed = 500; (Default 500)
+
+  ; Name of the skinfile you want to  | Nom du fichier skin que vous voulez
+  ; use.                              | utiliser.
+  ; Default : (empty to let the program choose)
+  Skin_file = 
+
+  ; Name of the font file (8x8) you   | Nom du fichier police de caractÃ¨re
+  ; want to use.                      | 8x8 utilisÃ©e dans les menus.
+  ; Default : (empty to let the program choose)
+  Font_file = 
+
+  ; This determines the color value for the grid. Each pixel of 
+  ; the grid will be displayed by XOR-ing the original color with
+  ; the value of this setting.
+  ; For example, if you always paint 16-color images, you can set it
+  ; to 16 so the color of the grid are 16 for 0, 17 for 1, etc.
+  ; Then you can set colors 16-31 as lighter/darker variants
+  ; of your original palette, resulting in a pretty grid !
+  ;
+  ; Valid values are 1 to 255. 
+  Grid_XOR_color = 255; (Default 255)
+
+  ; This records the last pixel ratio used, to restore it on start.
+  ; Valid values are from 0 to 7 for: Simple, Wide, Tall, Double,
+  ; Triple, Wide2, Tall2, Quadruple.
+  ;
+  Pixel_ratio = 0; (Default 0)
+
+  ; This records the visibility of toolbars, to restore them on start.
+  ; It's a bitfield, where 1=Status, 2=Layers, 4=Tools
+  ;
+  Menubars_visible = 255; (Default 255)
+  
+  ; end of configuration
diff -ruN gfx2orig/src/brush.c grafx2/src/brush.c
--- gfx2orig/src/brush.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/brush.c	2022-03-20 20:19:34.108495316 -0500
@@ -37,8 +37,8 @@
 #include "brush.h"
 
 
-// Calcul de redimensionnement du pinceau pour éviter les débordements de
-// l'écran et de l'image
+// Calcul de redimensionnement du pinceau pour Ã©viter les dÃ©bordements de
+// l'Ã©cran et de l'image
 void Compute_clipped_dimensions(short * x,short * y,short * width,short * height)
 {
   if ((*x)<Limit_left)
@@ -64,8 +64,8 @@
   }
 }
 
-  // -- Calcul de redimensionnement du pinceau pour éviter les débordements
-  //    de l'écran zoomé et de l'image --
+  // -- Calcul de redimensionnement du pinceau pour Ã©viter les dÃ©bordements
+  //    de l'Ã©cran zoomÃ© et de l'image --
 
 void Compute_clipped_dimensions_zoom(short * x,short * y,short * width,short * height)
 {
@@ -93,24 +93,24 @@
 }
 
 
-  // -- Afficher le pinceau (de façon définitive ou non) --
+  // -- Afficher le pinceau (de faÃ§on dÃ©finitive ou non) --
 
 void Display_paintbrush(short x,short y,byte color,byte is_preview)
   // x,y: position du centre du pinceau
-  // color: couleur à appliquer au pinceau
-  // is_preview: "Il ne faut l'afficher qu'à l'écran"
+  // color: couleur Ã  appliquer au pinceau
+  // is_preview: "Il ne faut l'afficher qu'Ã  l'Ã©cran"
 {
-  short start_x; // Position X (dans l'image) à partir de laquelle on
+  short start_x; // Position X (dans l'image) Ã  partir de laquelle on
         // affiche la brosse/pinceau
-  short start_y; // Position Y (dans l'image) à partir de laquelle on
+  short start_y; // Position Y (dans l'image) Ã  partir de laquelle on
         // affiche la brosse/pinceau
-  short width; // width dans l'écran selon laquelle on affiche la
+  short width; // width dans l'Ã©cran selon laquelle on affiche la
         // brosse/pinceau
-  short height; // height dans l'écran selon laquelle on affiche la
+  short height; // height dans l'Ã©cran selon laquelle on affiche la
         // brosse/pinceau
-  short start_x_counter; // Position X (dans la brosse/pinceau) à partir
+  short start_x_counter; // Position X (dans la brosse/pinceau) Ã  partir
         // de laquelle on affiche la brosse/pinceau
-  short start_y_counter; // Position Y (dans la brosse/pinceau) à partir
+  short start_y_counter; // Position Y (dans la brosse/pinceau) Ã  partir
         // de laquelle on affiche la brosse/pinceau
   short x_pos; // Position X (dans l'image) en cours d'affichage
   short y_pos; // Position Y (dans l'image) en cours d'affichage
@@ -118,9 +118,9 @@
         // d'affichage
   short counter_y; // Position Y (dans la brosse/pinceau) en cours
         // d'affichage
-  short end_counter_x; // Position X ou s'arrête l'affichade de la
+  short end_counter_x; // Position X ou s'arrÃªte l'affichade de la
         // brosse/pinceau
-  short end_counter_y; // Position Y ou s'arrête l'affichade de la
+  short end_counter_y; // Position Y ou s'arrÃªte l'affichade de la
         // brosse/pinceau
   byte  temp_color; // color de la brosse en cours d'affichage
   int position;
@@ -548,25 +548,25 @@
 void Hide_paintbrush(short x,short y)
   // x,y: position du centre du pinceau
 {
-  short start_x; // Position X (dans l'image) à partir de laquelle on
+  short start_x; // Position X (dans l'image) Ã  partir de laquelle on
         // affiche la brosse/pinceau
-  short start_y; // Position Y (dans l'image) à partir de laquelle on
+  short start_y; // Position Y (dans l'image) Ã  partir de laquelle on
         // affiche la brosse/pinceau
-  short width; // width dans l'écran selon laquelle on affiche la
+  short width; // width dans l'Ã©cran selon laquelle on affiche la
         // brosse/pinceau
-  short height; // height dans l'écran selon laquelle on affiche la
+  short height; // height dans l'Ã©cran selon laquelle on affiche la
         // brosse/pinceau
-  short start_x_counter; // Position X (dans la brosse/pinceau) à partir
+  short start_x_counter; // Position X (dans la brosse/pinceau) Ã  partir
         // de laquelle on affiche la brosse/pinceau
-  short start_y_counter; // Position Y (dans la brosse/pinceau) à partir
+  short start_y_counter; // Position Y (dans la brosse/pinceau) Ã  partir
         // de laquelle on affiche la brosse/pinceau
   //short x_pos; // Position X (dans l'image) en cours d'affichage
   //short y_pos; // Position Y (dans l'image) en cours d'affichage
   //short counter_x; // Position X (dans la brosse/pinceau) en cours
         //d'affichage
   //short counter_y; // Position Y (dans la brosse/pinceau) en cours d'affichage
-  short end_counter_x; // Position X ou s'arrête l'affichage de la brosse/pinceau
-  short end_counter_y; // Position Y ou s'arrête l'affichage de la brosse/pinceau
+
+
   byte * temp;
 
   if (Mouse_K == 0)
@@ -591,8 +591,8 @@
       Compute_clipped_dimensions(&start_x,&start_y,&width,&height);
       start_x_counter=start_x-(x-Brush_offset_X);
       start_y_counter=start_y-(y-Brush_offset_Y);
-      end_counter_x=start_x_counter+width;
-      end_counter_y=start_y_counter+height;
+
+
 
       if ( (width>0) && (height>0) )
         Clear_brush(start_x-Main_offset_X,
@@ -632,8 +632,8 @@
       Compute_clipped_dimensions(&start_x,&start_y,&width,&height);
       start_x_counter=start_x-(x-Paintbrush_offset_X);
       start_y_counter=start_y-(y-Paintbrush_offset_Y);
-      end_counter_x=start_x_counter+width;
-      end_counter_y=start_y_counter+height;
+
+
 
       temp=Brush;
       Brush=Paintbrush_sprite;
@@ -705,10 +705,10 @@
 
   if ((start_x<Main_image_width) && (start_y<Main_image_height))
   {
-    // On met les décalages du tiling à 0 pour eviter toute incohérence.
-    // Si par hasard on voulait les mettre à
+    // On met les dÃ©calages du tiling Ã  0 pour eviter toute incohÃ©rence.
+    // Si par hasard on voulait les mettre Ã 
     //    min(Tiling_Decalage_?,Brosse_?a??eur-1)
-    // il faudrait penser à les initialiser à 0 dans "MAIN.C".
+    // il faudrait penser Ã  les initialiser Ã  0 dans "MAIN.C".
     Tiling_offset_X=0;
     Tiling_offset_Y=0;
 
@@ -777,11 +777,11 @@
 {
   short x_pos; // Variable de balayage de la brosse
   short y_pos; // Variable de balayage de la brosse
-  byte  used[256]; // Tableau de booléens "La couleur est utilisée"
+  byte  used[256]; // Tableau de boolÃ©ens "La couleur est utilisÃ©e"
   int   color;
 
 
-  // On commence par initialiser le tableau de booléens à faux
+  // On commence par initialiser le tableau de boolÃ©ens Ã  faux
   for (color=0;color<=255;color++)
     used[color]=0;
 
@@ -790,32 +790,32 @@
     for (x_pos=0;x_pos<Brush_width;x_pos++)
       used[Read_pixel_from_brush(x_pos,y_pos)]=1;
 
-  //  On n'est pas censé remapper la couleur de transparence, sinon la brosse
-  // changera de forme, donc on dit pour l'instant qu'elle n'est pas utilisée
-  // ainsi on ne s'embêtera pas à la recalculer
+  //  On n'est pas censÃ© remapper la couleur de transparence, sinon la brosse
+  // changera de forme, donc on dit pour l'instant qu'elle n'est pas utilisÃ©e
+  // ainsi on ne s'embÃªtera pas Ã  la recalculer
   used[Back_color]=0;
 
   //   On va maintenant se servir de la table "used" comme table de
   // conversion: pour chaque indice, la table donne une couleur de
   // remplacement.
-  // Note : Seules les couleurs utilisées on besoin d'êtres recalculées: les
-  //       autres ne seront jamais consultées dans la nouvelle table de
+  // Note : Seules les couleurs utilisÃ©es on besoin d'Ãªtres recalculÃ©es: les
+  //       autres ne seront jamais consultÃ©es dans la nouvelle table de
   //       conversion puisque elles n'existent pas dans la brosse, donc elles
-  //       ne seront pas utilisées par Remap_brush_LOWLEVEL.
+  //       ne seront pas utilisÃ©es par Remap_brush_LOWLEVEL.
   for (color=0;color<=255;color++)
     if (used[color] != 0)
       used[color]=Best_color(Spare_palette[color].R,Spare_palette[color].G,Spare_palette[color].B);
 
-  //   Il reste une couleur non calculée dans la table qu'il faut mettre à
-  // jour: c'est la couleur de fond. On l'avait inhibée pour éviter son
-  // calcul inutile, mais comme il est possible qu'elle soit quand même dans
-  // la brosse, on va mettre dans la table une relation d'équivalence entre
-  // les deux palettes: comme on ne veut pas que la couleur soit remplacée,
-  // on va dire qu'on veut qu'elle soit remplacée par la couleur en question.
+  //   Il reste une couleur non calculÃ©e dans la table qu'il faut mettre Ã 
+  // jour: c'est la couleur de fond. On l'avait inhibÃ©e pour Ã©viter son
+  // calcul inutile, mais comme il est possible qu'elle soit quand mÃªme dans
+  // la brosse, on va mettre dans la table une relation d'Ã©quivalence entre
+  // les deux palettes: comme on ne veut pas que la couleur soit remplacÃ©e,
+  // on va dire qu'on veut qu'elle soit remplacÃ©e par la couleur en question.
   used[Back_color]=Back_color;
 
   //   Maintenant qu'on a une super table de conversion qui n'a que le nom
-  // qui craint un peu, on peut faire l'échange dans la brosse de toutes les
+  // qui craint un peu, on peut faire l'Ã©change dans la brosse de toutes les
   // teintes.
   Remap_general_lowlevel(used,Brush,Brush_width,Brush_height,Brush_width);
   //Remap_brush_LOWLEVEL(used);
@@ -839,7 +839,7 @@
 
   if (new_brush)
   {
-    // On remplit la bordure ajoutée par la Backcolor
+    // On remplit la bordure ajoutÃ©e par la Backcolor
     memset(new_brush,Back_color,((long)width)*height);
 
     // On copie la brosse courante dans la nouvelle
@@ -856,7 +856,7 @@
     width-=2;
     height-=2;
 
-    // Si on "outline" avec une couleur différente de la Back_color on y va!
+    // Si on "outline" avec une couleur diffÃ©rente de la Back_color on y va!
     if (Fore_color!=Back_color)
     {
       // 1er balayage (horizontal)
@@ -879,12 +879,12 @@
             state=1;
           }
         }
-        // Cas du dernier pixel à droite de la ligne
+        // Cas du dernier pixel Ã  droite de la ligne
         if (state != 0)
           Pixel_in_brush(x_pos,y_pos,Fore_color);
       }
 
-      // 2ème balayage (vertical)
+      // 2Ã¨me balayage (vertical)
       for (x_pos=1; x_pos<Brush_width-1; x_pos++)
       {
         state=0;
@@ -914,17 +914,17 @@
     Brush_offset_X=(Brush_width>>1);
     Brush_offset_Y=(Brush_height>>1);
 
-    free(temp); // Libération de l'ancienne brosse
+    free(temp); // LibÃ©ration de l'ancienne brosse
     temp = NULL;
 
-    // Réallocation d'un buffer de Smear
+    // RÃ©allocation d'un buffer de Smear
     free(Smear_brush);
     Smear_brush_width=(Brush_width>MAX_PAINTBRUSH_SIZE)?Brush_width:MAX_PAINTBRUSH_SIZE;
     Smear_brush_height=(Brush_height>MAX_PAINTBRUSH_SIZE)?Brush_height:MAX_PAINTBRUSH_SIZE;
     Smear_brush=(byte *)malloc(((long)Smear_brush_width)*Smear_brush_height);
   }
   else
-    Error(0); // Pas assez de mémoire!
+    Error(0); // Pas assez de mÃ©moire!
 }
 
 
@@ -989,12 +989,12 @@
             }
           }
         }
-        // Cas du dernier pixel à droite de la ligne
+        // Cas du dernier pixel Ã  droite de la ligne
         if (temp[((y_pos+1)*width)+x_pos+1]==Back_color)
           Pixel_in_brush(x_pos-1,y_pos,Back_color);
       }
 
-      // 2ème balayage (vertical)
+      // 2Ã¨me balayage (vertical)
       for (x_pos=0; x_pos<Brush_width; x_pos++)
       {
         state=(temp[width+x_pos+1]!=Back_color);;
@@ -1027,17 +1027,17 @@
       Brush_offset_X=(Brush_width>>1);
       Brush_offset_Y=(Brush_height>>1);
 
-      free(temp); // Libération de l'ancienne brosse
+      free(temp); // LibÃ©ration de l'ancienne brosse
       temp = NULL;
 
-      // Réallocation d'un buffer de Smear
+      // RÃ©allocation d'un buffer de Smear
       free(Smear_brush);
       Smear_brush_width=(Brush_width>MAX_PAINTBRUSH_SIZE)?Brush_width:MAX_PAINTBRUSH_SIZE;
       Smear_brush_height=(Brush_height>MAX_PAINTBRUSH_SIZE)?Brush_height:MAX_PAINTBRUSH_SIZE;
       Smear_brush=(byte *)malloc(((long)Smear_brush_width)*Smear_brush_height);
     }
     else
-      Error(0);  // Pas assez de mémoire!
+      Error(0);  // Pas assez de mÃ©moire!
   }
 }
 
@@ -1071,7 +1071,7 @@
       end_y=y_pos;
   }
 
-  // On clippe ces bornes à l'écran:
+  // On clippe ces bornes Ã  l'Ã©cran:
   if (start_x<Limit_left)
     start_x=Limit_left;
   if (end_x>Limit_right)
@@ -1086,10 +1086,10 @@
 
   if ((start_x<Main_image_width) && (start_y<Main_image_height))
   {
-    // On met les décalages du tiling à 0 pour eviter toute incohérence.
-    // Si par hasard on voulait les mettre à
+    // On met les dÃ©calages du tiling Ã  0 pour eviter toute incohÃ©rence.
+    // Si par hasard on voulait les mettre Ã 
     //    min(Tiling_Decalage_?,Brosse_?a??eur-1)
-    // il faudrait penser à les initialiser à 0 dans "MAIN.C".
+    // il faudrait penser Ã  les initialiser Ã  0 dans "MAIN.C".
     Tiling_offset_X=0;
     Tiling_offset_Y=0;
 
@@ -1120,7 +1120,7 @@
     Smear_brush_height=(Brush_height>MAX_PAINTBRUSH_SIZE)?Brush_height:MAX_PAINTBRUSH_SIZE;
     Smear_brush=(byte *)malloc(((long)Smear_brush_height)*Smear_brush_width);
 
-    if (!Smear_brush) // On ne peut même pas allouer la brosse du smear!
+    if (!Smear_brush) // On ne peut mÃªme pas allouer la brosse du smear!
     {
       Error(0);
 
@@ -1153,7 +1153,7 @@
                          points[0],points[1],
                          ~Back_color);
 
-    // On scanne la brosse pour remplacer tous les pixels affectés par le
+    // On scanne la brosse pour remplacer tous les pixels affectÃ©s par le
     // polyfill par ceux de l'image:
     for (y_pos=start_y;y_pos<=end_y;y_pos++)
       for (x_pos=start_x;x_pos<=end_x;x_pos++)
@@ -1180,19 +1180,19 @@
   byte * new_brush;
   int    new_brush_width;  // Width de la nouvelle brosse
   int    new_brush_height;  // Height de la nouvelle brosse
-  int    x_flipped, y_flipped;
+
   
   // Compute new brush dimensions
   if ((new_brush_width=x1-x2)<0)
   {
-    x_flipped=1;
+
     new_brush_width=-new_brush_width;
   }
   new_brush_width++;
 
   if ((new_brush_height=y1-y2)<0)
   {
-    y_flipped=1;
+
     new_brush_height=-new_brush_height;
   }
   new_brush_height++;
@@ -1215,7 +1215,7 @@
     Smear_brush_height=(Brush_height>MAX_PAINTBRUSH_SIZE)?Brush_height:MAX_PAINTBRUSH_SIZE;
     Smear_brush=(byte *)malloc(((long)Smear_brush_height)*Smear_brush_width);
 
-    if (!Smear_brush) // On ne peut même pas allouer la brosse du smear!
+    if (!Smear_brush) // On ne peut mÃªme pas allouer la brosse du smear!
     {
       Error(0);
 
@@ -1234,9 +1234,9 @@
   }
   else
   {
-    // Ici la libération de mémoire n'a pas suffi donc on remet dans l'état
-    // où c'etait avant. On a juste à réallouer la Smear_brush car il y a
-    // normalement la place pour elle puisque rien d'autre n'a pu être alloué
+    // Ici la libÃ©ration de mÃ©moire n'a pas suffi donc on remet dans l'Ã©tat
+    // oÃ¹ c'etait avant. On a juste Ã  rÃ©allouer la Smear_brush car il y a
+    // normalement la place pour elle puisque rien d'autre n'a pu Ãªtre allouÃ©
     // entre temps.
     Smear_brush=(byte *)malloc(((long)Smear_brush_height)*Smear_brush_width);
     Error(0);
@@ -1267,7 +1267,7 @@
   dest_width=final_dest_x_pos-initial_dest_x_pos+1;
   dest_height=final_dest_y_pos-initial_dest_y_pos+1;
 
-  // Calcul des vecteurs d'incrémentation :
+  // Calcul des vecteurs d'incrÃ©mentation :
   delta_x=(Brush_width<<16)/dest_width;
   delta_y=(Brush_height<<16)/dest_height;
 
@@ -1608,7 +1608,7 @@
       {
         xt=(((float)((x_pos-start_x)*delta_xt))/(float)delta_x2) + (float)xt1;
         yt=(((float)((x_pos-start_x)*delta_yt))/(float)delta_x2) + (float)yt1;
-        if (isnan(ScanY_X[0][y_pos])) // Gauche non défini
+        if (isnan(ScanY_X[0][y_pos])) // Gauche non dÃ©fini
         {
           ScanY_X[0][y_pos]=(float)x_pos;
           ScanY_Xt[0][y_pos]=xt;
@@ -1618,7 +1618,7 @@
         {
           if ((float)x_pos>=ScanY_X[0][y_pos])
           {
-            if (isnan(ScanY_X[1][y_pos]) // Droit non défini
+            if (isnan(ScanY_X[1][y_pos]) // Droit non dÃ©fini
              || (x_pos>ScanY_X[1][y_pos]))
             {
               ScanY_X[1][y_pos]=(float)x_pos;
@@ -1628,7 +1628,7 @@
           }
           else
           {
-            if (isnan(ScanY_X[1][y_pos])) // Droit non défini
+            if (isnan(ScanY_X[1][y_pos])) // Droit non dÃ©fini
             {
               ScanY_X[1][y_pos]=ScanY_X[0][y_pos];
               ScanY_Xt[1][y_pos]=ScanY_Xt[0][y_pos];
@@ -1665,7 +1665,7 @@
       {
         xt=(((float)((y_pos-start_y)*delta_xt))/(float)delta_y2) + (float)xt1;
         yt=(((float)((y_pos-start_y)*delta_yt))/(float)delta_y2) + (float)yt1;
-        if (isnan(ScanY_X[0][y_pos])) // Gauche non défini
+        if (isnan(ScanY_X[0][y_pos])) // Gauche non dÃ©fini
         {
           ScanY_X[0][y_pos]=(float)x_pos;
           ScanY_Xt[0][y_pos]=xt;
@@ -1675,7 +1675,7 @@
         {
           if ((float)x_pos>=ScanY_X[0][y_pos])
           {
-            if (isnan(ScanY_X[1][y_pos]) // Droit non défini
+            if (isnan(ScanY_X[1][y_pos]) // Droit non dÃ©fini
              || (x_pos>ScanY_X[1][y_pos]))
             {
               ScanY_X[1][y_pos]=(float)x_pos;
@@ -1685,7 +1685,7 @@
           }
           else
           {
-            if (isnan(ScanY_X[1][y_pos])) // Droit non défini
+            if (isnan(ScanY_X[1][y_pos])) // Droit non dÃ©fini
             {
               ScanY_X[1][y_pos]=ScanY_X[0][y_pos];
               ScanY_Xt[1][y_pos]=ScanY_Xt[0][y_pos];
@@ -1733,7 +1733,7 @@
   ScanY_X[0] =(float *)malloc(height*sizeof(float));
   ScanY_X[1] =(float *)malloc(height*sizeof(float));
 
-  // Fill_general avec des valeurs égales à NAN.
+  // Fill_general avec des valeurs Ã©gales Ã  NAN.
   for (y=0; y<height; y++)
   {
     ScanY_X[0][y]=NAN ;
@@ -1790,7 +1790,7 @@
   float cos_a=cos(angle);
   float sin_a=sin(angle);
 
-  // Calcul des coordonnées des 4 coins:
+  // Calcul des coordonnÃ©es des 4 coins:
   // 1 2
   // 3 4
 
@@ -1813,12 +1813,12 @@
   new_brush_width=x_max+1-x_min;
   new_brush_height=y_max+1-y_min;
 
-  free(Smear_brush); // On libère un peu de mémoire
+  free(Smear_brush); // On libÃ¨re un peu de mÃ©moire
   Smear_brush = NULL;
 
   if ((new_brush=((byte *)malloc(new_brush_width*new_brush_height))))
   {
-    // Et maintenant on calcule la nouvelle brosse tournée.
+    // Et maintenant on calcule la nouvelle brosse tournÃ©e.
     Compute_quad_texture(x1,y1,               0,               0,
                           x2,y2,Brush_width-1,               0,
                           x3,y3,               0,Brush_height-1,
@@ -1835,7 +1835,7 @@
     Smear_brush_height=(Brush_height>MAX_PAINTBRUSH_SIZE)?Brush_height:MAX_PAINTBRUSH_SIZE;
     Smear_brush=(byte *)malloc(((long)Smear_brush_height)*Smear_brush_width);
 
-    if (!Smear_brush) // On ne peut même pas allouer la brosse du smear!
+    if (!Smear_brush) // On ne peut mÃªme pas allouer la brosse du smear!
     {
       Error(0);
 
@@ -1854,9 +1854,9 @@
   }
   else
   {
-    // Ici la libération de mémoire n'a pas suffit donc on remet dans l'état
-    // où c'etait avant. On a juste à réallouer la Smear_brush car il y a
-    // normalement la place pour elle puisque rien d'autre n'a pu être alloué
+    // Ici la libÃ©ration de mÃ©moire n'a pas suffit donc on remet dans l'Ã©tat
+    // oÃ¹ c'etait avant. On a juste Ã  rÃ©allouer la Smear_brush car il y a
+    // normalement la place pour elle puisque rien d'autre n'a pu Ãªtre allouÃ©
     // entre temps.
     Smear_brush=(byte *)malloc(((long)Smear_brush_height)*Smear_brush_width);
     Error(0);
@@ -1870,15 +1870,15 @@
                                    int x3,int y3,int xt3,int yt3,
                                    int x4,int y4,int xt4,int yt4)
 {
-  int x_min,x_max,y_min,y_max;
+  int y_min,y_max;
   int x,y,xt,yt;
   int y_,y_min_;
   int start_x,end_x,width,height;
   float temp;
   byte color;
 
-  x_min=Min(Min(x1,x2),Min(x3,x4));
-  x_max=Max(Max(x1,x2),Max(x3,x4));
+
+
   y_min=Min(Min(y1,y2),Min(y3,y4));
   y_max=Max(Max(y1,y2),Max(y3,y4));
   height=1+y_max-y_min;
@@ -1890,7 +1890,7 @@
   ScanY_X[0] =(float *)malloc(height*sizeof(float));
   ScanY_X[1] =(float *)malloc(height*sizeof(float));
 
-  // Fill_general avec des valeurs égales à NAN.
+  // Fill_general avec des valeurs Ã©gales Ã  NAN.
   for (y=0; y<height; y++)
   {
     ScanY_X[0][y]=NAN;
@@ -1949,7 +1949,7 @@
   float cos_a=cos(angle);
   float sin_a=sin(angle);
 
-  // Calcul des coordonnées des 4 coins:
+  // Calcul des coordonnÃ©es des 4 coins:
   // 1 2
   // 3 4
 
@@ -1972,7 +1972,7 @@
   x4+=Brush_rotation_center_X;
   y4+=Brush_rotation_center_Y;
 
-  // Et maintenant on dessine la brosse tournée.
+  // Et maintenant on dessine la brosse tournÃ©e.
   Draw_quad_texture_preview(x1,y1,               0,               0,
                                 x2,y2,Brush_width-1,               0,
                                 x3,y3,               0,Brush_height-1,
diff -ruN gfx2orig/src/brush_ops.c grafx2/src/brush_ops.c
--- gfx2orig/src/brush_ops.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/brush_ops.c	2022-03-20 20:19:34.108495316 -0500
@@ -48,20 +48,20 @@
 {
 
   // Comme l'enclenchement du bouton efface le curseur, il faut l'afficher au
-  // préalable:
+  // prÃ©alable:
   Display_cursor();
   if (Mouse_K)
     Wait_end_of_click();
   // !!! Efface la croix puis affiche le viseur !!!
-  Select_button(BUTTON_DRAW,LEFT_SIDE); // Désenclenche au passage le bouton brosse
+  Select_button(BUTTON_DRAW,LEFT_SIDE); // DÃ©senclenche au passage le bouton brosse
   if (Config.Auto_discontinuous)
   {
-    // On se place en mode Dessin discontinu à la main
+    // On se place en mode Dessin discontinu Ã  la main
     while (Current_operation!=OPERATION_DISCONTINUOUS_DRAW)
       Select_button(BUTTON_DRAW,RIGHT_SIDE);
   }
-  // Maintenant, il faut réeffacer le curseur parce qu'il sera raffiché en fin
-  // d'appel à cette action:
+  // Maintenant, il faut rÃ©effacer le curseur parce qu'il sera raffichÃ© en fin
+  // d'appel Ã  cette action:
   Hide_cursor();
 
   // On passe en brosse couleur:
@@ -77,32 +77,32 @@
 
 void Magnifier_12_0(void)
 
-// Opération   : 4      (item d'une Loupe)
+// OpÃ©ration   : 4      (item d'une Loupe)
 // Click Souris: 1 ou 2
 // Taille_Pile : 0
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 
 {
 
   // On passe en mode loupe
   Main_magnifier_mode=1;
 
-  // La fonction d'affichage dans la partie image est désormais un affichage
-  // spécial loupe.
+  // La fonction d'affichage dans la partie image est dÃ©sormais un affichage
+  // spÃ©cial loupe.
   Pixel_preview=Pixel_preview_magnifier;
 
   // On calcule l'origine de la loupe
   Main_magnifier_offset_X=Mouse_X-(Main_magnifier_width>>1);
   Main_magnifier_offset_Y=Mouse_Y-(Main_magnifier_height>>1);
 
-  // Calcul du coin haut_gauche de la fenêtre devant être zoomée DANS L'ECRAN
+  // Calcul du coin haut_gauche de la fenÃªtre devant Ãªtre zoomÃ©e DANS L'ECRAN
   if (Main_magnifier_offset_X+Main_magnifier_width>=Limit_right-Main_offset_X)
     Main_magnifier_offset_X=Limit_right-Main_magnifier_width-Main_offset_X+1;
   if (Main_magnifier_offset_Y+Main_magnifier_height>=Limit_bottom-Main_offset_Y)
     Main_magnifier_offset_Y=Limit_bottom-Main_magnifier_height-Main_offset_Y+1;
 
-  // Calcul des coordonnées absolues de ce coin DANS L'IMAGE
+  // Calcul des coordonnÃ©es absolues de ce coin DANS L'IMAGE
   Main_magnifier_offset_X+=Main_offset_X;
   Main_magnifier_offset_Y+=Main_offset_Y;
 
@@ -111,15 +111,15 @@
   if (Main_magnifier_offset_Y<0)
     Main_magnifier_offset_Y=0;
 
-  // On calcule les bornes visibles dans l'écran
+  // On calcule les bornes visibles dans l'Ã©cran
   Position_screen_according_to_zoom();
   Compute_limits();
   Display_all_screen();
 
-  // Repositionner le curseur en fonction des coordonnées visibles
+  // Repositionner le curseur en fonction des coordonnÃ©es visibles
   Compute_paintbrush_coordinates();
 
-  // On fait de notre mieux pour restaurer l'ancienne opération:
+  // On fait de notre mieux pour restaurer l'ancienne opÃ©ration:
   Start_operation_stack(Operation_before_interrupt);
   Display_cursor();
   Wait_end_of_click();
@@ -131,11 +131,11 @@
 
 void Colorpicker_12_0(void)
 //
-// Opération   : OPERATION_COLORPICK
+// OpÃ©ration   : OPERATION_COLORPICK
 // Click Souris: 1 ou 2
 // Taille_Pile : 0
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 //
 {
   Init_start_operation();
@@ -154,11 +154,11 @@
 
 void Colorpicker_1_1(void)
 //
-// Opération   : OPERATION_COLORPICK
+// OpÃ©ration   : OPERATION_COLORPICK
 // Click Souris: 1
 // Taille_Pile : 1
 //
-// Souris effacée: Non
+// Souris effacÃ©e: Non
 //
 {
   char str[4];
@@ -196,11 +196,11 @@
 
 void Colorpicker_2_1(void)
 //
-// Opération   : OPERATION_COLORPICK
+// OpÃ©ration   : OPERATION_COLORPICK
 // Click Souris: 2
 // Taille_Pile : 1
 //
-// Souris effacée: Non
+// Souris effacÃ©e: Non
 //
 {
   char str[4];
@@ -239,11 +239,11 @@
 
 void Colorpicker_0_1(void)
 //
-// Opération   : OPERATION_COLORPICK
+// OpÃ©ration   : OPERATION_COLORPICK
 // Click Souris: 0
 // Taille_Pile : 1
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 //
 {
   short click;
@@ -266,31 +266,31 @@
 
 void Brush_12_0(void)
 //
-// Opération   : OPERATION_GRAB_BRUSH
+// OpÃ©ration   : OPERATION_GRAB_BRUSH
 // Click Souris: 1 ou 2
 // Taille_Pile : 0
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 //
 {
   Init_start_operation();
-  if (Mouse_K==RIGHT_SIDE) // Besoin d'effacer la brosse après ?
+  if (Mouse_K==RIGHT_SIDE) // Besoin d'effacer la brosse aprÃ¨s ?
   {
     Operation_push(1);
-    // Puisque la zone où on prend la brosse sera effacée, on fait un backup
+    // Puisque la zone oÃ¹ on prend la brosse sera effacÃ©e, on fait un backup
     Backup();
   }
   else
     Operation_push(0);
 
   // On laisse une trace du curseur pour que l'utilisateur puisse visualiser
-  // où demarre sa brosse:
+  // oÃ¹ demarre sa brosse:
   Display_cursor();
 
-  Operation_push(Paintbrush_X); // Début X
-  Operation_push(Paintbrush_Y); // Début Y
-  Operation_push(Paintbrush_X); // Dernière position X
-  Operation_push(Paintbrush_Y); // Dernière position Y
+  Operation_push(Paintbrush_X); // DÃ©but X
+  Operation_push(Paintbrush_Y); // DÃ©but Y
+  Operation_push(Paintbrush_X); // DerniÃ¨re position X
+  Operation_push(Paintbrush_Y); // DerniÃ¨re position Y
 
   if ((Config.Coords_rel) && (Menu_is_visible))
     Print_in_menu("\035:   1   \022:   1",0);
@@ -299,11 +299,11 @@
 
 void Brush_12_5(void)
 //
-// Opération   : OPERATION_GRAB_BRUSH
+// OpÃ©ration   : OPERATION_GRAB_BRUSH
 // Click Souris: 1 ou 2
 // Taille_Pile : 5
 //
-// Souris effacée: Non
+// Souris effacÃ©e: Non
 //
 {
   char  str[5];
@@ -345,11 +345,11 @@
 
 void Brush_0_5(void)
 //
-// Opération   : OPERATION_GRAB_BRUSH
+// OpÃ©ration   : OPERATION_GRAB_BRUSH
 // Click Souris: 0
 // Taille_Pile : 5
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 //
 {
   short start_x;
@@ -358,7 +358,7 @@
   short old_paintbrush_y;
   short clear;
 
-  // Comme on a demandé l'effacement du curseur, il n'y a plus de croix en
+  // Comme on a demandÃ© l'effacement du curseur, il n'y a plus de croix en
   // (Paintbrush_X,Paintbrush_Y). C'est une bonne chose.
 
   Operation_stack_size-=2;
@@ -371,7 +371,7 @@
   old_paintbrush_y=Paintbrush_Y;
   Paintbrush_X=start_x;
   Paintbrush_Y=start_y;
-  Hide_cursor(); // Maintenant, il n'y a plus de croix à l'écran.
+  Hide_cursor(); // Maintenant, il n'y a plus de croix Ã  l'Ã©cran.
 
   Paintbrush_X=old_paintbrush_x;
   Paintbrush_Y=old_paintbrush_y;
@@ -411,11 +411,11 @@
 
 
 void Polybrush_12_8(void)
-//  Opération   : OPERATION_POLYBRUSH
+//  OpÃ©ration   : OPERATION_POLYBRUSH
 //  Click Souris: 1 ou 2
 //  Taille_Pile : 8
 //
-//  Souris effacée: Non
+//  Souris effacÃ©e: Non
 {
   short click;
   short end_y;
@@ -439,13 +439,13 @@
     if (((start_x!=Paintbrush_X) || (start_y!=Paintbrush_Y)) &&
         (Polyfill_number_of_points<Config.Nb_max_vertices_per_polygon))
     {
-      // Il existe un nouveau segment défini par
+      // Il existe un nouveau segment dÃ©fini par
       // (start_x,start_y)-(Paintbrush_X,Paintbrush_Y)
 
       Hide_cursor();
       Print_coordinates();
 
-      // On le place à l'écran
+      // On le place Ã  l'Ã©cran
       Draw_line_preview_xor(start_x,start_y,end_x,end_y,0);
       Draw_line_preview_xor(start_x,start_y,Paintbrush_X,Paintbrush_Y,0);
 
@@ -474,13 +474,13 @@
           Hide_cursor();
           Print_coordinates();
 
-          // On le place à l'écran
+          // On le place Ã  l'Ã©cran
           Draw_line_preview_xor(start_x,start_y,end_x,end_y,0);
           Draw_line_preview_xor(start_x,start_y,Paintbrush_X,Paintbrush_Y,0);
           Display_cursor();
         }
 
-        // On remet les mêmes valeurs (comme si on n'avait pas cliqué):
+        // On remet les mÃªmes valeurs (comme si on n'avait pas cliquÃ©):
         Operation_push(start_x);
         Operation_push(start_y);
         Operation_push(Paintbrush_X);
@@ -499,7 +499,7 @@
   }
   else
   {
-    // L'utilisateur souhaite arrêter l'opération et refermer le polygone
+    // L'utilisateur souhaite arrÃªter l'opÃ©ration et refermer le polygone
 
     Operation_pop(&color);
     Operation_pop(&initial_y);
@@ -515,8 +515,8 @@
     free(Polyfill_table_of_points);
     Polyfill_table_of_points = NULL;
 
-    // On raffiche l'écran pour effacer les traits en xor et pour raffraichir
-    // l'écran si on a découpé une partie de l'image en prenant la brosse.
+    // On raffiche l'Ã©cran pour effacer les traits en xor et pour raffraichir
+    // l'Ã©cran si on a dÃ©coupÃ© une partie de l'image en prenant la brosse.
     Display_all_screen();
 
     Paintbrush_hidden=0;
@@ -540,27 +540,27 @@
 
 void Stretch_brush_12_0(void)
 //
-// Opération   : OPERATION_STRETCH_BRUSH
+// OpÃ©ration   : OPERATION_STRETCH_BRUSH
 // Click Souris: 1 ou 2
 // Taille_Pile : 0
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 //
 {
   Init_start_operation();
   if (Mouse_K==LEFT_SIDE)
   {
     // On laisse une trace du curseur pour que l'utilisateur puisse visualiser
-    // où demarre sa brosse:
+    // oÃ¹ demarre sa brosse:
     Display_cursor();
 
     Operation_push(Paintbrush_X); // Dernier calcul X
     Operation_push(Paintbrush_Y); // Dernier calcul Y
-    Operation_push(Paintbrush_X); // Début X
-    Operation_push(Paintbrush_Y); // Début Y
-    Operation_push(Paintbrush_X); // Dernière position X
-    Operation_push(Paintbrush_Y); // Dernière position Y
-    Operation_push(1); // State précédent
+    Operation_push(Paintbrush_X); // DÃ©but X
+    Operation_push(Paintbrush_Y); // DÃ©but Y
+    Operation_push(Paintbrush_X); // DerniÃ¨re position X
+    Operation_push(Paintbrush_Y); // DerniÃ¨re position Y
+    Operation_push(1); // State prÃ©cÃ©dent
 
     if ((Config.Coords_rel) && (Menu_is_visible))
       Print_in_menu("\035:   1   \022:   1",0);
@@ -576,11 +576,11 @@
 
 void Stretch_brush_1_7(void)
 //
-// Opération   : OPERATION_STRETCH_BRUSH
+// OpÃ©ration   : OPERATION_STRETCH_BRUSH
 // Click Souris: 1
 // Taille_Pile : 7
 //
-// Souris effacée: Non
+// Souris effacÃ©e: Non
 //
 {
   char  str[5];
@@ -666,11 +666,11 @@
 
 void Stretch_brush_0_7(void)
 //
-// Opération   : OPERATION_STRETCH_BRUSH
+// OpÃ©ration   : OPERATION_STRETCH_BRUSH
 // Click Souris: 0
 // Taille_Pile : 7
 //
-// Souris effacée: Non
+// Souris effacÃ©e: Non
 //
 {
   char  str[5];
@@ -709,7 +709,7 @@
   }
 
   // Utilise Key_ANSI au lieu de Key, car Get_input() met ce dernier
-  // à zero si une operation est en cours (Operation_stack_size!=0)
+  // Ã  zero si une operation est en cours (Operation_stack_size!=0)
   if (Key_ANSI)
   {
     size_change=1;
@@ -727,15 +727,15 @@
         width=start_x+Brush_width-1;
         height=start_y+(Brush_height<<1)-1;
         break;
-      case 'h': // Moitié
+      case 'h': // MoitiÃ©
         width=(Brush_width>1)?start_x+(Brush_width>>1)-1:1;
         height=(Brush_height>1)?start_y+(Brush_height>>1)-1:1;
         break;
-      case 'X': // Moitié X
+      case 'X': // MoitiÃ© X
         width=(Brush_width>1)?start_x+(Brush_width>>1)-1:1;
         height=start_y+Brush_height-1;
         break;
-      case 'Y': // Moitié Y
+      case 'Y': // MoitiÃ© Y
         width=start_x+Brush_width-1;
         height=(Brush_height>1)?start_y+(Brush_height>>1)-1:1;
         break;
@@ -782,11 +782,11 @@
 
 void Stretch_brush_2_7(void)
 //
-// Opération   : OPERATION_STRETCH_BRUSH
+// OpÃ©ration   : OPERATION_STRETCH_BRUSH
 // Click Souris: 2
 // Taille_Pile : 7
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 //
 {
   short computed_x;
@@ -804,7 +804,7 @@
   // On efface la preview de la brosse (et la croix)
   Display_all_screen();
 
-  // Et enfin on stocke pour de bon la nouvelle brosse étirée
+  // Et enfin on stocke pour de bon la nouvelle brosse Ã©tirÃ©e
   Stretch_brush(start_x,start_y,computed_x,computed_y);
 
   Return_to_draw_mode();
@@ -816,11 +816,11 @@
 
 void Rotate_brush_12_0(void)
 //
-// Opération   : OPERATION_ROTATE_BRUSH
+// OpÃ©ration   : OPERATION_ROTATE_BRUSH
 // Click Souris: 1 ou 2
 // Taille_Pile : 0
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 //
 {
   Init_start_operation();
@@ -829,19 +829,19 @@
     Brush_rotation_center_X=Paintbrush_X+(Brush_width>>1)-Brush_width;
     Brush_rotation_center_Y=Paintbrush_Y;
     Brush_rotation_center_is_defined=1;
-    Operation_push(Paintbrush_X); // Dernière position calculée X
-    Operation_push(Paintbrush_Y); // Dernière position calculée Y
-    Operation_push(Paintbrush_X); // Dernière position X
-    Operation_push(Paintbrush_Y); // Dernière position Y
-    Operation_push(1); // State précédent
+    Operation_push(Paintbrush_X); // DerniÃ¨re position calculÃ©e X
+    Operation_push(Paintbrush_Y); // DerniÃ¨re position calculÃ©e Y
+    Operation_push(Paintbrush_X); // DerniÃ¨re position X
+    Operation_push(Paintbrush_Y); // DerniÃ¨re position Y
+    Operation_push(1); // State prÃ©cÃ©dent
 
     if ((Config.Coords_rel) && (Menu_is_visible))
-      Print_in_menu("Angle:   0°    ",0);
+      Print_in_menu("Angle:   0\xB0    ",0);
   }
   else
   {
     Start_operation_stack(Operation_before_interrupt);
-    Wait_end_of_click(); // FIXME: celui-la il donne un résultat pas très chouette en visuel
+    Wait_end_of_click(); // FIXME: celui-la il donne un rÃ©sultat pas trÃ¨s chouette en visuel
   }
 }
 
@@ -849,11 +849,11 @@
 
 void Rotate_brush_1_5(void)
 //
-// Opération   : OPERATION_ROTATE_BRUSH
+// OpÃ©ration   : OPERATION_ROTATE_BRUSH
 // Click Souris: 1
 // Taille_Pile : 5
 //
-// Souris effacée: Non
+// Souris effacÃ©e: Non
 //
 {
   char  str[4];
@@ -909,11 +909,11 @@
 
 void Rotate_brush_0_5(void)
 //
-// Opération   : OPERATION_ROTATE_BRUSH
+// OpÃ©ration   : OPERATION_ROTATE_BRUSH
 // Click Souris: 0
 // Taille_Pile : 5
 //
-// Souris effacée: Non
+// Souris effacÃ©e: Non
 //
 {
   char  str[4];
@@ -956,7 +956,7 @@
   }
 
   // Utilise Key_ANSI au lieu de Key, car Get_input() met ce dernier
-  // à zero si une operation est en cours (Operation_stack_size!=0)
+  // Ã  zero si une operation est en cours (Operation_stack_size!=0)
   if (Key_ANSI)
   {
     angle_change=1;
@@ -1000,11 +1000,11 @@
 
 void Rotate_brush_2_5(void)
 //
-// Opération   : OPERATION_ROTATE_BRUSH
+// OpÃ©ration   : OPERATION_ROTATE_BRUSH
 // Click Souris: 2
 // Taille_Pile : 5
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 //
 {
   short computed_x;
@@ -1020,7 +1020,7 @@
   Operation_pop(&computed_y);
   Operation_pop(&computed_x);
 
-  // Calcul de l'angle par rapport à la dernière position calculée
+  // Calcul de l'angle par rapport Ã  la derniÃ¨re position calculÃ©e
   if ( (Brush_rotation_center_X==computed_x)
     && (Brush_rotation_center_Y==computed_y) )
     angle=0.0;
@@ -1032,7 +1032,7 @@
     if (dy>0) angle=M_2PI-angle;
   }
 
-  // Et enfin on stocke pour de bon la nouvelle brosse étirée
+  // Et enfin on stocke pour de bon la nouvelle brosse Ã©tirÃ©e
   Rotate_brush(angle);
 
   Return_to_draw_mode();
@@ -1055,11 +1055,11 @@
 
 void Distort_brush_0_0(void)
 //
-// Opération   : OPERATION_DISTORT_BRUSH
+// OpÃ©ration   : OPERATION_DISTORT_BRUSH
 // Click Souris: 0
 // Taille_Pile : 0
 //
-// Souris effacée: Non
+// Souris effacÃ©e: Non
 //
 {
   if ( Menu_is_visible )
@@ -1070,11 +1070,11 @@
 
 void Distort_brush_1_0(void)
 //
-// Opération   : OPERATION_DISTORT_BRUSH
+// OpÃ©ration   : OPERATION_DISTORT_BRUSH
 // Click Souris: 1
 // Taille_Pile : 0
 //
-// Souris effacée: Non
+// Souris effacÃ©e: Non
 //
 {
   short x_pos, y_pos;
@@ -1129,11 +1129,11 @@
 
 void Distort_brush_1_8(void)
 //
-//  Opération   : OPERATION_DISTORT_BRUSH
+//  OpÃ©ration   : OPERATION_DISTORT_BRUSH
 //  Click Souris: 1
 //  Taille_Pile : 8
 //
-//  Souris effacée: No
+//  Souris effacÃ©e: No
 //
 {
   // How far (in pixels) you can catch a handle
@@ -1176,11 +1176,11 @@
 
 void Distort_brush_1_9(void)
 //
-//  Opération   : OPERATION_DISTORT_BRUSH
+//  OpÃ©ration   : OPERATION_DISTORT_BRUSH
 //  Click Souris: 1
 //  Taille_Pile : 9
 //
-//  Souris effacée: No
+//  Souris effacÃ©e: No
 //
 {
   short i;
@@ -1233,11 +1233,11 @@
 }
 void Distort_brush_0_9(void)
 //
-//  Opération   : OPERATION_DISTORT_BRUSH
+//  OpÃ©ration   : OPERATION_DISTORT_BRUSH
 //  Click Souris: 0
 //  Taille_Pile : 9
 //
-//  Souris effacée: No
+//  Souris effacÃ©e: No
 //
 {
   short selected_corner;
@@ -1247,11 +1247,11 @@
 
 void Distort_brush_2_0(void)
 //
-// Opération   : OPERATION_DISTORT_BRUSH
+// OpÃ©ration   : OPERATION_DISTORT_BRUSH
 // Click Souris: 2
 // Taille_Pile : 0
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 //
 {
   Paintbrush_hidden=0;
@@ -1266,11 +1266,11 @@
 
 void Distort_brush_2_8(void)
 //
-// Opération   : OPERATION_DISTORT_BRUSH
+// OpÃ©ration   : OPERATION_DISTORT_BRUSH
 // Click Souris: 2
 // Taille_Pile : 8
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 //
 {
   short i;
diff -ruN gfx2orig/src/buttons.c grafx2/src/buttons.c
--- gfx2orig/src/buttons.c	2010-03-21 17:12:06.000000000 -0500
+++ grafx2/src/buttons.c	2022-03-20 20:19:34.112495316 -0500
@@ -185,7 +185,7 @@
       Paintbrush_shape=PAINTBRUSH_SHAPE_POINT;
       break;
     // Note: Il existe un Paintbrush_shape_before_lasso, mais comme le lasso aura
-    // été automatiquement désactivé avant d'arriver ici, y'a pas de problème.
+    // Ã©tÃ© automatiquement dÃ©sactivÃ© avant d'arriver ici, y'a pas de problÃ¨me.
   }
 }
 
@@ -356,8 +356,8 @@
       }
     }
 
-    //   On repositionne le décalage de l'image pour qu'il n'y ait pas d'in-
-    // -cohérences lorsqu'on sortira du mode Loupe.
+    //   On repositionne le dÃ©calage de l'image pour qu'il n'y ait pas d'in-
+    // -cohÃ©rences lorsqu'on sortira du mode Loupe.
     if (Main_offset_Y+Screen_height>Main_image_height)
     {
       if (Screen_height>Main_image_height)
@@ -425,8 +425,8 @@
       }
     }
 
-    //   On repositionne le décalage de l'image pour qu'il n'y ait pas d'in-
-    // -cohérences lorsqu'on sortira du mode Loupe.
+    //   On repositionne le dÃ©calage de l'image pour qu'il n'y ait pas d'in-
+    // -cohÃ©rences lorsqu'on sortira du mode Loupe.
     if (Main_offset_Y+Screen_height>Main_image_height)
     {
       if (Screen_height>Main_image_height)
@@ -557,7 +557,7 @@
   if (!Main_image_is_modified)
     return 1;
 
-  // On commence par afficher la fenêtre de QUIT
+  // On commence par afficher la fenÃªtre de QUIT
   Open_window(160,84,"Quit ?");
   Window_set_normal_button(20,20,120,14,"Stay",0,1,KEY_ESC);          // 1
   Window_set_normal_button(20,40,120,14,"Save & quit",1,1,SDLK_s);   // 2
@@ -601,14 +601,14 @@
         Display_cursor();
        
         if (!File_error)
-          // L'ayant sauvée avec succès,
+          // L'ayant sauvÃ©e avec succÃ¨s,
           return 1; // On peut quitter
         else
           // Il y a eu une erreur lors de la sauvegarde,
           return 0; // On ne peut donc pas quitter
       }
       else
-        // L'utilisateur ne veut pas écraser l'ancien fichier,
+        // L'utilisateur ne veut pas Ã©craser l'ancien fichier,
         return 0; // On doit donc rester
     case 3 : return 1; // Quitter
   }
@@ -625,7 +625,7 @@
     if (Spare_image_is_modified)
     {
       Button_Page(); // On passe sur le brouillon
-      // Si l'utilisateur présente les derniers symptomes de l'abandon
+      // Si l'utilisateur prÃ©sente les derniers symptomes de l'abandon
       if (Button_Quit_local_function())
         Quitting=1;
     }
@@ -643,7 +643,7 @@
 }
 
 
-//---------------------------- Effacer l'écran -------------------------------
+//---------------------------- Effacer l'Ã©cran -------------------------------
 void Button_Clear(void)
 {
   Hide_cursor();
@@ -675,7 +675,7 @@
 }
  
 
-//------------------------------- Paramètres ---------------------------------
+//------------------------------- ParamÃ¨tres ---------------------------------
 
 void Settings_display_config(T_Config * conf)
 #define YES "YES"
@@ -765,16 +765,16 @@
 
   Window_set_normal_button(9, 81, 107, 14, "Clear pal:   ", 0, 1, SDLK_LAST); // 3
   Window_set_normal_button(9, 96, 107, 14, "Max prev.:   ", 0, 1, SDLK_LAST); // 4
-  // Button Effectuer des backups à chaque sauvegarde
+  // Button Effectuer des backups Ã  chaque sauvegarde
   Window_set_normal_button(  9,111,107,14,"Backup   :   ",0,1,SDLK_LAST); // 5
 
   // Button Safety colors
   Window_set_normal_button(117, 81,131,14,"Safe. colors:   ",0,1,SDLK_LAST); // 6
   // Button Adjust Brush Pick
   Window_set_normal_button(117, 96,131,14,"AdjBrushPick:   ",0,1,SDLK_LAST); // 7
-  // Button Passer dans la résolution appropriée après un chargement
+  // Button Passer dans la rÃ©solution appropriÃ©e aprÃ¨s un chargement
   Window_set_normal_button(117,111,131,14,"Auto-set res:   ",0,1,SDLK_LAST); // 8
-  // Button Adapter la palette après un chargement (<=> Shift+BkSpc)
+  // Button Adapter la palette aprÃ¨s un chargement (<=> Shift+BkSpc)
   Window_set_normal_button(117,126,131,14,"Coords:         ",0,1,SDLK_LAST); // 9
 
     // Button Reload
@@ -786,7 +786,7 @@
     // Button Close
   Window_set_normal_button(250,163, 51,14,"Close"        ,0,1,KEY_ESC); // 13
 
-  // Jauges de sensibilité de la souris (X puis Y)
+  // Jauges de sensibilitÃ© de la souris (X puis Y)
   Window_set_scroller_button(265,99,56,4,1,0); // 14
   Window_set_scroller_button(279,99,56,4,1,0); // 15
 
@@ -830,7 +830,7 @@
       case 8 : // Auto-set resolution
         Config_choisie.Auto_set_res=!Config_choisie.Auto_set_res;
         break;
-      case 9 : // Coordonnées
+      case 9 : // CoordonnÃ©es
         Config_choisie.Coords_rel=!Config_choisie.Coords_rel;
         break;
       case 10 : // Reload
@@ -898,11 +898,11 @@
   Close_window();
   Unselect_button(BUTTON_SETTINGS);
   // Raffichage du menu pour que les inscriptions qui y figurent soient
-  // retracées avec la nouvelle fonte
+  // retracÃ©es avec la nouvelle fonte
   Display_menu();
   Display_cursor();
 
-  // On vérifie qu'on peut bien allouer le nombre de pages Undo.
+  // On vÃ©rifie qu'on peut bien allouer le nombre de pages Undo.
   Set_number_of_backups(Config.Max_undo_pages);
 }
 
@@ -1217,7 +1217,7 @@
   Close_window();
   Unselect_button(BUTTON_SETTINGS);
   
-  // Raffichage du menu pour que les inscriptions qui y figurent soient retracées avec la nouvelle fonte
+  // Raffichage du menu pour que les inscriptions qui y figurent soient retracÃ©es avec la nouvelle fonte
   Display_menu();
   Display_cursor();
 }
@@ -1231,10 +1231,10 @@
   
   Hide_cursor();
 
-  // On dégrossit le travail avec les infos des listes de pages
+  // On dÃ©grossit le travail avec les infos des listes de pages
   Exchange_main_and_spare();
 
-  // On fait le reste du travail "à la main":
+  // On fait le reste du travail "Ã  la main":
   SWAP_PBYTES(Main_visible_image.Image,Spare_visible_image.Image)
   SWAP_WORDS (Main_visible_image.Width,Spare_visible_image.Width)
   SWAP_WORDS (Main_visible_image.Height,Spare_visible_image.Height)
@@ -1254,7 +1254,7 @@
   SWAP_WORDS (Main_magnifier_width,Spare_magnifier_width)
   SWAP_SHORTS(Main_magnifier_offset_X,Spare_magnifier_offset_X)
   SWAP_SHORTS(Main_magnifier_offset_Y,Spare_magnifier_offset_Y)
-  // Swap du booléen "Image modifiée"
+  // Swap du boolÃ©en "Image modifiÃ©e"
   SWAP_BYTES (Main_image_is_modified,Spare_image_is_modified)
 
   // Swap des infos sur les fileselects
@@ -1287,7 +1287,7 @@
   End_of_modification();
   // --
 
-  // A la fin, on affiche l'écran
+  // A la fin, on affiche l'Ã©cran
   for (factor_index=0; ZOOM_FACTOR[factor_index]!=Main_magnifier_factor; factor_index++);
   //Change_magnifier_factor(factor_index,0);
   Compute_magnifier_data();
@@ -1339,7 +1339,7 @@
 
     // Copie des dimensions de l'image
     /*
-      C'est inutile, le "Backuper et redimensionner brouillon" a déjà modifié
+      C'est inutile, le "Backuper et redimensionner brouillon" a dÃ©jÃ  modifiÃ©
       ces valeurs pour qu'elles soient correctes.
     */
     /*
@@ -1347,25 +1347,25 @@
     Spare_image_height=Main_image_height;
     */
 
-    // Copie des décalages de la fenêtre principale (non zoomée) de l'image
+    // Copie des dÃ©calages de la fenÃªtre principale (non zoomÃ©e) de l'image
     Spare_offset_X=Main_offset_X;
     Spare_offset_Y=Main_offset_Y;
 
-    // Copie du booléen "Mode loupe" de l'image
+    // Copie du boolÃ©en "Mode loupe" de l'image
     Spare_magnifier_mode=Main_magnifier_mode;
 
     // Copie du facteur de zoom du brouillon
     Spare_magnifier_factor=Main_magnifier_factor;
 
-    // Copie des dimensions de la fenêtre de zoom
+    // Copie des dimensions de la fenÃªtre de zoom
     Spare_magnifier_width=Main_magnifier_width;
     Spare_magnifier_height=Main_magnifier_height;
 
-    // Copie des décalages de la fenêtre de zoom
+    // Copie des dÃ©calages de la fenÃªtre de zoom
     Spare_magnifier_offset_X=Main_magnifier_offset_X;
     Spare_magnifier_offset_Y=Main_magnifier_offset_Y;
 
-    // Copie des données du split du zoom
+    // Copie des donnÃ©es du split du zoom
     Spare_separator_position=Main_separator_position;
     Spare_X_zoom=Main_X_zoom;
     Spare_separator_proportion=Main_separator_proportion;
@@ -1763,7 +1763,7 @@
           // Si l'utilisateur s'est servi du bouton droit de la souris:
           if (Mouse_K==2)
           {
-            // On affecte également les dimensions de l'image:
+            // On affecte Ã©galement les dimensions de l'image:
             chosen_width=Video_mode[selected_mode].Width/Pixel_width;
             Num2str(chosen_width,str,4);
             Window_input_content(input_width_button,str);
@@ -1787,10 +1787,10 @@
         chosen_pixel=Window_attribute2;
         break;
         
-      default: // Boutons de tag des états des modes
+      default: // Boutons de tag des Ã©tats des modes
         temp=list_start+clicked_button-8;
-        if (Video_mode[temp].Fullscreen==1 && // On n'a pas le droit de cocher le mode fenêtré
-            !(Video_mode[temp].State & 128)) // Ni ceux non détectés par SDL
+        if (Video_mode[temp].Fullscreen==1 && // On n'a pas le droit de cocher le mode fenÃªtrÃ©
+            !(Video_mode[temp].State & 128)) // Ni ceux non dÃ©tectÃ©s par SDL
         {
           if (Window_attribute1==LEFT_SIDE)
             Video_mode[temp].State=((Video_mode[temp].State&0x7F)+1)&3;
@@ -1804,7 +1804,7 @@
         }
     }
 
-    // Gestion des touches de déplacement dans la liste
+    // Gestion des touches de dÃ©placement dans la liste
     switch (Key)
     {
       case SDLK_UP : // Haut
@@ -1903,7 +1903,7 @@
         Video_mode[selected_mode].Fullscreen,
         chosen_pixel))
     {
-      Error(0); // On signale à l'utilisateur que c'est un mode invalide
+      Error(0); // On signale Ã  l'utilisateur que c'est un mode invalide
       Pixel_ratio=PIXEL_SIMPLE;
       Init_mode_video(
         Video_mode[Current_resolution].Width,
@@ -1951,12 +1951,12 @@
   Display_all_screen();
 
   Unselect_button(BUTTON_RESOL);
-  // Le pinceau est affiché à la position du clic et pas 
+  // Le pinceau est affichÃ© Ã  la position du clic et pas 
   Display_cursor();
 }
 
 
-//------------------ Gestion des boutons de dessin à la main -----------------
+//------------------ Gestion des boutons de dessin Ã  la main -----------------
 
 void Button_Draw(void)
 {
@@ -2061,18 +2061,18 @@
 }
 
 
-// -- Gestion du menu des dégradés ------------------------------------------
+// -- Gestion du menu des dÃ©gradÃ©s ------------------------------------------
 void Draw_button_gradient_style(short x_pos,short y_pos,int technique)
 {
   short line;
 
-  // On commence par afficher les 2 côtés qui constituent le dégradé de base:
-    // Côté gauche (noir)
+  // On commence par afficher les 2 cÃ´tÃ©s qui constituent le dÃ©gradÃ© de base:
+    // CÃ´tÃ© gauche (noir)
   Block(Window_pos_X+((x_pos+2)*Menu_factor_X),
         Window_pos_Y+((y_pos+2)*Menu_factor_Y),
         Menu_factor_X*6,
         Menu_factor_Y*10,MC_Black);
-    // Côté droit (blanc)
+    // CÃ´tÃ© droit (blanc)
   Block(Window_pos_X+((x_pos+8)*Menu_factor_X),
         Window_pos_Y+((y_pos+2)*Menu_factor_Y),
         Menu_factor_X*5,
@@ -2080,8 +2080,8 @@
 
   switch(technique)
   {
-    case 1 : // Dégradé de trames simples
-      // Au centre, on place 10 lignes tramées simplement
+    case 1 : // DÃ©gradÃ© de trames simples
+      // Au centre, on place 10 lignes tramÃ©es simplement
       for (line=2;line<2+10;line++)
         if (line&1)
         {
@@ -2097,8 +2097,8 @@
           Pixel_in_window(x_pos+ 9,y_pos+line,MC_Black);
         }
       break;
-    case 2 : // Dégradé de trames étendues
-      // Au centre, on place 10 lignes tramées de façon compliquée
+    case 2 : // DÃ©gradÃ© de trames Ã©tendues
+      // Au centre, on place 10 lignes tramÃ©es de faÃ§on compliquÃ©e
       for (line=2;line<2+10;line++)
         if (line&1)
         {
@@ -2133,20 +2133,20 @@
 
   switch(Gradient_array[index].Technique)
   {
-    case 0 : // Degradé de base
+    case 0 : // DegradÃ© de base
       Gradient_function=Gradient_basic;
       break;
-    case 1 : // Dégradé de trames simples
+    case 1 : // DÃ©gradÃ© de trames simples
       Gradient_function=Gradient_dithered;
       break;
-    case 2 : // Dégradé de trames étendues
+    case 2 : // DÃ©gradÃ© de trames Ã©tendues
       Gradient_function=Gradient_extra_dithered;
   }
 }
 
 void Draw_gradient_preview(short start_x,short start_y,short width,short height,int index)
 {
-  short x_pos; // Variables de balayage du block en bas de l'écran.
+  short x_pos; // Variables de balayage du block en bas de l'Ã©cran.
   short y_pos;
   short end_x;
   short end_y;
@@ -2191,15 +2191,15 @@
   Open_window(237,133,"Gradation menu");
 
   Window_set_palette_button(48,21);                            // 1
-    // Définition du scrolleur <=> indice du dégradé dans le tableau
+    // DÃ©finition du scrolleur <=> indice du dÃ©gradÃ© dans le tableau
   Window_set_scroller_button(218,22,75,16,1,Current_gradient);  // 2
-    // Définition du scrolleur de mélange du dégradé
+    // DÃ©finition du scrolleur de mÃ©lange du dÃ©gradÃ©
   mix_scroller = Window_set_scroller_button(31,22,84,256,1,
     Gradient_array[Current_gradient].Mix);                      // 3
-    // Définition du bouton de sens
+    // DÃ©finition du bouton de sens
   Window_set_normal_button(8,22,15,14,
     (Gradient_array[Current_gradient].Inverse)?"\033":"\032",0,1,SDLK_TAB); // 4
-    // Définition du bouton de technique
+    // DÃ©finition du bouton de technique
   Window_set_normal_button(8,92,15,14,"",0,1,SDLK_TAB|MOD_SHIFT); // 5
   Draw_button_gradient_style(8,92,Gradient_array[Current_gradient].Technique);
 
@@ -2214,7 +2214,7 @@
   Num2str(Current_gradient+1,str,2);
   Print_in_window(215,100,str,MC_Black,MC_Light);
 
-    // On affiche le cadre autour de la préview
+    // On affiche le cadre autour de la prÃ©view
   Window_display_frame_in(7,111,110,16);
     // On affiche la preview
   Draw_gradient_preview(8,112,108,14,Current_gradient);
@@ -2245,11 +2245,11 @@
           {
             // On vient de clicker
 
-            // On met à jour l'intervalle du dégradé
+            // On met Ã  jour l'intervalle du dÃ©gradÃ©
             first_color=last_color=Gradient_array[Current_gradient].Start=Gradient_array[Current_gradient].End=temp_color;
             // On tagge le bloc
             Tag_color_range(Gradient_array[Current_gradient].Start,Gradient_array[Current_gradient].End);
-            // Tracé de la preview:
+            // TracÃ© de la preview:
             Draw_gradient_preview(8,112,108,14,Current_gradient);
           }
           else
@@ -2257,7 +2257,7 @@
             // On maintient le click, on va donc tester si le curseur bouge
             if (temp_color!=last_color)
             {
-              // On commence par ordonner la 1ère et dernière couleur du bloc
+              // On commence par ordonner la 1Ã¨re et derniÃ¨re couleur du bloc
               if (first_color<temp_color)
               {
                 Gradient_array[Current_gradient].Start=first_color;
@@ -2272,7 +2272,7 @@
                 Gradient_array[Current_gradient].Start=Gradient_array[Current_gradient].End=first_color;
               // On tagge le bloc
               Tag_color_range(Gradient_array[Current_gradient].Start,Gradient_array[Current_gradient].End);
-              // Tracé de la preview:
+              // TracÃ© de la preview:
               Draw_gradient_preview(8,112,108,14,Current_gradient);
               last_color=temp_color;
             }
@@ -2280,7 +2280,7 @@
           Display_cursor();
         }
         break;
-      case  2 : // Nouvel indice de dégradé
+      case  2 : // Nouvel indice de dÃ©gradÃ©
         Hide_cursor();
         // Nouvel indice dans Window_attribute2
         Current_gradient=Window_attribute2;
@@ -2295,7 +2295,7 @@
         // On affiche le sens qui va avec
         Print_in_window(12,25,(Gradient_array[Current_gradient].Inverse)?"\033":"\032",MC_Black,MC_Light);
 
-        // On raffiche le mélange (jauge) qui va avec
+        // On raffiche le mÃ©lange (jauge) qui va avec
         mix_scroller->Position=Gradient_array[Current_gradient].Mix;
         Window_draw_slider(mix_scroller);
 
@@ -2307,9 +2307,9 @@
 
         Display_cursor();
         break;
-      case  3 : // Nouveau mélange de dégradé
+      case  3 : // Nouveau mÃ©lange de dÃ©gradÃ©
         Hide_cursor();
-        // Nouvel mélange dans Window_attribute2
+        // Nouvel mÃ©lange dans Window_attribute2
         Gradient_array[Current_gradient].Mix=Window_attribute2;
         // On affiche la nouvelle preview
         Draw_gradient_preview(8,112,108,14,Current_gradient);
@@ -2337,7 +2337,7 @@
     if (!Mouse_K)
     switch (Key)
     {
-      case SDLK_BACKQUOTE : // Récupération d'une couleur derrière le menu
+      case SDLK_BACKQUOTE : // RÃ©cupÃ©ration d'une couleur derriÃ¨re le menu
       case SDLK_COMMA :
         Get_color_behind_window(&color,&click);
         if (click)
@@ -2345,11 +2345,11 @@
           Hide_cursor();
           temp_color=color;
 
-          // On met à jour l'intervalle du dégradé
+          // On met Ã  jour l'intervalle du dÃ©gradÃ©
           first_color=last_color=Gradient_array[Current_gradient].Start=Gradient_array[Current_gradient].End=temp_color;
           // On tagge le bloc
           Tag_color_range(Gradient_array[Current_gradient].Start,Gradient_array[Current_gradient].End);
-          // Tracé de la preview:
+          // TracÃ© de la preview:
           Draw_gradient_preview(8,112,108,14,Current_gradient);
           Display_cursor();
           Wait_end_of_click();
@@ -2386,7 +2386,7 @@
 }
 
 
-// -- Gestion des boutons de cercle / ellipse / rectangle dégradés --------------------
+// -- Gestion des boutons de cercle / ellipse / rectangle dÃ©gradÃ©s --------------------
 
 void Button_Grad_circle(void)
 {
@@ -2573,7 +2573,7 @@
   Display_cursor();
 }
 
-// -- Fonction renvoyant le mode vidéo le plus adapté à l'image chargée -----
+// -- Fonction renvoyant le mode vidÃ©o le plus adaptÃ© Ã  l'image chargÃ©e -----
 #define TOLERANCE_X 8
 #define TOLERANCE_Y 4
 int Best_video_mode(void)
@@ -2583,11 +2583,11 @@
   short temp_x,temp_y;
   int mode;
 
-  // Si mode fenêtre, on reste dans ce mode.
+  // Si mode fenÃªtre, on reste dans ce mode.
   if (Current_resolution == 0)
     return 0;
     
-  // On commence par borner les dimensions, ou du moins les rendre cohérentes
+  // On commence par borner les dimensions, ou du moins les rendre cohÃ©rentes
   if ((Original_screen_X<=0) || (Config.Set_resolution_according_to==2))
     Original_screen_X=Main_image_width;
   else
@@ -2677,6 +2677,11 @@
       use_brush_palette=Confirmation_box("Use the palette of the brush?");
   }
 
+#if defined(FDOS)
+  // Silence 'set but not used' compiler warning.
+  (void)use_brush_palette;
+#endif
+
   // confirm is modified inside the first if, that's why we check it
   // again here
   if (confirm)
@@ -2723,7 +2728,7 @@
       Select_button(BUTTON_DRAW,LEFT_SIDE);
       if (Config.Auto_discontinuous)
       {
-        // On se place en mode Dessin discontinu à la main
+        // On se place en mode Dessin discontinu Ã  la main
         while (Current_operation!=OPERATION_DISCONTINUOUS_DRAW)
           Select_button(BUTTON_DRAW,RIGHT_SIDE);
       }
@@ -2813,7 +2818,7 @@
 
 void Button_Load(void)
 {
-  // On sauve l'état actuel des paramètres de l'image pour pouvoir les
+  // On sauve l'Ã©tat actuel des paramÃ¨tres de l'image pour pouvoir les
   // restituer en cas d'erreur n'affectant pas l'image
   Upload_infos_page_main(Main_backups->Pages);
 
@@ -2826,7 +2831,7 @@
   byte old_cursor_shape;
   int  new_mode;
 
-  // On sauve l'état actuel des paramètres de l'image pour pouvoir les
+  // On sauve l'Ã©tat actuel des paramÃ¨tres de l'image pour pouvoir les
   // restituer en cas d'erreur n'affectant pas l'image
   Upload_infos_page_main(Main_backups->Pages);
 
@@ -2934,10 +2939,10 @@
   File_error=0;
 
   // On fait un backup si le nom du fichier n'est pas celui qu'on a choisi
-  // pour nommer les backups (c'est évident!).
+  // pour nommer les backups (c'est Ã©vident!).
   if (strcmp(new_filename,filename))
   {
-    // S'il y avait déjà un fichier Backup, on l'efface
+    // S'il y avait dÃ©jÃ  un fichier Backup, on l'efface
     if ((File_exists(new_filename))
      && (remove(new_filename)!=0))
       File_error=1;
@@ -3123,7 +3128,7 @@
 
 void Button_Unselect_brush(void)
 {
-  // On fait de notre mieux pour restaurer l'ancienne opération:
+  // On fait de notre mieux pour restaurer l'ancienne opÃ©ration:
   Start_operation_stack(Operation_before_interrupt);
 }
 
@@ -3162,7 +3167,7 @@
 
 void Button_Unselect_lasso(void)
 {
-  // On fait de notre mieux pour restaurer l'ancienne opération:
+  // On fait de notre mieux pour restaurer l'ancienne opÃ©ration:
   Start_operation_stack(Operation_before_interrupt);
   Paintbrush_shape=Paintbrush_shape_before_lasso;
 }
@@ -3199,7 +3204,7 @@
          ( (!Main_magnifier_mode) || (Mouse_X<Main_separator_position) || (Mouse_X>=Main_X_zoom) ) )
       Print_in_menu("X:       Y:             ",0);
 
-  // On fait de notre mieux pour restaurer l'ancienne opération:
+  // On fait de notre mieux pour restaurer l'ancienne opÃ©ration:
   if (Current_operation==OPERATION_COLORPICK)
   {
     Start_operation_stack(Operation_before_interrupt);
@@ -3249,27 +3254,27 @@
       Start_operation_stack(OPERATION_MAGNIFY);
     }
     else
-    { /* Ceci est de la duplication de code de presque toute l'opération de */
-      /* la loupe... Il serait peut-être plus propre de faire une procédure */
+    { /* Ceci est de la duplication de code de presque toute l'opÃ©ration de */
+      /* la loupe... Il serait peut-Ãªtre plus propre de faire une procÃ©dure */
       /* qui s'en charge... */
       // On passe en mode loupe
       Main_magnifier_mode=1;
 
-      // La fonction d'affichage dans la partie image est désormais un affichage
-      // spécial loupe.
+      // La fonction d'affichage dans la partie image est dÃ©sormais un affichage
+      // spÃ©cial loupe.
       Pixel_preview=Pixel_preview_magnifier;
 
       // On calcule l'origine de la loupe
       Main_magnifier_offset_X=Mouse_X-(Main_magnifier_width>>1);
       Main_magnifier_offset_Y=Mouse_Y-(Main_magnifier_height>>1);
 
-      // Calcul du coin haut_gauche de la fenêtre devant être zoomée DANS L'ECRAN
+      // Calcul du coin haut_gauche de la fenÃªtre devant Ãªtre zoomÃ©e DANS L'ECRAN
       if (Main_magnifier_offset_X+Main_magnifier_width>=Limit_right-Main_offset_X)
         Main_magnifier_offset_X=Limit_right-Main_magnifier_width-Main_offset_X+1;
       if (Main_magnifier_offset_Y+Main_magnifier_height>=Limit_bottom-Main_offset_Y)
         Main_magnifier_offset_Y=Limit_bottom-Main_magnifier_height-Main_offset_Y+1;
 
-      // Calcul des coordonnées absolues de ce coin DANS L'IMAGE
+      // Calcul des coordonnÃ©es absolues de ce coin DANS L'IMAGE
       Main_magnifier_offset_X+=Main_offset_X;
       Main_magnifier_offset_Y+=Main_offset_Y;
 
@@ -3278,12 +3283,12 @@
       if (Main_magnifier_offset_Y<0)
         Main_magnifier_offset_Y=0;
 
-      // On calcule les bornes visibles dans l'écran
+      // On calcule les bornes visibles dans l'Ã©cran
       Position_screen_according_to_zoom();
       Compute_limits();
       Display_all_screen();
 
-      // Repositionner le curseur en fonction des coordonnées visibles
+      // Repositionner le curseur en fonction des coordonnÃ©es visibles
       Compute_paintbrush_coordinates();
     }
   }
@@ -3344,12 +3349,12 @@
     Main_magnifier_mode=0;
 
     /*
-    // --> Recalculer le décalage de l'écran lorsqu'on sort de la loupe <--
-    // Centrage "brut" de lécran par rapport à la loupe
+    // --> Recalculer le dÃ©calage de l'Ã©cran lorsqu'on sort de la loupe <--
+    // Centrage "brut" de lÃ©cran par rapport Ã  la loupe
     Main_offset_X=Main_magnifier_offset_X-((Screen_width-Main_magnifier_width)>>1);
     Main_offset_Y=Main_magnifier_offset_Y-((Menu_Y-Main_magnifier_height)>>1);
     */
-    // Correction en cas de débordement de l'image
+    // Correction en cas de dÃ©bordement de l'image
     if (Old_main_offset_X+Screen_width>Main_image_width)
       Main_offset_X=Main_image_width-Screen_width;
     else
@@ -3364,19 +3369,19 @@
     if (Main_offset_Y<0)
       Main_offset_Y=0;
 
-    // La fonction d'affichage dans l'image est désormais un affichage normal.
+    // La fonction d'affichage dans l'image est dÃ©sormais un affichage normal.
     Pixel_preview=Pixel_preview_normal;
 
-    // Calculer les bornes visibles dans l'écran
+    // Calculer les bornes visibles dans l'Ã©cran
     Compute_limits();
     Display_all_screen();  // <=> Display_screen();
-    // Repositionner le curseur en fonction des coordonnées visibles
+    // Repositionner le curseur en fonction des coordonnÃ©es visibles
     Compute_paintbrush_coordinates();
     
     Old_MX = -1;
     Old_MY = -1;
   }
-  else // On fait de notre mieux pour restaurer l'ancienne opération:
+  else // On fait de notre mieux pour restaurer l'ancienne opÃ©ration:
     Start_operation_stack(Operation_before_interrupt);
 }
 
@@ -3397,15 +3402,15 @@
   Window_set_normal_button(236,141, 67,14,"Cancel"          ,0,1,KEY_ESC); // 1
   Window_set_normal_button( 19, 46, 27,14,"X\035"           ,0,1,Config_Key[SPECIAL_FLIP_X][0]); // 2
   Window_set_normal_button( 19, 61, 27,14,"Y\022"           ,0,1,Config_Key[SPECIAL_FLIP_Y][0]); // 3
-  Window_set_normal_button( 58, 46, 37,14,"90°"             ,0,1,Config_Key[SPECIAL_ROTATE_90][0]); // 4
-  Window_set_normal_button( 96, 46, 37,14,"180°"            ,0,1,Config_Key[SPECIAL_ROTATE_180][0]); // 5
+  Window_set_normal_button( 58, 46, 37,14,"90\xB0"          ,0,1,Config_Key[SPECIAL_ROTATE_90][0]); // 4
+  Window_set_normal_button( 96, 46, 37,14,"180\xB0"         ,0,1,Config_Key[SPECIAL_ROTATE_180][0]); // 5
   Window_set_normal_button( 58, 61, 75,14,"any angle"       ,0,1,Config_Key[SPECIAL_ROTATE_ANY_ANGLE][0]); // 6
   Window_set_normal_button(145, 46, 67,14,"Stretch"         ,0,1,Config_Key[SPECIAL_STRETCH][0]); // 7
   Window_set_normal_button(145, 61, 67,14,"Distort"         ,0,1,Config_Key[SPECIAL_DISTORT][0]); // 8
   Window_set_normal_button(155, 99,131,14,"Recolorize"      ,0,1,Config_Key[SPECIAL_RECOLORIZE_BRUSH][0]); // 9
   Window_set_normal_button(155,117,131,14,"Get brush colors",0,1,Config_Key[SPECIAL_GET_BRUSH_COLORS][0]); // 10
 
-  // Boutons représentant les coins du brush handle: (HG,HD,C,BG,BD)
+  // Boutons reprÃ©sentant les coins du brush handle: (HG,HD,C,BG,BD)
   Window_set_normal_button( 75, 90,11,11,"",0,1,Config_Key[SPECIAL_TOP_LEFT_ATTACHMENT][0]); // 11
   Window_set_normal_button(103, 90,11,11,"",0,1,Config_Key[SPECIAL_TOP_RIGHT_ATTACHMENT][0]); // 12
   Window_set_normal_button( 89,104,11,11,"",0,1,Config_Key[SPECIAL_CENTER_ATTACHMENT][0]); // 13
@@ -3427,7 +3432,7 @@
   Print_in_window( 20,102,"Brush",MC_Dark,MC_Light);
   Print_in_window( 16,110,"handle",MC_Dark,MC_Light);
 
-  // Dessin des pointillés pour le "brush handle"
+  // Dessin des pointillÃ©s pour le "brush handle"
   for (index=0; index<13; index+=2)
   {
     Pixel_in_window( 88+index, 92,MC_Dark);
@@ -3474,7 +3479,7 @@
   Close_window();
   Unselect_button(BUTTON_BRUSH_EFFECTS);
 
-  // Gestion du bouton clické
+  // Gestion du bouton clickÃ©
   switch (clicked_button)
   {
     case  2 : // Flip X
@@ -3483,10 +3488,10 @@
     case  3 : // Flip Y
       Flip_Y_lowlevel(Brush, Brush_width, Brush_height);
       break;
-    case  4 : // 90° Rotation
+    case  4 : // 90Â° Rotation
       Rotate_90_deg();
       break;
-    case  5 : // 180° Rotation
+    case  5 : // 180Â° Rotation
       Rotate_180_deg_lowlevel(Brush, Brush_width, Brush_height);
       Brush_offset_X=(Brush_width>>1);
       Brush_offset_Y=(Brush_height>>1);
@@ -3550,7 +3555,7 @@
 }
 
 
-//---------------------------- Courbes de Bézier ----------------------------
+//---------------------------- Courbes de BÃ©zier ----------------------------
 
 void Button_Curves(void)
 {
@@ -3646,7 +3651,7 @@
   Window_set_normal_button(194, 62,19,14,"+1"        ,0,1,SDLK_KP_PLUS); // 6
   Window_set_normal_button(194, 79,19,14,"-1"        ,0,1,SDLK_KP_MINUS); // 7
   Window_set_normal_button(194, 96,19,14,"x2"        ,0,1,SDLK_KP_MULTIPLY); // 8
-  Window_set_normal_button(194,113,19,14,"÷2"        ,0,1,SDLK_KP_ENTER); // 9
+  Window_set_normal_button(194,113,19,14,"\xF7""2"        ,0,1,SDLK_KP_ENTER); // 9   0xf7 is divide
 
   Window_set_normal_button(  8, 37,43,14,"Clear"     ,1,1,SDLK_c); // 10
 
@@ -3673,11 +3678,11 @@
   Window_display_frame(173,56,45,86);
   Window_display_frame(137,19,81,33);
 
-  // On tagge toutes les couleurs utilisées
+  // On tagge toutes les couleurs utilisÃ©es
   for (index=0; index<256; index++)
     if (Airbrush_multi_flow[index])
       Stencil_tag_color(index,MC_Black);
-  // Et enfin, on tagge la couleur sélectionnée
+  // Et enfin, on tagge la couleur sÃ©lectionnÃ©e
   Stencil_tag_color(selected_color,MC_White);
   Refresh_airbrush_settings(selected_color,0);
 
@@ -3722,7 +3727,7 @@
           Hide_cursor();
           Stencil_tag_color(selected_color,(Airbrush_multi_flow[selected_color])?MC_Black:MC_Light);
           Stencil_update_color(selected_color);
-          // Mettre la couleur sélectionnée à jour suivant le click
+          // Mettre la couleur sÃ©lectionnÃ©e Ã  jour suivant le click
           selected_color=(clicked_button==4) ? Window_attribute2 : Read_pixel(Mouse_X,Mouse_Y);
           if (Mouse_K==2)
             Airbrush_multi_flow[selected_color]=0;
@@ -3730,7 +3735,7 @@
             if (Airbrush_multi_flow[selected_color]==0)
               Airbrush_multi_flow[selected_color]=spray_init;
 
-          // Tagger la couleur sélectionnée en blanc
+          // Tagger la couleur sÃ©lectionnÃ©e en blanc
           Stencil_tag_color(selected_color,MC_White);
           Refresh_airbrush_settings(selected_color,1);
           Display_cursor();
@@ -3786,7 +3791,7 @@
         Display_cursor();
         break;
 
-      case  9 : // ÷2
+      case  9 : // Ã·2
         for (index=0; index<256; index++)
         {
           if (Airbrush_multi_flow[index]>1)
@@ -3799,11 +3804,11 @@
 
       case 10 : // Clear
         memset(Airbrush_multi_flow,0,256);
-        // On raffiche les infos de la couleur sélectionnée
+        // On raffiche les infos de la couleur sÃ©lectionnÃ©e
         Refresh_airbrush_settings(selected_color,1);
         // On efface les anciens TAGs
         Window_clear_tags();
-        // Tagger la couleur sélectionnée en blanc
+        // Tagger la couleur sÃ©lectionnÃ©e en blanc
         Stencil_tag_color(selected_color,MC_White);
         Stencil_update_color(selected_color);
         break;
@@ -3874,7 +3879,7 @@
     if (!Mouse_K)
     switch (Key)
     {
-      case SDLK_BACKQUOTE : // Récupération d'une couleur derrière le menu
+      case SDLK_BACKQUOTE : // RÃ©cupÃ©ration d'une couleur derriÃ¨re le menu
       case SDLK_COMMA :
         Get_color_behind_window(&color,&click);
         if (click)
@@ -3882,7 +3887,7 @@
           Hide_cursor();
           Stencil_tag_color(selected_color,(Airbrush_multi_flow[selected_color])?MC_Black:MC_Light);
           Stencil_update_color(selected_color);
-          // Mettre la couleur sélectionnée à jour suivant le click
+          // Mettre la couleur sÃ©lectionnÃ©e Ã  jour suivant le click
           selected_color=color;
           if (click==2)
             Airbrush_multi_flow[selected_color]=0;
@@ -3890,7 +3895,7 @@
             if (Airbrush_multi_flow[selected_color]==0)
               Airbrush_multi_flow[selected_color]=spray_init;
 
-          // Tagger la couleur sélectionnée en blanc
+          // Tagger la couleur sÃ©lectionnÃ©e en blanc
           Stencil_tag_color(selected_color,MC_White);
           Refresh_airbrush_settings(selected_color,1);
           Display_cursor();
@@ -3918,9 +3923,9 @@
   Close_window();
 
 /*
-  //   Tant que l'on aura pas résolu le problème du désenclenchement du mode
-  // de dessin précedent, il faudra laisser ça en remarque et donc passer en
-  // spray même si on a clické sur Cancel (idem pour OK (un peu plus bas)).
+  //   Tant que l'on aura pas rÃ©solu le problÃ¨me du dÃ©senclenchement du mode
+  // de dessin prÃ©cedent, il faudra laisser Ã§a en remarque et donc passer en
+  // spray mÃªme si on a clickÃ© sur Cancel (idem pour OK (un peu plus bas)).
   if (clicked_button==1) // Cancel
   {
     if (Current_operation!=OPERATION_AIRBRUSH)
@@ -4553,7 +4558,7 @@
       Select_button(BUTTON_DRAW,LEFT_SIDE);
       if (Config.Auto_discontinuous)
       {
-        // On se place en mode Dessin discontinu à la main
+        // On se place en mode Dessin discontinu Ã  la main
         while (Current_operation!=OPERATION_DISCONTINUOUS_DRAW)
           Select_button(BUTTON_DRAW,RIGHT_SIDE);
       }
diff -ruN gfx2orig/src/buttons_effects.c grafx2/src/buttons_effects.c
--- gfx2orig/src/buttons_effects.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/buttons_effects.c	2022-03-20 20:19:34.108495316 -0500
@@ -64,13 +64,13 @@
   {
     Window_set_normal_button(91,129,78,14,"OK"    ,0,1,SDLK_RETURN); // 4
     Window_set_normal_button( 7,129,78,14,"Cancel",0,1,KEY_ESC);  // 5
-    // On enregistre la table dans un backup au cas où on ferait Cancel
+    // On enregistre la table dans un backup au cas oÃ¹ on ferait Cancel
     memcpy(backup_table,table,256);
   }
   else
     Window_set_normal_button(49,129,78,14,"OK"    ,0,1,SDLK_RETURN); // 4
 
-  // On affiche l'état actuel de la table
+  // On affiche l'Ã©tat actuel de la table
   for (index=0; index<=255; index++)
     Stencil_tag_color(index, (table[index])?MC_Black:MC_Light);
 
@@ -120,7 +120,7 @@
     if (!Mouse_K)
     switch (Key)
     {
-      case SDLK_BACKQUOTE : // Récupération d'une couleur derrière le menu
+      case SDLK_BACKQUOTE : // RÃ©cupÃ©ration d'une couleur derriÃ¨re le menu
       case SDLK_COMMA :
         Get_color_behind_window(&color,&click);
         if (click)
@@ -496,7 +496,7 @@
   if (clicked_button==2) // OK
   {
     memcpy(Smooth_matrix,chosen_matrix,sizeof(Smooth_matrix));
-    Smooth_mode=0; // On le met à 0 car la fonct° suivante va le passer à 1
+    Smooth_mode=0; // On le met Ã  0 car la fonctÂ° suivante va le passer Ã  1
     Button_Smooth_mode();
   }
 
@@ -565,9 +565,9 @@
 
 void Button_Colorize_display_selection(int mode)
 {
-  short y_pos=0; // Ligne où afficher les flèches de sélection
+  short y_pos=0; // Ligne oÃ¹ afficher les flÃ¨ches de sÃ©lection
 
-  // On commence par effacer les anciennes sélections:
+  // On commence par effacer les anciennes sÃ©lections:
     // Partie gauche
   Print_in_window(4,37," ",MC_Black,MC_Light);
   Print_in_window(4,57," ",MC_Black,MC_Light);
@@ -577,16 +577,16 @@
   Print_in_window(129,57," ",MC_Black,MC_Light);
   Print_in_window(129,74," ",MC_Black,MC_Light);
 
-  // Ensuite, on affiche la flèche là où il le faut:
+  // Ensuite, on affiche la flÃ¨che lÃ  oÃ¹ il le faut:
   switch(mode)
   {
-    case 0 : // Méthode interpolée
+    case 0 : // MÃ©thode interpolÃ©e
       y_pos=37;
       break;
-    case 1 : // Méthode additive
+    case 1 : // MÃ©thode additive
       y_pos=57;
       break;
-    case 2 : // Méthode soustractive
+    case 2 : // MÃ©thode soustractive
       y_pos=74;
   }
   Print_in_window(4,y_pos,"\020",MC_Black,MC_Light);
@@ -630,7 +630,7 @@
 
     switch(clicked_button)
     {
-      case 1: // Zone de saisie de l'opacité
+      case 1: // Zone de saisie de l'opacitÃ©
         Num2str(chosen_opacity,str,3);
         Readline(89,23,str,3,1);
         chosen_opacity=atoi(str);
@@ -643,9 +643,9 @@
         }
         Display_cursor();
         break;
-      case 2: // Méthode interpolée
-      case 3: // Méthode additive
-      case 4: // Méthode soustractive
+      case 2: // MÃ©thode interpolÃ©e
+      case 3: // MÃ©thode additive
+      case 4: // MÃ©thode soustractive
         selected_mode=clicked_button-2;
         Hide_cursor();
         Button_Colorize_display_selection(selected_mode);
@@ -665,7 +665,7 @@
     Colorize_opacity      =chosen_opacity;
     Colorize_current_mode=selected_mode;
     Compute_colorize_table();
-    Colorize_mode=0; // On le met à 0 car la fonct° suivante va le passer à 1
+    Colorize_mode=0; // On le met Ã  0 car la fonctÂ° suivante va le passer Ã  1
     Button_Colorize_mode();
   }
 
@@ -721,12 +721,12 @@
   {
     clicked_button=Window_clicked_button();
 
-    if (clicked_button==3)  // Zone de saisie du décalage X
+    if (clicked_button==3)  // Zone de saisie du dÃ©calage X
     {
       Num2str(chosen_offset_x,str,4);
       Readline(93,23,str,4,1);
       chosen_offset_x=atoi(str);
-      // On corrige le décalage en X
+      // On corrige le dÃ©calage en X
       if (chosen_offset_x>=Brush_width)
       {
         chosen_offset_x=Brush_width-1;
@@ -736,12 +736,12 @@
       Display_cursor();
     }
     else
-    if (clicked_button==4)  // Zone de saisie du décalage Y
+    if (clicked_button==4)  // Zone de saisie du dÃ©calage Y
     {
       Num2str(chosen_offset_y,str,4);
       Readline(93,37,str,4,1);
       chosen_offset_y=atoi(str);
-      // On corrige le décalage en Y
+      // On corrige le dÃ©calage en Y
       if (chosen_offset_y>=Brush_height)
       {
         chosen_offset_y=Brush_height-1;
@@ -803,9 +803,9 @@
   short start_y=Window_pos_Y+(Menu_factor_Y*78);
 
   x_size=Menu_factor_X*5; // |_ Taille d'une case
-  y_size=Menu_factor_Y*5; // |  de la trame zoomée
+  y_size=Menu_factor_Y*5; // |  de la trame zoomÃ©e
 
-  // On efface de contenu précédent
+  // On efface de contenu prÃ©cÃ©dent
   Block(origin_x,origin_y,
         Menu_factor_X*Window_special_button_list->Width,
         Menu_factor_Y*Window_special_button_list->Height,MC_Light);
@@ -827,7 +827,7 @@
     }
 
   // Dessiner la preview de la trame
-  x_size=Menu_factor_X*51; // |_ Taille de la fenêtre
+  x_size=Menu_factor_X*51; // |_ Taille de la fenÃªtre
   y_size=Menu_factor_Y*71; // |  de la preview
   for (y_pos=0; y_pos<y_size; y_pos++)
     for (x_pos=0; x_pos<x_size; x_pos++)
@@ -880,7 +880,7 @@
       Sieve[x_pos][y_pos]=!(Sieve[x_pos][y_pos]);
 }
 
-// Rafraichit toute la zone correspondant à la trame zoomee.
+// Rafraichit toute la zone correspondant Ã  la trame zoomee.
 void Update_sieve_area(short x, short y)
 {
   Update_rect(x,y,80*Menu_factor_X,80*Menu_factor_Y);
@@ -900,24 +900,24 @@
   static byte default_bg_color=0;
   T_Normal_button * button_bg_color;
   char  str[3];
-  byte  temp; // Octet temporaire servant à n'importe quoi
+  byte  temp; // Octet temporaire servant Ã  n'importe quoi
   short old_sieve_width=Sieve_width;
   short old_sieve_height=Sieve_height;
   byte  old_sieve[16][16];
-  short preview_x_start; // |  Données précalculées
-  short preview_y_start; // |_ pour la preview
-  short preview_x_end;   // |  => plus grande
-  short preview_y_end;   // |  rapidité.
+
+
+
+
 
 
   memcpy(old_sieve,Sieve,256);
 
   Open_window(290,179,"Sieve");
 
-  preview_x_start=Window_pos_X+(Menu_factor_X*230);
-  preview_y_start=Window_pos_Y+(Menu_factor_Y*78);
-  preview_x_end=preview_x_start+(Menu_factor_X*51);
-  preview_y_end=preview_y_start+(Menu_factor_Y*71);
+
+
+
+
 
   Window_display_frame      (  7, 65,130,43);
   Window_display_frame      (  7,110,130,43);
@@ -1014,10 +1014,10 @@
               temp=MC_White;
             else
               temp=MC_Black;
-            // Affichage du pixel dans la fenêtre zoomée
+            // Affichage du pixel dans la fenÃªtre zoomÃ©e
             Block(origin_x+(old_x_pos*x_pos), origin_y+(old_y_pos*y_pos),
                   x_pos-Menu_factor_X, y_pos-Menu_factor_Y, temp);
-            // Mise à jour de la preview
+            // Mise Ã  jour de la preview
             Draw_sieve_scaled(origin_x,origin_y);
             Display_cursor();
             // Maj de la case seule
@@ -1075,7 +1075,7 @@
         Change_paintbrush_shape(PAINTBRUSH_SHAPE_COLOR_BRUSH);
         break;
 
-      case  8 : // Réduire hauteur
+      case  8 : // RÃ©duire hauteur
         if (Sieve_height>1)
         {
           Hide_cursor();
@@ -1103,7 +1103,7 @@
         }
         break;
 
-      case 10 : // Réduire largeur
+      case 10 : // RÃ©duire largeur
         if (Sieve_width>1)
         {
           Hide_cursor();
@@ -1131,7 +1131,7 @@
         }
         break;
 
-      case 12 : // Toggle octets insérés
+      case 12 : // Toggle octets insÃ©rÃ©s
         Hide_cursor();
         default_bg_color=!default_bg_color;
         Block(Window_pos_X+(Menu_factor_X*(button_bg_color->Pos_X+2)),
@@ -1202,7 +1202,7 @@
         Update_sieve_area(origin_x, origin_y);
         break;
 
-      default : // Boutons de trames prédéfinies
+      default : // Boutons de trames prÃ©dÃ©finies
         Hide_cursor();
         Copy_preset_sieve(clicked_button-17);
         Draw_sieve_scaled(origin_x,origin_y);
diff -ruN gfx2orig/src/buttons.h grafx2/src/buttons.h
--- gfx2orig/src/buttons.h	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/buttons.h	2022-03-20 20:19:34.108495316 -0500
@@ -104,7 +104,7 @@
 */
 void Button_Paintbrush_menu(void);
 
-// Boutons relatifs au mode de dessin à main levée
+// Boutons relatifs au mode de dessin Ã  main levÃ©e
 
 /*!
     Callback for the freehand draw button left click.
@@ -167,7 +167,7 @@
 */
 void Button_Airbrush_menu(void);
 
-// Courbes de Bézier
+// Courbes de BÃ©zier
 
 /*!
     Callback for the curves button left click.
@@ -203,7 +203,7 @@
 */
 void Button_Text(void);
 
-// Boutons relatifs aux dégradés
+// Boutons relatifs aux dÃ©gradÃ©s
 
 /*!
     Callback for the gradation button.
@@ -217,7 +217,7 @@
 */
 void Load_gradient_data(int index);
 
-// Boutons relatifs aux cercles (ellipses) dégradé(e)s
+// Boutons relatifs aux cercles (ellipses) dÃ©gradÃ©(e)s
 
 /*!
     Callback for the gradation circle button left click.
@@ -482,7 +482,7 @@
 */
 void Button_Unselect_lasso(void);
 
-// Button relatifs à la pipette
+// Button relatifs Ã  la pipette
 
 /*!
     Starts the color picking operation.
@@ -516,14 +516,14 @@
 */
 void Button_Unselect_magnifier(void);
 
-// Les différents effets sur la brosse
+// Les diffÃ©rents effets sur la brosse
 
 /*!
     Display the Brush effects window.
 */
 void Button_Brush_FX(void);
 
-// Boutons relatifs aux différentes pages
+// Boutons relatifs aux diffÃ©rentes pages
 
 /*!
     Swap main and spare drawing pages.
@@ -545,7 +545,7 @@
 */
 void Button_Kill(void);
 
-// Boutons relatifs aux changements de résolution et de taille d'image
+// Boutons relatifs aux changements de rÃ©solution et de taille d'image
 
 /*!
     Display the screenmode menu.
@@ -579,7 +579,7 @@
 */
 void Button_Autosave(void);
 
-// Réglage des paramètres de l'utilisateur
+// RÃ©glage des paramÃ¨tres de l'utilisateur
 
 /*!
     Display the setting menu.
@@ -591,7 +591,7 @@
 */
 void Button_Skins(void);
 
-// Annulation de la dernière modification
+// Annulation de la derniÃ¨re modification
 
 /*!
     Undo the last modification to the picture.
diff -ruN gfx2orig/src/const.h grafx2/src/const.h
--- gfx2orig/src/const.h	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/const.h	2022-03-20 20:19:34.108495316 -0500
@@ -69,7 +69,7 @@
 // Character to show a left arrow, used when editing long strings. It's present in ::Gfx->System_font 
 #define LEFT_TRIANGLE_CHARACTER   17
 /// Character to display in menus for an ellipsis.
-#define ELLIPSIS_CHARACTER       ''
+#define ELLIPSIS_CHARACTER       '\x85'
 #define NB_LAYERS                  1    ///< Initial number of layers for a new image
 #define MAX_NB_LAYERS             16    ///< Maximum number of layers that can be used in grafx2. Note that 32 is upper limit because of a few bit fields.
 #define BRUSH_CONTAINER_PREVIEW_WIDTH    16  ///< Size for preview of a brush in Brush container
diff -ruN gfx2orig/src/engine.c grafx2/src/engine.c
--- gfx2orig/src/engine.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/engine.c	2022-03-20 20:19:34.108495316 -0500
@@ -48,7 +48,7 @@
 
 //---------- Annuler les effets des modes de dessin (sauf la grille) ---------
 
-// Variables mémorisants les anciens effets
+// Variables mÃ©morisants les anciens effets
 
 byte Shade_mode_before_cancel;
 byte Quick_shade_mode_before_cancel;
@@ -330,11 +330,11 @@
 {
   if (Buttons_Pool[btn_number].Pressed)
   {
-    // On affiche le cadre autour du bouton de façon à ce qu'il paraisse relâché
+    // On affiche le cadre autour du bouton de faÃ§on Ã  ce qu'il paraisse relÃ¢chÃ©
     Draw_menu_button_frame(btn_number,BUTTON_RELEASED);
-    // On considère que le bouton est relâché
+    // On considÃ¨re que le bouton est relÃ¢chÃ©
     Buttons_Pool[btn_number].Pressed=BUTTON_RELEASED;
-    // On appelle le désenclenchement particulier au bouton:
+    // On appelle le dÃ©senclenchement particulier au bouton:
     Buttons_Pool[btn_number].Unselect_action();
   }
 }
@@ -367,31 +367,31 @@
   if (icon!=-1)
     Display_sprite_in_menu(btn_number,icon+(click==RIGHT_SIDE));
 
-  // On note déjà la famille du bouton (La "Famiglia" c'est sacré)
+  // On note dÃ©jÃ  la famille du bouton (La "Famiglia" c'est sacrÃ©)
   family=Buttons_Pool[btn_number].Family;
 
   switch (family)
   {
-    case FAMILY_TOOLBAR: // On ne fait rien (on préserve les interruptions)
+    case FAMILY_TOOLBAR: // On ne fait rien (on prÃ©serve les interruptions)
       break;
 
-    case FAMILY_INTERRUPTION: // Petit cas spécial dans la famille "Interruption":
+    case FAMILY_INTERRUPTION: // Petit cas spÃ©cial dans la famille "Interruption":
       if ((btn_number!=BUTTON_MAGNIFIER) || (!Main_magnifier_mode))
       // Pour chaque bouton:
       for (b=0; b<NB_BUTTONS; b++)
-        // S'il est de la même famille
+        // S'il est de la mÃªme famille
         if (
              (b!=btn_number) &&
              (Buttons_Pool[b].Family==FAMILY_INTERRUPTION) &&
              (  (b!=BUTTON_MAGNIFIER) ||
                ((b==BUTTON_MAGNIFIER) && (!Main_magnifier_mode)) )
            )
-          // Alors on désenclenche le bouton
+          // Alors on dÃ©senclenche le bouton
           Unselect_button(b);
       break;
 
     default:
-      // On désenclenche D'ABORD les interruptions
+      // On dÃ©senclenche D'ABORD les interruptions
       // Pour chaque bouton:
       for (b=0; b<NB_BUTTONS; b++)
         // S'il est de la famille interruption
@@ -399,7 +399,7 @@
           && (Buttons_Pool[b].Family==FAMILY_INTERRUPTION)
           // Et que ce n'est pas la loupe, ou alors qu'on n'est pas en mode loupe
           && (!(Main_magnifier_mode && (b==BUTTON_MAGNIFIER))) )
-          // Alors on désenclenche le bouton
+          // Alors on dÃ©senclenche le bouton
           Unselect_button(b);
       // Right-clicking on Adjust opens a menu, so in this case we skip
       // the unselection of all "Tool" buttons.
@@ -410,14 +410,14 @@
         break;
       // Pour chaque bouton:
       for (b=0; b<NB_BUTTONS; b++)
-        // S'il est de la même famille
+        // S'il est de la mÃªme famille
         if ( (b!=btn_number)
           && (Buttons_Pool[b].Family==family) )
-          // Alors on désenclenche le bouton
+          // Alors on dÃ©senclenche le bouton
           Unselect_button(b);
   }
 
-  // On affiche le cadre autour du bouton de façon à ce qu'il paraisse enfoncé
+  // On affiche le cadre autour du bouton de faÃ§on Ã  ce qu'il paraisse enfoncÃ©
   Draw_menu_button_frame(btn_number,BUTTON_PRESSED);
 
   Display_cursor();
@@ -425,11 +425,11 @@
   if ((click==1 && !Buttons_Pool[btn_number].Left_instant)
     ||(click!=1 && !Buttons_Pool[btn_number].Right_instant))
   {
-    // On attend ensuite que l'utilisateur lâche son bouton:
+    // On attend ensuite que l'utilisateur lÃ¢che son bouton:
     Wait_end_of_click();
   }
 
-  // On considère que le bouton est enfoncé
+  // On considÃ¨re que le bouton est enfoncÃ©
   Buttons_Pool[btn_number].Pressed=BUTTON_PRESSED;
 
   // Puis on se contente d'appeler l'action correspondant au bouton:
@@ -509,10 +509,10 @@
 void Main_handler(void)
 {
   static byte temp_color;
-  int  button_index;           // Numéro de bouton de menu en cours
-  int  prev_button_number=0; // Numéro de bouton de menu sur lequel on était précédemment
-  byte blink;                   // L'opération demande un effacement du curseur
-  int  key_index;           // index du tableau de touches spéciales correspondant à la touche enfoncée
+  int  button_index;           // NumÃ©ro de bouton de menu en cours
+  int  prev_button_number=0; // NumÃ©ro de bouton de menu sur lequel on Ã©tait prÃ©cÃ©demment
+  byte blink;                   // L'opÃ©ration demande un effacement du curseur
+  int  key_index;           // index du tableau de touches spÃ©ciales correspondant Ã  la touche enfoncÃ©e
   char str[25];
   byte temp;
   byte effect_modified;
@@ -577,7 +577,7 @@
                 Special_previous_backcolor();
                 action++;
                 break;
-              case SPECIAL_SMALLER_PAINTBRUSH: // Rétrécir le pinceau
+              case SPECIAL_SMALLER_PAINTBRUSH: // RÃ©trÃ©cir le pinceau
                 Smaller_paintbrush();
                 action++;
                 break;
@@ -726,13 +726,13 @@
                 Display_cursor();
                 action++;
                 break;
-              case SPECIAL_ROTATE_90 : // 90° brush rotation
+              case SPECIAL_ROTATE_90 : // 90Â° brush rotation
                 Hide_cursor();
                 Rotate_90_deg();
                 Display_cursor();
                 action++;
                 break;
-              case SPECIAL_ROTATE_180 : // 180° brush rotation
+              case SPECIAL_ROTATE_180 : // 180Â° brush rotation
                 Hide_cursor();
                 Rotate_180_deg_lowlevel(Brush, Brush_width, Brush_height);
                 Brush_offset_X=(Brush_width>>1);
@@ -1097,8 +1097,8 @@
           }
         }
   
-        // Si on a modifié un effet, il faut rafficher le bouton des effets en
-        // conséquence.
+        // Si on a modifiÃ© un effet, il faut rafficher le bouton des effets en
+        // consÃ©quence.
         if (effect_modified)
         {
           Hide_cursor();
@@ -1119,10 +1119,10 @@
   
       Uint32 debut;
       debut = SDL_GetTicks();
-      // Première attente : le complément de "delay" millisecondes
+      // PremiÃ¨re attente : le complÃ©ment de "delay" millisecondes
       SDL_Delay(delay - (debut % delay));
-      // Si ça ne suffit pas, on complète par des attentes successives de "1ms".
-      // (Remarque, Windows arrondit généralement aux 10ms supérieures)
+      // Si Ã§a ne suffit pas, on complÃ¨te par des attentes successives de "1ms".
+      // (Remarque, Windows arrondit gÃ©nÃ©ralement aux 10ms supÃ©rieures)
       while ( SDL_GetTicks()/delay <= debut/delay)
       {
         SDL_Delay(1);
@@ -1153,7 +1153,7 @@
         {
           if (Menu_is_visible)
           {
-            // On nettoie les coordonnées
+            // On nettoie les coordonnÃ©es
             Hide_cursor();
             Block(18*Menu_factor_X,Menu_status_Y,192*Menu_factor_X,Menu_factor_Y<<3,MC_Light);
             Update_rect(18*Menu_factor_X,Menu_status_Y,192*Menu_factor_X,Menu_factor_Y<<3);
@@ -1228,7 +1228,7 @@
 
 
     // Le curseur se trouve dans l'image
-    if ( (!Cursor_in_menu) && (Menu_is_visible) && (Old_MY != Mouse_Y || Old_MX != Mouse_X || Key || Mouse_K)) // On ne met les coordonnées à jour que si l'utilisateur a fait un truc
+    if ( (!Cursor_in_menu) && (Menu_is_visible) && (Old_MY != Mouse_Y || Old_MX != Mouse_X || Key || Mouse_K)) // On ne met les coordonnÃ©es Ã  jour que si l'utilisateur a fait un truc
     {
        if ( (Current_operation!=OPERATION_COLORPICK) && (Current_operation!=OPERATION_REPLACE) )
        {
@@ -1272,14 +1272,14 @@
 
 
 //////////////////////////////////////////////////////////////////////////////
-//      différentes fonctions d'affichage utilisées dans les fenêtres       //
+//      diffÃ©rentes fonctions d'affichage utilisÃ©es dans les fenÃªtres       //
 //////////////////////////////////////////////////////////////////////////////
 
-//----------------------- Tracer une fenêtre d'options -----------------------
+//----------------------- Tracer une fenÃªtre d'options -----------------------
 
 void Open_window(word width,word height, const char * title)
-// Lors de l'appel à cette procédure, la souris doit être affichée.
-// En sortie de cette procedure, la souris est effacée.
+// Lors de l'appel Ã  cette procÃ©dure, la souris doit Ãªtre affichÃ©e.
+// En sortie de cette procedure, la souris est effacÃ©e.
 {
   //word i,j;
   size_t title_length;
@@ -1291,18 +1291,18 @@
   Window_width=width;
   Window_height=height;
 
-  // Positionnement de la fenêtre
+  // Positionnement de la fenÃªtre
   Window_pos_X=(Screen_width-(width*Menu_factor_X))>>1;
 
   Window_pos_Y=(Screen_height-(height*Menu_factor_Y))>>1;
 
-  // Sauvegarde de ce que la fenêtre remplace
+  // Sauvegarde de ce que la fenÃªtre remplace
   Save_background(&(Window_background[Windows_open-1]), Window_pos_X, Window_pos_Y, width, height);
 
-  // Fenêtre grise
+  // FenÃªtre grise
   Block(Window_pos_X+(Menu_factor_X<<1),Window_pos_Y+(Menu_factor_Y<<1),(width-4)*Menu_factor_X,(height-4)*Menu_factor_Y,MC_Light);
 
-  // -- Frame de la fenêtre ----- --- -- -  -
+  // -- Frame de la fenÃªtre ----- --- -- -  -
 
   // Frame noir puis en relief
   Window_display_frame_mono(0,0,width,height,MC_Black);
@@ -1329,7 +1329,7 @@
     Paintbrush_hidden=1;
   }
 
-  // Initialisation des listes de boutons de la fenêtre
+  // Initialisation des listes de boutons de la fenÃªtre
   Window_normal_button_list  =NULL;
   Window_palette_button_list =NULL;
   Window_scroller_button_list=NULL;
@@ -1339,11 +1339,11 @@
 
 }
 
-//----------------------- Fermer une fenêtre d'options -----------------------
+//----------------------- Fermer une fenÃªtre d'options -----------------------
 
 void Close_window(void)
-// Lors de l'appel à cette procedure, la souris doit être affichée.
-// En sortie de cette procedure, la souris est effacée.
+// Lors de l'appel Ã  cette procedure, la souris doit Ãªtre affichÃ©e.
+// En sortie de cette procedure, la souris est effacÃ©e.
 {
   T_Normal_button   * temp1;
   T_Palette_button  * temp2;
@@ -1394,7 +1394,7 @@
 
   if (Windows_open != 1)
   {
-    // Restore de ce que la fenêtre cachait
+    // Restore de ce que la fenÃªtre cachait
     Restore_background(Window_background[Windows_open-1], Window_pos_X, Window_pos_Y, Window_width, Window_height);
     Window_background[Windows_open-1]=NULL;
     Update_rect(Window_pos_X,Window_pos_Y,Window_width*Menu_factor_X,Window_height*Menu_factor_Y);
@@ -1427,7 +1427,7 @@
 }
 
 
-//---------------- Dessiner un bouton normal dans une fenêtre ----------------
+//---------------- Dessiner un bouton normal dans une fenÃªtre ----------------
 
 void Window_draw_normal_bouton(word x_pos,word y_pos,word width,word height,
                                     char * title,byte undersc_letter,byte clickable)
@@ -1459,14 +1459,14 @@
 }
 
 
-// -- Button normal enfoncé dans la fenêtre --
+// -- Button normal enfoncÃ© dans la fenÃªtre --
 void Window_select_normal_button(word x_pos,word y_pos,word width,word height)
 {
   Window_display_frame_generic(x_pos,y_pos,width,height,MC_Dark,MC_Black,MC_Dark,MC_Dark,MC_Black);
   Update_rect(Window_pos_X+x_pos*Menu_factor_X, Window_pos_Y+y_pos*Menu_factor_Y, width*Menu_factor_X, height*Menu_factor_Y);
 }
 
-// -- Button normal désenfoncé dans la fenêtre --
+// -- Button normal dÃ©senfoncÃ© dans la fenÃªtre --
 void Window_unselect_normal_button(word x_pos,word y_pos,word width,word height)
 {
   Window_display_frame_out(x_pos,y_pos,width,height);
@@ -1474,7 +1474,7 @@
 }
 
 
-//--------------- Dessiner un bouton palette dans une fenêtre ----------------
+//--------------- Dessiner un bouton palette dans une fenÃªtre ----------------
 void Window_draw_palette_bouton(word x_pos,word y_pos)
 {
   word color;
@@ -1487,7 +1487,7 @@
 
 
 // -------------------- Effacer les TAGs sur les palette ---------------------
-// Cette fonct° ne sert plus que lorsqu'on efface les tags dans le menu Spray.
+// Cette fonctÂ° ne sert plus que lorsqu'on efface les tags dans le menu Spray.
 void Window_clear_tags(void)
 {
   word origin_x;
@@ -1537,10 +1537,10 @@
 
   if (start!=end)
   {
-    // On complète le 1er TAG
+    // On complÃ¨te le 1er TAG
     Pixel_in_window(origin_x+1,origin_y+4,MC_Black);
 
-    // On affiche le 2ème TAG
+    // On affiche le 2Ã¨me TAG
     origin_x=(Window_palette_button_list->Pos_X+3)+(end>>4)*10;
     origin_y=(Window_palette_button_list->Pos_Y+3)+(end&15)* 5;
     for (y_pos=0,window_y_pos=origin_y; y_pos<5; y_pos++,window_y_pos++)
@@ -1549,13 +1549,13 @@
       Pixel_in_window(origin_x+1,window_y_pos,MC_Black);
     Pixel_in_window(origin_x+2,origin_y+2,MC_Black);
 
-    // On TAG toutes les couleurs intermédiaires
+    // On TAG toutes les couleurs intermÃ©diaires
     for (index=start+1;index<end;index++)
     {
       Block(Window_pos_X+(Window_palette_button_list->Pos_X+3+((index>>4)*10))*Menu_factor_X,
             Window_pos_Y+(Window_palette_button_list->Pos_Y+3+((index&15)* 5))*Menu_factor_Y,
             Menu_factor_X*2,Menu_factor_Y*5,MC_Black);
-      // On efface l'éventuelle pointe d'une ancienne extrémité de l'intervalle
+      // On efface l'Ã©ventuelle pointe d'une ancienne extrÃ©mitÃ© de l'intervalle
       Pixel_in_window(Window_palette_button_list->Pos_X+5+((index>>4)*10),
                          Window_palette_button_list->Pos_Y+5+((index&15)* 5),
                          MC_Light);
@@ -1569,7 +1569,7 @@
 }
 
 
-//------------------ Dessiner un scroller dans une fenêtre -------------------
+//------------------ Dessiner un scroller dans une fenÃªtre -------------------
 
 void Compute_slider_cursor_height(T_Scroller_button * button)
 {
@@ -1619,7 +1619,7 @@
 }
 
 
-//--------------- Dessiner une zone de saisie dans une fenêtre ---------------
+//--------------- Dessiner une zone de saisie dans une fenÃªtre ---------------
 
 void Window_draw_input_bouton(word x_pos,word y_pos,word width_in_characters)
 {
@@ -1643,7 +1643,7 @@
 }
 
 
-//------ Rajout d'un bouton à la liste de ceux présents dans la fenêtre ------
+//------ Rajout d'un bouton Ã  la liste de ceux prÃ©sents dans la fenÃªtre ------
 
 T_Normal_button * Window_set_normal_button(word x_pos, word y_pos,
                                    word width, word height,
@@ -1673,7 +1673,7 @@
   Window_draw_normal_bouton(x_pos,y_pos,width,height,title,undersc_letter,clickable);
   return temp;
 }
-//------ Rajout d'un bouton à la liste de ceux présents dans la fenêtre ------
+//------ Rajout d'un bouton Ã  la liste de ceux prÃ©sents dans la fenÃªtre ------
 
 T_Normal_button * Window_set_repeatable_button(word x_pos, word y_pos,
                                    word width, word height,
@@ -1800,9 +1800,9 @@
   return temp;
 }
 
-// Ajoute un choix à une dropdown. Le libellé est seulement référencé,
-// il doit pointer sur une zone qui doit être encore valide à la fermeture 
-// de la fenêtre (comprise).
+// Ajoute un choix Ã  une dropdown. Le libellÃ© est seulement rÃ©fÃ©rencÃ©,
+// il doit pointer sur une zone qui doit Ãªtre encore valide Ã  la fermeture 
+// de la fenÃªtre (comprise).
 void Window_dropdown_add_item(T_Dropdown_button * dropdown, word btn_number, const char *label)
 {
   T_Dropdown_choice *temp;
@@ -1816,7 +1816,7 @@
   last=dropdown->First_item;
   if (last)
   {
-    // On cherche le dernier élément
+    // On cherche le dernier Ã©lÃ©ment
     for (;last->Next;last=last->Next)
       ;
     last->Next=temp;
@@ -1878,12 +1878,12 @@
 //----------------------- Ouverture d'un pop-up -----------------------
 
 void Open_popup(word x_pos, word y_pos, word width,word height)
-// Lors de l'appel à cette procédure, la souris doit être affichée.
-// En sortie de cette procedure, la souris est effacée.
+// Lors de l'appel Ã  cette procÃ©dure, la souris doit Ãªtre affichÃ©e.
+// En sortie de cette procedure, la souris est effacÃ©e.
 
-// Note : les pop-ups sont gérés comme s'ils étaient des sous-fenêtres, ils ont donc leur propre boucle d'évènements et tout, on peut ajouter des widgets dedans, ...
-// Les différences sont surtout graphiques :
-    // -Possibilité de préciser la position XY
+// Note : les pop-ups sont gÃ©rÃ©s comme s'ils Ã©taient des sous-fenÃªtres, ils ont donc leur propre boucle d'Ã©vÃ¨nements et tout, on peut ajouter des widgets dedans, ...
+// Les diffÃ©rences sont surtout graphiques :
+    // -PossibilitÃ© de prÃ©ciser la position XY
     // -Pas de titre
     // -Pas de cadre en relief mais seulement un plat, et il est blanc au lieu de noir.
 {
@@ -1894,11 +1894,11 @@
   Window_pos_X=x_pos;
   Window_pos_Y=y_pos;
 
-  // Sauvegarde de ce que la fenêtre remplace
+  // Sauvegarde de ce que la fenÃªtre remplace
   Save_background(&(Window_background[Windows_open-1]), Window_pos_X, Window_pos_Y, width, height);
 
 /*
-  // Fenêtre grise
+  // FenÃªtre grise
   Block(Window_pos_X+1*Menu_factor_X,
         Window_pos_Y+1*Menu_factor_Y,
         (width-2)*Menu_factor_X,(height-2)*Menu_factor_Y,MC_Light);
@@ -1918,7 +1918,7 @@
     Paintbrush_hidden=1;
   }
 
-  // Initialisation des listes de boutons de la fenêtre
+  // Initialisation des listes de boutons de la fenÃªtre
   Window_normal_button_list  =NULL;
   Window_palette_button_list =NULL;
   Window_scroller_button_list=NULL;
@@ -1928,11 +1928,11 @@
 
 }
 
-//----------------------- Fermer une fenêtre d'options -----------------------
+//----------------------- Fermer une fenÃªtre d'options -----------------------
 
 void Close_popup(void)
-// Lors de l'appel à cette procedure, la souris doit être affichée.
-// En sortie de cette procedure, la souris est effacée.
+// Lors de l'appel Ã  cette procedure, la souris doit Ãªtre affichÃ©e.
+// En sortie de cette procedure, la souris est effacÃ©e.
 {
   T_Normal_button   * temp1;
   T_Palette_button  * temp2;
@@ -1983,7 +1983,7 @@
   
   if (Windows_open != 1)
   {
-    // Restore de ce que la fenêtre cachait
+    // Restore de ce que la fenÃªtre cachait
     Restore_background(Window_background[Windows_open-1], Window_pos_X, Window_pos_Y, Window_width, Window_height);
     Window_background[Windows_open-1]=NULL;
     Update_rect(Window_pos_X,Window_pos_Y,Window_width*Menu_factor_X,Window_height*Menu_factor_Y);
@@ -2017,12 +2017,12 @@
 }
 //////////////////////////////////////////////////////////////////////////////
 //                                                                          //
-//       Mini-MOTEUR utilisé dans les fenêtres (menus des boutons...)       //
+//       Mini-MOTEUR utilisÃ© dans les fenÃªtres (menus des boutons...)       //
 //                                                                          //
 //////////////////////////////////////////////////////////////////////////////
 
 
-// -- Indique si on a cliqué dans une zone définie par deux points extremes --
+// -- Indique si on a cliquÃ© dans une zone dÃ©finie par deux points extremes --
 byte Window_click_in_rectangle(short start_x,short start_y,short end_x,short end_y)
 {
   short x_pos,y_pos;
@@ -2038,7 +2038,7 @@
 
 
 // --- Attend que l'on clique dans la palette pour renvoyer la couleur choisie
-// ou bien renvoie -1 si on a annulé l'action pas click-droit ou Escape ------
+// ou bien renvoie -1 si on a annulÃ© l'action pas click-droit ou Escape ------
 short Wait_click_in_palette(T_Palette_button * button)
 {
   short start_x=button->Pos_X+5;
@@ -2102,13 +2102,13 @@
 
 
 
-// -------------- Récupération d'une couleur derrière un menu ----------------
+// -------------- RÃ©cupÃ©ration d'une couleur derriÃ¨re un menu ----------------
 void Get_color_behind_window(byte * color, byte * click)
 {
   short old_x=-1;
   short old_y=-1;
   short index;
-  short a,b,c,d; // Variables temporaires et multitâches...
+  short a,b,c,d; // Variables temporaires et multitÃ¢ches...
   byte * buffer = NULL;
   char str[25];
   byte cursor_was_hidden;
@@ -2132,7 +2132,7 @@
   Cursor_shape=CURSOR_SHAPE_COLORPICKER;
   b=Paintbrush_hidden;
   Paintbrush_hidden=1;
-  c=-1; // color pointée: au début aucune, comme ça on initialise tout
+  c=-1; // color pointÃ©e: au dÃ©but aucune, comme Ã§a on initialise tout
   if (Menu_is_visible_before_window)
     Print_in_menu(Menu_tooltip[BUTTON_CHOOSE_COL],0);
 
@@ -2148,7 +2148,7 @@
       a=Read_pixel(Mouse_X,Mouse_Y);
       if (a!=c)
       {
-        c=a; // Mise à jour de la couleur pointée
+        c=a; // Mise Ã  jour de la couleur pointÃ©e
         if (Menu_is_visible_before_window)
         {
           sprintf(str,"%d",a);
@@ -2199,7 +2199,7 @@
 
 
 
-// ------------ Opération de déplacement de la fenêtre à l'écran -------------
+// ------------ OpÃ©ration de dÃ©placement de la fenÃªtre Ã  l'Ã©cran -------------
 void Move_window(short dx, short dy)
 {
   short new_x=Mouse_X-dx;
@@ -2293,21 +2293,21 @@
     Menu_Y=a;
     Menu_is_visible=b;
 
-    // Sauvegarde du contenu actuel de la fenêtre
+    // Sauvegarde du contenu actuel de la fenÃªtre
     Save_background(&buffer, Window_pos_X, Window_pos_Y, Window_width, Window_height);
     
-    // Restore de ce que la fenêtre cachait
+    // Restore de ce que la fenÃªtre cachait
     Restore_background(Window_background[Windows_open-1], Window_pos_X, Window_pos_Y, Window_width, Window_height);
     Window_background[Windows_open-1] = NULL;
 
-    // Sauvegarde de ce que la fenêtre remplace
+    // Sauvegarde de ce que la fenÃªtre remplace
     Save_background(&(Window_background[Windows_open-1]), new_x, new_y, Window_width, Window_height);
 
-    // Raffichage de la fenêtre
+    // Raffichage de la fenÃªtre
     Restore_background(buffer, new_x, new_y, Window_width, Window_height);
     buffer = NULL;
 
-    // Mise à jour du rectangle englobant
+    // Mise Ã  jour du rectangle englobant
     Update_rect(
       (new_x>Window_pos_X)?Window_pos_X:new_x,
       (new_y>Window_pos_Y)?Window_pos_Y:new_y,
@@ -2341,7 +2341,7 @@
   short box_height;
   T_Dropdown_choice *item;
   
-  // Taille de l'ombre portée (en plus des dimensions normales)
+  // Taille de l'ombre portÃ©e (en plus des dimensions normales)
   #define SHADOW_RIGHT 3
   #define SHADOW_BOTTOM 4
 
@@ -2367,7 +2367,7 @@
   Block(Window_pos_X,Window_pos_Y,Menu_factor_X,box_height*Menu_factor_Y,MC_Black);
   // Frame fonce et blanc
   Window_display_frame_out(1,0,button->Dropdown_width-1,box_height);
-  // Ombre portée
+  // Ombre portÃ©e
   if (SHADOW_BOTTOM)
   {
     Block(Window_pos_X+SHADOW_RIGHT*Menu_factor_X,
@@ -2399,7 +2399,7 @@
   while (1)
   {
     old_selected_index = selected_index;
-    // Fenêtre grise
+    // FenÃªtre grise
     Block(Window_pos_X+2*Menu_factor_X,
         Window_pos_Y+1*Menu_factor_Y,
         (button->Dropdown_width-3)*Menu_factor_X,(box_height-2)*Menu_factor_Y,MC_Light);
@@ -2430,7 +2430,7 @@
     {
       // Attente
       if(!Get_input()) SDL_Delay(20);
-      // Mise à jour du survol
+      // Mise Ã  jour du survol
       selected_index=Window_click_in_rectangle(2,2,button->Dropdown_width-2,box_height-1)?
         (((Mouse_Y-Window_pos_Y)/Menu_factor_Y-2)>>3) : -1;
 
@@ -2488,9 +2488,9 @@
   
 }
 
-// --- Fonction de clic sur un bouton a peu près ordinaire:
+// --- Fonction de clic sur un bouton a peu prÃ¨s ordinaire:
 // Attend que l'on relache le bouton, et renvoie le numero du bouton si on
-// est resté dessus, 0 si on a annulé en sortant du bouton.
+// est restÃ© dessus, 0 si on a annulÃ© en sortant du bouton.
 short Window_normal_button_onclick(word x_pos, word y_pos, word width, word height, short btn_number)
 {
   while(1)
@@ -2718,7 +2718,7 @@
   else
     Window_attribute1=LEFT_SIDE;
 
-  // On fait une première recherche
+  // On fait une premiÃ¨re recherche
   temp=Window_normal_button_list;
   while (temp!=NULL)
   {
@@ -2739,9 +2739,9 @@
     temp=temp->Next;
   }
 
-  // Si la recherche n'a pas été fructueuse ET que l'utilisateur appuyait sur
-  // <Shift>, on regarde si un bouton ne pourrait pas réagir comme si <Shift>
-  // n'était pas appuyé.
+  // Si la recherche n'a pas Ã©tÃ© fructueuse ET que l'utilisateur appuyait sur
+  // <Shift>, on regarde si un bouton ne pourrait pas rÃ©agir comme si <Shift>
+  // n'Ã©tait pas appuyÃ©.
   if (Window_attribute1==RIGHT_SIDE)
   {
     temp=Window_normal_button_list;
@@ -2890,7 +2890,7 @@
           {
             list->List_start=list->List_start+list->Cursor_position;
             list->Cursor_position=0;
-            // Mise à jour du scroller
+            // Mise Ã  jour du scroller
             list->Scroller->Position=list->List_start;
             Window_draw_slider(list->Scroller);
           }
@@ -2910,7 +2910,7 @@
           {
             list->List_start=list->List_start+list->Cursor_position-(list->Scroller->Nb_visibles-1);
             list->Cursor_position=(list->Scroller->Nb_visibles-1);
-            // Mise à jour du scroller
+            // Mise Ã  jour du scroller
             list->Scroller->Position=list->List_start;
             Window_draw_slider(list->Scroller);
           }
@@ -2927,7 +2927,7 @@
           Hide_cursor();
           list->Cursor_position=0;
           list->List_start=0;
-          // Mise à jour du scroller
+          // Mise Ã  jour du scroller
           list->Scroller->Position=list->List_start;
           Window_draw_slider(list->Scroller);
           Window_redraw_list(list);
@@ -2946,7 +2946,7 @@
           {
             list->List_start=list->List_start+list->Cursor_position-(list->Scroller->Nb_visibles-1);
             list->Cursor_position=(list->Scroller->Nb_visibles-1);
-            // Mise à jour du scroller
+            // Mise Ã  jour du scroller
             list->Scroller->Position=list->List_start;
             Window_draw_slider(list->Scroller);
           }
@@ -2976,7 +2976,7 @@
             {
               list->List_start=list->Scroller->Nb_elements-list->Scroller->Nb_visibles;
             }
-            // Mise à jour du scroller
+            // Mise Ã  jour du scroller
             list->Scroller->Position=list->List_start;
             Window_draw_slider(list->Scroller);
           }
@@ -3002,7 +3002,7 @@
             {
               list->List_start=0;
             }
-            // Mise à jour du scroller
+            // Mise Ã  jour du scroller
             list->Scroller->Position=list->List_start;
             Window_draw_slider(list->Scroller);
           }
@@ -3021,10 +3021,10 @@
           else
             list->List_start=0;
           list->Cursor_position-=list->List_start;
-          // On affiche à nouveau la liste
+          // On affiche Ã  nouveau la liste
           Hide_cursor();
           Window_redraw_list(list);
-          // Mise à jour du scroller
+          // Mise Ã  jour du scroller
           list->Scroller->Position=list->List_start;
           Window_draw_slider(list->Scroller);
           Display_cursor();
@@ -3038,10 +3038,10 @@
             list->List_start=list->Scroller->Nb_elements-list->Scroller->Nb_visibles;
           }          
           list->Cursor_position-=list->List_start;
-          // On affiche à nouveau la liste
+          // On affiche Ã  nouveau la liste
           Hide_cursor();
           Window_redraw_list(list);
-          // Mise à jour du scroller
+          // Mise Ã  jour du scroller
           list->Scroller->Position=list->List_start;
           Window_draw_slider(list->Scroller);
           Display_cursor();
@@ -3055,8 +3055,8 @@
 }
 
 
-// Fonction qui sert à remapper les parties sauvegardées derriere les
-// fenetres ouvertes. C'est utilisé par exemple par la fenetre de palette
+// Fonction qui sert Ã  remapper les parties sauvegardÃ©es derriere les
+// fenetres ouvertes. C'est utilisÃ© par exemple par la fenetre de palette
 // Qui remappe des couleurs, afin de propager les changements.
 void Remap_window_backgrounds(byte * conversion_table, int Min_Y, int Max_Y)
 {
diff -ruN gfx2orig/src/factory.c grafx2/src/factory.c
--- gfx2orig/src/factory.c	2010-03-21 16:47:25.000000000 -0500
+++ grafx2/src/factory.c	2022-03-20 20:19:34.108495316 -0500
@@ -26,6 +26,11 @@
 
 #include <math.h>
 
+#if defined(FDOS)
+#include <stdlib.h> // free
+#include <string.h> // memcpy
+#endif
+
 #include "brush.h"
 #include "buttons.h"
 #include "engine.h"
diff -ruN gfx2orig/src/fileformats.c grafx2/src/fileformats.c
--- gfx2orig/src/fileformats.c	2010-03-22 04:36:40.000000000 -0500
+++ grafx2/src/fileformats.c	2022-03-20 20:19:34.108495316 -0500
@@ -31,6 +31,10 @@
 
 #include <stdlib.h>
 
+#if defined(FDOS)
+#include <string.h> // strlen
+#endif
+
 #include "errors.h"
 #include "global.h"
 #include "loadsave.h"
@@ -58,7 +62,7 @@
   // Ouverture du fichier
   if ((file=fopen(filename, "rb")))
   {
-    // Lecture et vérification de la signature
+    // Lecture et vÃ©rification de la signature
     if (Read_bytes(file,IMG_header.Filler1,sizeof(IMG_header.Filler1))
     && Read_word_le(file,&(IMG_header.Width))
     && Read_word_le(file,&(IMG_header.Height))
@@ -87,6 +91,10 @@
   long file_size;
   T_IMG_Header IMG_header;
 
+#if defined(FDOS)
+  (void) width_read; // Silence 'set but not used' compiler warning.
+#endif
+
   Get_full_filename(filename, context->File_name, context->File_directory);
   File_error=0;
 
@@ -187,7 +195,7 @@
       if (File_error)
         remove(filename);
     }
-    else // Error d'écriture (disque plein ou protégé)
+    else // Error d'Ã©criture (disque plein ou protÃ©gÃ©)
     {
       fclose(file);
       remove(filename);
@@ -249,10 +257,10 @@
     else
     {
       Read_dword_be(LBM_file, &dummy);
-                   //   On aurait pu vérifier que ce long est égal à la taille
-                   // du fichier - 8, mais ça aurait interdit de charger des
-                   // fichiers tronqués (et déjà que c'est chiant de perdre
-                   // une partie du fichier il faut quand même pouvoir en
+                   //   On aurait pu vÃ©rifier que ce long est Ã©gal Ã  la taille
+                   // du fichier - 8, mais Ã§a aurait interdit de charger des
+                   // fichiers tronquÃ©s (et dÃ©jÃ  que c'est chiant de perdre
+                   // une partie du fichier il faut quand mÃªme pouvoir en
                    // garder un peu... Sinon, moi je pleure :'( !!! )
       if (! Read_bytes(LBM_file,format,4))
         File_error=1;
@@ -325,7 +333,7 @@
           }
         }
       }
-      // Ici, il reste les 16 dernières couleurs à modifier
+      // Ici, il reste les 16 derniÃ¨res couleurs Ã  modifier
       for (i=240,j=0; j<16; i++,j++)
       {
         temp=context->Palette[j].R+8;
@@ -363,7 +371,7 @@
         }
       }
     }
-    else // Image 64 couleurs sauvée en 32.
+    else // Image 64 couleurs sauvÃ©e en 32.
     {
       for (i=0; i<32; i++)
       {
@@ -378,13 +386,13 @@
   // ------------------------- Attendre une section -------------------------
   byte Wait_for(byte * expected_section)
   {
-    // Valeur retournée: 1=Section trouvée, 0=Section non trouvée (erreur)
+    // Valeur retournÃ©e: 1=Section trouvÃ©e, 0=Section non trouvÃ©e (erreur)
     dword Taille_section;
     byte section_read[4];
 
     if (! Read_bytes(LBM_file,section_read,4))
       return 0;
-    while (memcmp(section_read,expected_section,4)) // Sect. pas encore trouvée
+    while (memcmp(section_read,expected_section,4)) // Sect. pas encore trouvÃ©e
     {
       if (!Read_dword_be(LBM_file,&Taille_section))
         return 0;
@@ -398,7 +406,7 @@
     return 1;
   }
 
-// Les images ILBM sont stockés en bitplanes donc on doit trifouiller les bits pour
+// Les images ILBM sont stockÃ©s en bitplanes donc on doit trifouiller les bits pour
 // en faire du chunky
 
 byte Color_ILBM_line(word x_pos, word real_line_size, byte HBPm1)
@@ -527,7 +535,7 @@
   {
     file_size=File_length_file(LBM_file);
 
-    // On avance dans le fichier (pas besoin de tester ce qui l'a déjà été)
+    // On avance dans le fichier (pas besoin de tester ce qui l'a dÃ©jÃ  Ã©tÃ©)
     Read_bytes(LBM_file,section,4);
     Read_dword_be(LBM_file,&dummy);
     Read_bytes(LBM_file,format,4);
@@ -560,15 +568,15 @@
         {
           if ((nb_colors==32) && (header.BitPlanes==6))
           {              // Ce n'est pas une image HAM mais une image 64 coul.
-            Image_HAM=1; // Sauvée en 32 coul. => il faut copier les 32 coul.
-          }              // sur les 32 suivantes et assombrir ces dernières.
+            Image_HAM=1; // SauvÃ©e en 32 coul. => il faut copier les 32 coul.
+          }              // sur les 32 suivantes et assombrir ces derniÃ¨res.
           else
           {
             if ((header.BitPlanes==6) || (header.BitPlanes==8))
               Image_HAM=header.BitPlanes;
             else
-              /* File_error=1;*/  /* C'est censé être incorrect mais j'ai */
-              Image_HAM=0;            /* trouvé un fichier comme ça, alors... */
+              /* File_error=1;*/  /* C'est censÃ© Ãªtre incorrect mais j'ai */
+              Image_HAM=0;            /* trouvÃ© un fichier comme Ã§a, alors... */
           }
         }
         else
@@ -583,9 +591,9 @@
           // Deluxe paint le fait... alors on le fait...
           Back_color=header.Transp_col;
 
-          // On commence par passer la palette en 256 comme ça, si la nouvelle
-          // palette a moins de 256 coul, la précédente ne souffrira pas d'un
-          // assombrissement préjudiciable.
+          // On commence par passer la palette en 256 comme Ã§a, si la nouvelle
+          // palette a moins de 256 coul, la prÃ©cÃ©dente ne souffrira pas d'un
+          // assombrissement prÃ©judiciable.
           if (Config.Clear_palette)
             memset(context->Palette,0,sizeof(T_Palette));
           else
@@ -635,7 +643,7 @@
                   }
 
                   if (!header.Compression)
-                  {                                           // non compressé
+                  {                                           // non compressÃ©
                     LBM_buffer=(byte *)malloc(line_size);
                     for (y_pos=0; ((y_pos<context->Height) && (!File_error)); y_pos++)
                     {
@@ -648,7 +656,7 @@
                     LBM_buffer = NULL;
                   }
                   else
-                  {                                               // compressé
+                  {                                               // compressÃ©
                     /*Init_lecture();*/
 
                     LBM_buffer=(byte *)malloc(line_size);
@@ -662,7 +670,7 @@
                           File_error=2;
                           break;
                         }
-                        // Si temp_byte > 127 alors il faut répéter 256-'temp_byte' fois la couleur de l'octet suivant
+                        // Si temp_byte > 127 alors il faut rÃ©pÃ©ter 256-'temp_byte' fois la couleur de l'octet suivant
                         // Si temp_byte <= 127 alors il faut afficher directement les 'temp_byte' octets suivants
                         if (temp_byte>127)
                         {
@@ -697,7 +705,7 @@
                   real_line_size=context->Width+(context->Width&1);
 
                   if (!header.Compression)
-                  {                                           // non compressé
+                  {                                           // non compressÃ©
                     LBM_buffer=(byte *)malloc(real_line_size);
                     for (y_pos=0; ((y_pos<context->Height) && (!File_error)); y_pos++)
                     {
@@ -711,7 +719,7 @@
                     LBM_buffer = NULL;
                   }
                   else
-                  {                                               // compressé
+                  {                                               // compressÃ©
                     /*Init_lecture();*/
                     for (y_pos=0; ((y_pos<context->Height) && (!File_error)); y_pos++)
                     {
@@ -812,11 +820,11 @@
 
     switch (LBM_list_size)
     {
-      case 0 : // Première couleur
+      case 0 : // PremiÃ¨re couleur
         LBM_color_list[0]=color;
         LBM_list_size=1;
         break;
-      case 1 : // Deuxième couleur
+      case 1 : // DeuxiÃ¨me couleur
         last_color=LBM_color_list[0];
         LBM_repetition_mode=(last_color==color);
         LBM_color_list[1]=color;
@@ -825,7 +833,7 @@
       default: // Couleurs suivantes
         last_color      =LBM_color_list[LBM_list_size-1];
         second_last_color=LBM_color_list[LBM_list_size-2];
-        if (last_color==color)  // On a une répétition de couleur
+        if (last_color==color)  // On a une rÃ©pÃ©tition de couleur
         {
           if ( (LBM_repetition_mode) || (second_last_color!=color) )
           // On conserve le mode...
@@ -846,7 +854,7 @@
             LBM_repetition_mode=1;
           }
         }
-        else // La couleur n'est pas la même que la précédente
+        else // La couleur n'est pas la mÃªme que la prÃ©cÃ©dente
         {
           if (!LBM_repetition_mode)                 // On conserve le mode...
           {
@@ -882,7 +890,7 @@
   if ((LBM_file=fopen(filename,"wb")))
   {
     Write_bytes(LBM_file,"FORM",4);
-    Write_dword_be(LBM_file,0); // On mettra la taille à jour à la fin
+    Write_dword_be(LBM_file,0); // On mettra la taille Ã  jour Ã  la fin
 
     Write_bytes(LBM_file,"PBM BMHD",8);
     Write_dword_be(LBM_file,20);
@@ -925,7 +933,7 @@
     Write_bytes(LBM_file,context->Palette,sizeof(T_Palette));
 
     Write_bytes(LBM_file,"BODY",4);
-    Write_dword_be(LBM_file,0); // On mettra la taille à jour à la fin
+    Write_dword_be(LBM_file,0); // On mettra la taille Ã  jour Ã  la fin
 
     Init_write_buffer();
 
@@ -956,7 +964,7 @@
         fseek(LBM_file,4,SEEK_SET);
 
         //   Si la taille de la section de l'image (taille fichier-8) est
-        // impaire, on rajoute un 0 (Padding) à la fin.
+        // impaire, on rajoute un 0 (Padding) Ã  la fin.
         if ((file_size) & 1)
         {
           Write_dword_be(LBM_file,file_size-7);
@@ -1157,7 +1165,7 @@
           {
             if (Config.Clear_palette)
               memset(context->Palette,0,sizeof(T_Palette));
-            //   On peut maintenant transférer la nouvelle palette
+            //   On peut maintenant transfÃ©rer la nouvelle palette
             for (index=0; index<nb_colors; index++)
             {
               context->Palette[index].R=local_palette[index][2];
@@ -1174,7 +1182,7 @@
               case 0 : // Pas de compression
                 line_size=context->Width;
                 x_pos=(32/header.Nb_bits); // x_pos sert de variable temporaire
-                // On arrondit line_size au premier multiple de x_pos supérieur
+                // On arrondit line_size au premier multiple de x_pos supÃ©rieur
                 if (line_size % x_pos)
                   line_size=((line_size/x_pos)*x_pos)+x_pos;
                 // On convertit cette taille en octets
@@ -1236,7 +1244,7 @@
                         x_pos+=a;
                         y_pos-=b;
                         break;
-                      default: // Nouvelle série
+                      default: // Nouvelle sÃ©rie
                         while (b)
                         {
                           if(Read_byte(file, &a)!=1)
@@ -1295,7 +1303,7 @@
                         x_pos+=a;
                         y_pos-=b;
                         break;
-                      default: // Nouvelle série (B 1/2 pixels bruts)
+                      default: // Nouvelle sÃ©rie (B 1/2 pixels bruts)
                         for (index=1; ((index<=b) && (!File_error)); index++,x_pos++)
                         {
                           if (index&1)
@@ -1307,7 +1315,7 @@
                             Set_pixel(context, x_pos,y_pos,c&0xF);
                         }
                         //   On lit l'octet rendant le nombre d'octets pair, si
-                        // nécessaire. Encore un truc de crétin "made in MS".
+                        // nÃ©cessaire. Encore un truc de crÃ©tin "made in MS".
                         if ( ((b&3)==1) || ((b&3)==2) )
                         {
                           byte dummy;
@@ -1502,11 +1510,11 @@
      && Write_dword_le(file,header.Clr_Imprt))
     {
       //   Chez Bill, ils ont dit: "On va mettre les couleur dans l'ordre
-      // inverse, et pour faire chier, on va les mettre sur une échelle de
-      // 0 à 255 parce que le standard VGA c'est de 0 à 63 (logique!). Et
-      // puis comme c'est pas assez débile, on va aussi y rajouter un octet
-      // toujours à 0 pour forcer les gens à s'acheter des gros disques
-      // durs... Comme ça, ça fera passer la pillule lorsqu'on sortira
+      // inverse, et pour faire chier, on va les mettre sur une Ã©chelle de
+      // 0 Ã  255 parce que le standard VGA c'est de 0 Ã  63 (logique!). Et
+      // puis comme c'est pas assez dÃ©bile, on va aussi y rajouter un octet
+      // toujours Ã  0 pour forcer les gens Ã  s'acheter des gros disques
+      // durs... Comme Ã§a, Ã§a fera passer la pillule lorsqu'on sortira
       // Windows 95." ...
       for (index=0; index<256; index++)
       {
@@ -1521,7 +1529,7 @@
         Init_write_buffer();
 
         // ... Et Bill, il a dit: "OK les gars! Mais seulement si vous rangez
-        // les pixels dans l'ordre inverse, mais que sur les Y quand-même
+        // les pixels dans l'ordre inverse, mais que sur les Y quand-mÃªme
         // parce que faut pas pousser."
         for (y_pos=context->Height-1; ((y_pos>=0) && (!File_error)); y_pos--)
           for (x_pos=0; x_pos<line_size; x_pos++)
@@ -1617,20 +1625,20 @@
 // -- Lire un fichier au format GIF -----------------------------------------
 // -- Lire un fichier au format GIF -----------------------------------------
 
-// Définition de quelques variables globales au chargement du GIF87a
+// DÃ©finition de quelques variables globales au chargement du GIF87a
 word GIF_nb_bits;        // Nb de bits composants un code complet
 word GIF_remainder_bits;      // Nb de bits encore dispos dans GIF_last_byte
 byte GIF_remainder_byte;      // Nb d'octets avant le prochain bloc de Raster Data
-word GIF_current_code;    // Code traité (qui vient d'être lu en général)
+word GIF_current_code;    // Code traitÃ© (qui vient d'Ãªtre lu en gÃ©nÃ©ral)
 byte GIF_last_byte;      // Octet de lecture des bits
-word GIF_pos_X;          // Coordonnées d'affichage de l'image
+word GIF_pos_X;          // CoordonnÃ©es d'affichage de l'image
 word GIF_pos_Y;
-word GIF_interlaced;     // L'image est entrelacée
-word GIF_finished_interlaced_image; // L'image entrelacée est finie de charger
-word GIF_pass;          // index de passe de l'image entrelacée
+word GIF_interlaced;     // L'image est entrelacÃ©e
+word GIF_finished_interlaced_image; // L'image entrelacÃ©e est finie de charger
+word GIF_pass;          // index de passe de l'image entrelacÃ©e
 FILE *GIF_file;        // L'handle du fichier
 
-// -- Lit le code à GIF_nb_bits suivant --
+// -- Lit le code Ã  GIF_nb_bits suivant --
 
 word GIF_get_next_code(void)
 {
@@ -1720,12 +1728,12 @@
   char filename[MAX_PATH_CHARACTERS];
   char signature[6];
 
-  word * alphabet_stack;     // Pile de décodage d'une chaîne
-  word * alphabet_prefix;  // Table des préfixes des codes
+  word * alphabet_stack;     // Pile de dÃ©codage d'une chaÃ®ne
+  word * alphabet_prefix;  // Table des prÃ©fixes des codes
   word * alphabet_suffix;  // Table des suffixes des codes
   word   alphabet_free;     // Position libre dans l'alphabet
-  word   alphabet_max;      // Nombre d'entrées possibles dans l'alphabet
-  word   alphabet_stack_pos; // Position dans la pile de décodage d'un chaîne
+  word   alphabet_max;      // Nombre d'entrÃ©es possibles dans l'alphabet
+  word   alphabet_stack_pos; // Position dans la pile de dÃ©codage d'un chaÃ®ne
 
   T_GIF_LSDB LSDB;
   T_GIF_IDB IDB;
@@ -1733,16 +1741,16 @@
 
   word nb_colors;       // Nombre de couleurs dans l'image
   word color_index; // index de traitement d'une couleur
-  byte size_to_read; // Nombre de données à lire      (divers)
+  byte size_to_read; // Nombre de donnÃ©es Ã  lire      (divers)
   byte block_identifier;  // Code indicateur du type de bloc en cours
-  word initial_nb_bits;   // Nb de bits au début du traitement LZW
-  word special_case=0;       // Mémoire pour le cas spécial
-  word old_code=0;       // Code précédent
+  word initial_nb_bits;   // Nb de bits au dÃ©but du traitement LZW
+  word special_case=0;       // MÃ©moire pour le cas spÃ©cial
+  word old_code=0;       // Code prÃ©cÃ©dent
   word byte_read;         // Sauvegarde du code en cours de lecture
   word value_clr;        // Valeur <=> Clear tables
   word value_eof;        // Valeur <=> End d'image
   long file_size;
-  int number_LID; // Nombre d'images trouvées dans le fichier
+  int number_LID; // Nombre d'images trouvÃ©es dans le fichier
   short current_layer = 0;
 
   /////////////////////////////////////////////////// FIN DES DECLARATIONS //
@@ -1760,7 +1768,7 @@
            (memcmp(signature,"GIF89a",6)==0) ) )
     {
 
-      // Allocation de mémoire pour les tables & piles de traitement:
+      // Allocation de mÃ©moire pour les tables & piles de traitement:
       alphabet_stack   =(word *)malloc(4096*sizeof(word));
       alphabet_prefix=(word *)malloc(4096*sizeof(word));
       alphabet_suffix=(word *)malloc(4096*sizeof(word));
@@ -1772,7 +1780,7 @@
       && Read_byte(GIF_file,&(LSDB.Aspect))
         )
       {
-        // Lecture du Logical Screen Descriptor Block réussie:
+        // Lecture du Logical Screen Descriptor Block rÃ©ussie:
 
         Original_screen_X=LSDB.Width;
         Original_screen_Y=LSDB.Height;
@@ -1807,7 +1815,7 @@
             }
           else
           {
-            // Palette triée par composantes:
+            // Palette triÃ©e par composantes:
             for (color_index=0;color_index<nb_colors;color_index++)
               Read_byte(GIF_file,&(context->Palette[color_index].R));
             for (color_index=0;color_index<nb_colors;color_index++)
@@ -1835,7 +1843,7 @@
                 switch(function_code)
                 {
                   case 0xFE: // Comment Block Extension
-                    // On récupère le premier commentaire non-vide, 
+                    // On rÃ©cupÃ¨re le premier commentaire non-vide, 
                     // on jette les autres.
                     if (context->Comment[0]=='\0')
                     {
@@ -1850,7 +1858,7 @@
                     }
                     break;
                   case 0xF9: // Graphics Control Extension
-                    // Prévu pour la transparence
+                    // PrÃ©vu pour la transparence
                     if ( Read_byte(GIF_file,&(GCE.Packed_fields))
                       && Read_word_le(GIF_file,&(GCE.Delay_time))
                       && Read_byte(GIF_file,&(GCE.Transparent_color)))
@@ -1885,7 +1893,7 @@
             break;
             case 0x2C: // Local Image Descriptor
             {
-              // Si on a deja lu une image, c'est une GIF animée ou bizarroide, on sort.
+              // Si on a deja lu une image, c'est une GIF animÃ©e ou bizarroide, on sort.
               if (number_LID!=0)
               {
                 // This a second layer/frame, or more.
@@ -1906,7 +1914,7 @@
               {
     
                 // Palette locale dispo = (IDB.Indicator and $80)
-                // Image entrelacée     = (IDB.Indicator and $40)
+                // Image entrelacÃ©e     = (IDB.Indicator and $40)
                 // Ordre de classement  = (IDB.Indicator and $20)
                 // Nombre de bits/pixel = (IDB.Indicator and $07)+1 (si palette locale dispo)
     
@@ -1927,7 +1935,7 @@
                     }
                   else
                   {
-                    // Palette triée par composantes:
+                    // Palette triÃ©e par composantes:
                     for (color_index=0;color_index<nb_colors;color_index++)
                       Read_byte(GIF_file,&(context->Palette[color_index].R));
                     for (color_index=0;color_index<nb_colors;color_index++)
@@ -1995,7 +2003,7 @@
                           alphabet_max      =((1 << (++GIF_nb_bits))-1);
                       }
                     }
-                    else // Code Clear rencontré
+                    else // Code Clear rencontrÃ©
                     {
                       GIF_nb_bits       =initial_nb_bits;
                       alphabet_max      =((1 <<  GIF_nb_bits)-1);
@@ -2007,7 +2015,7 @@
                   }
                   else
                     File_error=2;
-                } // Code End-Of-Information ou erreur de fichier rencontré
+                } // Code End-Of-Information ou erreur de fichier rencontrÃ©
     
                 /*Close_lecture();*/
     
@@ -2031,7 +2039,7 @@
       else
         File_error=1;
 
-      // Libération de la mémoire utilisée par les tables & piles de traitement:
+      // LibÃ©ration de la mÃ©moire utilisÃ©e par les tables & piles de traitement:
       free(alphabet_suffix);
       free(alphabet_prefix);
       free(alphabet_stack);
@@ -2042,7 +2050,7 @@
 
     fclose(GIF_file);
 
-  } // Le fichier était ouvrable
+  } // Le fichier Ã©tait ouvrable
   else
     File_error=1;
 }
@@ -2050,8 +2058,8 @@
 
 // -- Sauver un fichier au format GIF ---------------------------------------
 
-  int  GIF_stop;         // "On peut arrêter la sauvegarde du fichier"
-  byte GIF_buffer[256];   // buffer d'écriture de bloc de données compilées
+  int  GIF_stop;         // "On peut arrÃªter la sauvegarde du fichier"
+  byte GIF_buffer[256];   // buffer d'Ã©criture de bloc de donnÃ©es compilÃ©es
 
   // -- Vider le buffer GIF dans le buffer KM --
 
@@ -2070,7 +2078,7 @@
     }
   }
 
-  // -- Ecrit un code à GIF_nb_bits --
+  // -- Ecrit un code Ã  GIF_nb_bits --
 
   void GIF_set_code(word Code)
   {
@@ -2088,9 +2096,9 @@
       nb_bits_processed  +=current_nb_bits;
       nb_bits_to_process-=current_nb_bits;
 
-      if (GIF_remainder_bits==8) // Il ne reste plus de bits à coder sur l'octet courant
+      if (GIF_remainder_bits==8) // Il ne reste plus de bits Ã  coder sur l'octet courant
       {
-        // Ecrire l'octet à balancer:
+        // Ecrire l'octet Ã  balancer:
         GIF_buffer[++GIF_remainder_byte]=GIF_last_byte;
 
         // Si on a atteint la fin du bloc de Raster Data
@@ -2129,23 +2137,23 @@
 {
   char filename[MAX_PATH_CHARACTERS];
 
-  word * alphabet_prefix;  // Table des préfixes des codes
+  word * alphabet_prefix;  // Table des prÃ©fixes des codes
   word * alphabet_suffix;  // Table des suffixes des codes
-  word * alphabet_daughter;    // Table des chaînes filles (plus longues)
-  word * alphabet_sister;    // Table des chaînes soeurs (même longueur)
+  word * alphabet_daughter;    // Table des chaÃ®nes filles (plus longues)
+  word * alphabet_sister;    // Table des chaÃ®nes soeurs (mÃªme longueur)
   word   alphabet_free;     // Position libre dans l'alphabet
-  word   alphabet_max;      // Nombre d'entrées possibles dans l'alphabet
-  word   start;            // Code précédent (sert au linkage des chaînes)
-  int    descend;          // Booléen "On vient de descendre"
+  word   alphabet_max;      // Nombre d'entrÃ©es possibles dans l'alphabet
+  word   start;            // Code prÃ©cÃ©dent (sert au linkage des chaÃ®nes)
+  int    descend;          // BoolÃ©en "On vient de descendre"
 
   T_GIF_LSDB LSDB;
   T_GIF_IDB IDB;
 
 
   byte block_identifier;  // Code indicateur du type de bloc en cours
-  word current_string;   // Code de la chaîne en cours de traitement
-  byte current_char;         // Caractère à coder
-  word index;            // index de recherche de chaîne
+  word current_string;   // Code de la chaÃ®ne en cours de traitement
+  byte current_char;         // CaractÃ¨re Ã  coder
+  word index;            // index de recherche de chaÃ®ne
   short current_layer;
 
   /////////////////////////////////////////////////// FIN DES DECLARATIONS //
@@ -2156,12 +2164,12 @@
 
   if ((GIF_file=fopen(filename,"wb")))
   {
-    // On écrit la signature du fichier
+    // On Ã©crit la signature du fichier
     if (Write_bytes(GIF_file,"GIF89a",6))
     {
-      // La signature du fichier a été correctement écrite.
+      // La signature du fichier a Ã©tÃ© correctement Ã©crite.
 
-      // Allocation de mémoire pour les tables
+      // Allocation de mÃ©moire pour les tables
       alphabet_prefix=(word *)malloc(4096*sizeof(word));
       alphabet_suffix=(word *)malloc(4096*sizeof(word));
       alphabet_daughter  =(word *)malloc(4096*sizeof(word));
@@ -2190,14 +2198,14 @@
           Write_byte(GIF_file,LSDB.Backcol) &&
           Write_byte(GIF_file,LSDB.Aspect) )
       {
-        // Le LSDB a été correctement écrit.
+        // Le LSDB a Ã©tÃ© correctement Ã©crit.
 
         // On sauve la palette
         if (Write_bytes(GIF_file,context->Palette,768))
         {
-          // La palette a été correctement écrite.
+          // La palette a Ã©tÃ© correctement Ã©crite.
 
-          //   Le jour où on se servira des blocks d'extensions pour placer
+          //   Le jour oÃ¹ on se servira des blocks d'extensions pour placer
           // des commentaires, on le fera ici.
 
           // Ecriture de la transparence
@@ -2242,13 +2250,13 @@
             if (Write_bytes(GIF_file,GCE_block,8))
             {
             
-              // On va écrire un block indicateur d'IDB et l'IDB du fichier
+              // On va Ã©crire un block indicateur d'IDB et l'IDB du fichier
               block_identifier=0x2C;
               IDB.Pos_X=0;
               IDB.Pos_Y=0;
               IDB.Image_width=context->Width;
               IDB.Image_height=context->Height;
-              IDB.Indicator=0x07;    // Image non entrelacée, pas de palette locale.
+              IDB.Indicator=0x07;    // Image non entrelacÃ©e, pas de palette locale.
               IDB.Nb_bits_pixel=8; // Image 256 couleurs;
     
               if ( Write_byte(GIF_file,block_identifier) &&
@@ -2259,8 +2267,8 @@
                    Write_byte(GIF_file,IDB.Indicator) &&
                    Write_byte(GIF_file,IDB.Nb_bits_pixel))
               {
-                //   Le block indicateur d'IDB et l'IDB ont étés correctements
-                // écrits.
+                //   Le block indicateur d'IDB et l'IDB ont Ã©tÃ©s correctements
+                // Ã©crits.
     
                 Init_write_buffer();
                 GIF_pos_X=0;
@@ -2273,7 +2281,7 @@
                 File_error=0;
                 GIF_stop=0;
     
-                // Réintialisation de la table:
+                // RÃ©intialisation de la table:
                 alphabet_free=258;
                 GIF_nb_bits  =9;
                 alphabet_max =511;
@@ -2293,8 +2301,8 @@
                 {
                   current_char=GIF_next_pixel(context, &IDB);
     
-                  //   On regarde si dans la table on aurait pas une chaîne
-                  // équivalente à current_string+Caractere
+                  //   On regarde si dans la table on aurait pas une chaÃ®ne
+                  // Ã©quivalente Ã  current_string+Caractere
     
                   while ( (index<alphabet_free) &&
                           ( (current_string!=alphabet_prefix[index]) ||
@@ -2322,16 +2330,16 @@
                     else
                       alphabet_sister[start]=alphabet_free;
     
-                    // On rajoute la chaîne current_string+Caractere à la table
+                    // On rajoute la chaÃ®ne current_string+Caractere Ã  la table
                     alphabet_prefix[alphabet_free  ]=current_string;
                     alphabet_suffix[alphabet_free++]=current_char;
     
-                    // On écrit le code dans le fichier
+                    // On Ã©crit le code dans le fichier
                     GIF_set_code(current_string);
     
                     if (alphabet_free>0xFFF)
                     {
-                      // Réintialisation de la table:
+                      // RÃ©intialisation de la table:
                       GIF_set_code(256);
                       alphabet_free=258;
                       GIF_nb_bits  =9;
@@ -2360,21 +2368,21 @@
     
                 if (!File_error)
                 {
-                  // On écrit le code dans le fichier
-                  GIF_set_code(current_string); // Dernière portion d'image
+                  // On Ã©crit le code dans le fichier
+                  GIF_set_code(current_string); // DerniÃ¨re portion d'image
     
-                  //   Cette dernière portion ne devrait pas poser de problèmes
-                  // du côté GIF_nb_bits puisque pour que GIF_nb_bits change de
-                  // valeur, il faudrait que la table de chaîne soit remplie or
-                  // c'est impossible puisqu'on traite une chaîne qui se trouve
-                  // déjà dans la table, et qu'elle n'a rien d'inédit. Donc on
-                  // ne devrait pas avoir à changer de taille, mais je laisse
-                  // quand même en remarque tout ça, au cas où il subsisterait
-                  // des problèmes dans certains cas exceptionnels.
+                  //   Cette derniÃ¨re portion ne devrait pas poser de problÃ¨mes
+                  // du cÃ´tÃ© GIF_nb_bits puisque pour que GIF_nb_bits change de
+                  // valeur, il faudrait que la table de chaÃ®ne soit remplie or
+                  // c'est impossible puisqu'on traite une chaÃ®ne qui se trouve
+                  // dÃ©jÃ  dans la table, et qu'elle n'a rien d'inÃ©dit. Donc on
+                  // ne devrait pas avoir Ã  changer de taille, mais je laisse
+                  // quand mÃªme en remarque tout Ã§a, au cas oÃ¹ il subsisterait
+                  // des problÃ¨mes dans certains cas exceptionnels.
                   //
-                  // Note: de toutes façons, ces lignes en commentaires ont étés
-                  //      écrites par copier/coller du temps où la sauvegarde du
-                  //      GIF déconnait. Il y a donc fort à parier qu'elles ne
+                  // Note: de toutes faÃ§ons, ces lignes en commentaires ont Ã©tÃ©s
+                  //      Ã©crites par copier/coller du temps oÃ¹ la sauvegarde du
+                  //      GIF dÃ©connait. Il y a donc fort Ã  parier qu'elles ne
                   //      sont pas correctes.
     
                   /*
@@ -2385,7 +2393,7 @@
                       // On balargue un Clear Code
                       GIF_set_code(256);
     
-                      // On réinitialise les données LZW
+                      // On rÃ©initialise les donnÃ©es LZW
                       alphabet_free=258;
                       GIF_nb_bits  =9;
                       alphabet_max =511;
@@ -2400,17 +2408,17 @@
     
                   GIF_set_code(257);             // Code de End d'image
                   if (GIF_remainder_bits!=0)
-                    GIF_set_code(0);             // Code bidon permettant de s'assurer que tous les bits du dernier code aient bien étés inscris dans le buffer GIF
-                  GIF_empty_buffer();         // On envoie les dernières données du buffer GIF dans le buffer KM
-                  End_write(GIF_file);   // On envoie les dernières données du buffer KM  dans le fichier
+                    GIF_set_code(0);             // Code bidon permettant de s'assurer que tous les bits du dernier code aient bien Ã©tÃ©s inscris dans le buffer GIF
+                  GIF_empty_buffer();         // On envoie les derniÃ¨res donnÃ©es du buffer GIF dans le buffer KM
+                  End_write(GIF_file);   // On envoie les derniÃ¨res donnÃ©es du buffer KM  dans le fichier
     
-                  // On écrit un \0
+                  // On Ã©crit un \0
                   if (! Write_byte(GIF_file,'\x00'))
                     File_error=1;
                   
                   }
       
-                } // On a pu écrire l'IDB
+                } // On a pu Ã©crire l'IDB
               else
                 File_error=1;
             }
@@ -2421,26 +2429,26 @@
           // After writing all layers
           if (!File_error)
           {
-            // On écrit un GIF TERMINATOR, exigé par SVGA et SEA.
+            // On Ã©crit un GIF TERMINATOR, exigÃ© par SVGA et SEA.
             if (! Write_byte(GIF_file,'\x3B'))
               File_error=1;
           }
 
-        } // On a pu écrire la palette
+        } // On a pu Ã©crire la palette
         else
           File_error=1;
 
-      } // On a pu écrire le LSDB
+      } // On a pu Ã©crire le LSDB
       else
         File_error=1;
 
-      // Libération de la mémoire utilisée par les tables
+      // LibÃ©ration de la mÃ©moire utilisÃ©e par les tables
       free(alphabet_sister);
       free(alphabet_daughter);
       free(alphabet_suffix);
       free(alphabet_prefix);
 
-    } // On a pu écrire la signature du fichier
+    } // On a pu Ã©crire la signature du fichier
     else
       File_error=1;
 
@@ -2448,7 +2456,7 @@
     if (File_error)
       remove(filename);
 
-  } // On a pu ouvrir le fichier en écriture
+  } // On a pu ouvrir le fichier en Ã©criture
   else
     File_error=1;
 
@@ -2462,21 +2470,21 @@
   {
     byte Manufacturer;       // |_ Il font chier ces cons! Ils auraient pu
     byte Version;            // |  mettre une vraie signature!
-    byte Compression;        // L'image est-elle compressée?
+    byte Compression;        // L'image est-elle compressÃ©e?
     byte Depth;              // Nombre de bits pour coder un pixel (inutile puisqu'on se sert de Plane)
     word X_min;              // |_ Coin haut-gauche   |
-    word Y_min;              // |  de l'image         |_ (Crétin!)
+    word Y_min;              // |  de l'image         |_ (CrÃ©tin!)
     word X_max;              // |_ Coin bas-droit     |
     word Y_max;              // |  de l'image         |
-    word X_dpi;              // |_ Densité de |_ (Presque inutile parce que
+    word X_dpi;              // |_ DensitÃ© de |_ (Presque inutile parce que
     word Y_dpi;              // |  l'image    |  aucun moniteur n'est pareil!)
-    byte Palette_16c[48];    // Palette 16 coul (inutile pour 256c) (débile!)
-    byte Reserved;           // Ca me plait ça aussi!
+    byte Palette_16c[48];    // Palette 16 coul (inutile pour 256c) (dÃ©bile!)
+    byte Reserved;           // Ca me plait Ã§a aussi!
     byte Plane;              // 4 => 16c , 1 => 256c , ...
-    word Bytes_per_plane_line;// Doit toujours être pair
-    word Palette_info;       // 1 => color , 2 => Gris (ignoré à partir de la version 4)
+    word Bytes_per_plane_line;// Doit toujours Ãªtre pair
+    word Palette_info;       // 1 => color , 2 => Gris (ignorÃ© Ã  partir de la version 4)
     word Screen_X;           // |_ Dimensions de
-    word Screen_Y;           // |  l'écran d'origine
+    word Screen_Y;           // |  l'Ã©cran d'origine
     byte Filler[54];         // Ca... J'adore!
   } T_PCX_Header;
 #pragma pack()
@@ -2516,7 +2524,7 @@
     {
     
       //   Vu que ce header a une signature de merde et peu significative, il
-      // va falloir que je teste différentes petites valeurs dont je connais
+      // va falloir que je teste diffÃ©rentes petites valeurs dont je connais
       // l'intervalle. Grrr!
       if ( (PCX_header.Manufacturer!=10)
         || (PCX_header.Compression>1)
@@ -2537,7 +2545,7 @@
 
 // -- Lire un fichier au format PCX -----------------------------------------
 
-  // -- Afficher une ligne PCX codée sur 1 seul plan avec moins de 256 c. --
+  // -- Afficher une ligne PCX codÃ©e sur 1 seul plan avec moins de 256 c. --
   void Draw_PCX_line(T_IO_Context *context, short y_pos, byte depth)
   {
     short x_pos;
@@ -2559,7 +2567,7 @@
   FILE *file;
   
   short line_size;
-  short real_line_size; // width de l'image corrigée
+  short real_line_size; // width de l'image corrigÃ©e
   short width_read;
   short x_pos;
   short y_pos;
@@ -2612,7 +2620,7 @@
         Pre_load(context, context->Width,context->Height,file_size,FORMAT_PCX,PIXEL_SIMPLE,0);
         if (File_error==0)
         {
-          // On prépare la palette à accueillir les valeurs du fichier PCX
+          // On prÃ©pare la palette Ã  accueillir les valeurs du fichier PCX
           if (Config.Clear_palette)
             memset(context->Palette,0,sizeof(T_Palette));
           nb_colors=(dword)(1<<PCX_header.Plane)<<(PCX_header.Depth-1);
@@ -2626,7 +2634,7 @@
             context->Palette[1].B=0;
             byte1=PCX_header.Palette_16c[3]>>5;
             if (nb_colors==4)
-            { // Pal. CGA "alakon" (du Turc Allahkoum qui signifie "à la con" :))
+            { // Pal. CGA "alakon" (du Turc Allahkoum qui signifie "Ã  la con" :))
               memcpy(context->Palette+1,palette_CGA,9);
               if (!(byte1&2))
               {
@@ -2643,17 +2651,17 @@
             }
           }
 
-          //   On se positionne à la fin du fichier - 769 octets pour voir s'il y
+          //   On se positionne Ã  la fin du fichier - 769 octets pour voir s'il y
           // a une palette.
           if ( (PCX_header.Depth==8) && (PCX_header.Version>=5) && (file_size>(256*3)) )
           {
             fseek(file,file_size-((256*3)+1),SEEK_SET);
-            // On regarde s'il y a une palette après les données de l'image
+            // On regarde s'il y a une palette aprÃ¨s les donnÃ©es de l'image
             if (Read_byte(file,&byte1))
               if (byte1==12) // Lire la palette si c'est une image en 256 couleurs
               {
                 int index;
-                // On lit la palette 256c que ces crétins ont foutue à la fin du fichier
+                // On lit la palette 256c que ces crÃ©tins ont foutue Ã  la fin du fichier
                 for(index=0;index<256;index++)
                   if ( ! Read_byte(file,&(context->Palette[index].R))
                    || ! Read_byte(file,&(context->Palette[index].G))
@@ -2667,21 +2675,21 @@
           }
           Palette_loaded(context);
 
-          //   Maintenant qu'on a lu la palette que ces crétins sont allés foutre
-          // à la fin, on retourne juste après le header pour lire l'image.
+          //   Maintenant qu'on a lu la palette que ces crÃ©tins sont allÃ©s foutre
+          // Ã  la fin, on retourne juste aprÃ¨s le header pour lire l'image.
           fseek(file,128,SEEK_SET);
           if (!File_error)
           {
             line_size=PCX_header.Bytes_per_plane_line*PCX_header.Plane;
             real_line_size=(short)PCX_header.Bytes_per_plane_line<<3;
-            //   On se sert de données LBM car le dessin de ligne en moins de 256
+            //   On se sert de donnÃ©es LBM car le dessin de ligne en moins de 256
             // couleurs se fait comme avec la structure ILBM.
             Image_HAM=0;
             HBPm1=PCX_header.Plane-1;
             LBM_buffer=(byte *)malloc(line_size);
 
             // Chargement de l'image
-            if (PCX_header.Compression)  // Image compressée
+            if (PCX_header.Compression)  // Image compressÃ©e
             {
               /*Init_lecture();*/
   
@@ -2691,14 +2699,14 @@
               {
                 for (position=0; ((position<image_size) && (!File_error));)
                 {
-                  // Lecture et décompression de la ligne
+                  // Lecture et dÃ©compression de la ligne
                   if(Read_byte(file,&byte1) !=1) File_error=2;
                   if (!File_error)
                   {
                     if ((byte1&0xC0)==0xC0)
                     {
-                      byte1-=0xC0;               // facteur de répétition
-                      if(Read_byte(file,&byte2)!=1) File_error = 2; // octet à répéter
+                      byte1-=0xC0;               // facteur de rÃ©pÃ©tition
+                      if(Read_byte(file,&byte2)!=1) File_error = 2; // octet Ã  rÃ©pÃ©ter
                       if (!File_error)
                       {
                         for (index=0; index<byte1; index++,position++)
@@ -2720,7 +2728,7 @@
                   }
                 }
               }
-              else                 // couleurs rangées par plans
+              else                 // couleurs rangÃ©es par plans
               {
                 for (y_pos=0; ((y_pos<context->Height) && (!File_error)); y_pos++)
                 {
@@ -2731,8 +2739,8 @@
                     {
                       if ((byte1&0xC0)==0xC0)
                       {
-                        byte1-=0xC0;               // facteur de répétition
-                        if(Read_byte(file,&byte2)!=1) File_error=2; // octet à répéter
+                        byte1-=0xC0;               // facteur de rÃ©pÃ©tition
+                        if(Read_byte(file,&byte2)!=1) File_error=2; // octet Ã  rÃ©pÃ©ter
                         if (!File_error)
                         {
                           for (index=0; index<byte1; index++)
@@ -2758,7 +2766,7 @@
 
               /*Close_lecture();*/
             }
-            else                     // Image non compressée
+            else                     // Image non compressÃ©e
             {
               for (y_pos=0;(y_pos<context->Height) && (!File_error);y_pos++)
               {
@@ -2815,14 +2823,14 @@
 
             for (y_pos=0,position=0;(y_pos<context->Height) && (!File_error);)
             {
-              // Lecture et décompression de la ligne
+              // Lecture et dÃ©compression de la ligne
               if(Read_byte(file,&byte1)!=1) File_error=2;
               if (!File_error)
               {
                 if ((byte1 & 0xC0)==0xC0)
                 {
-                  byte1-=0xC0;               // facteur de répétition
-                  if(Read_byte(file,&byte2)!=1) File_error=2; // octet à répéter
+                  byte1-=0xC0;               // facteur de rÃ©pÃ©tition
+                  if(Read_byte(file,&byte2)!=1) File_error=2; // octet Ã  rÃ©pÃ©ter
                   if (!File_error)
                   {
                     for (index=0; (index<byte1) && (!File_error); index++)
@@ -2942,7 +2950,7 @@
       {
         pixel_read=Get_pixel(context, 0,y_pos);
      
-        // Compression et écriture de la ligne
+        // Compression et Ã©criture de la ligne
         for (x_pos=0; ((x_pos<line_size) && (!File_error)); )
         {
           x_pos++;
@@ -3016,7 +3024,7 @@
   // Ouverture du fichier
   if ((file=fopen(filename, "rb")))
   {
-    // Lecture et vérification de la signature
+    // Lecture et vÃ©rification de la signature
     if (Read_bytes(file,SCx_header.Filler1,sizeof(SCx_header.Filler1))
     && Read_word_le(file, &(SCx_header.Width))
     && Read_word_le(file, &(SCx_header.Height))
@@ -3194,7 +3202,7 @@
       if (File_error)
         remove(filename);
     }
-    else // Error d'écriture (disque plein ou protégé)
+    else // Error d'Ã©criture (disque plein ou protÃ©gÃ©)
     {
       fclose(file);
       remove(filename);
@@ -3647,7 +3655,7 @@
     fclose(file);
   }
 
-  //   S'il y a eu une erreur de sauvegarde, on ne va tout de même pas laisser
+  //   S'il y a eu une erreur de sauvegarde, on ne va tout de mÃªme pas laisser
   // ce fichier pourri trainait... Ca fait pas propre.
   if (File_error)
     remove(filename);
diff -ruN gfx2orig/src/filesel.c grafx2/src/filesel.c
--- gfx2orig/src/filesel.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/filesel.c	2022-03-20 20:19:34.112495316 -0500
@@ -44,6 +44,10 @@
     #define isHidden(x) ((x)->d_name[0]=='.')
 #endif
 
+#if defined(FDOS)
+    #include <limits.h> // PATH_MAX
+#endif
+
 #include "const.h"
 #include "struct.h"
 #include "global.h"
@@ -60,12 +64,12 @@
 #include "help.h"
 #include "filesel.h"
 
-#define NORMAL_FILE_COLOR    MC_Light // color du texte pour une ligne de fichier non sélectionné
-#define NORMAL_DIRECTORY_COLOR MC_Dark // color du texte pour une ligne de répertoire non sélectionné
-#define NORMAL_BACKGROUND_COLOR       MC_Black  // color du fond  pour une ligne non sélectionnée
-#define SELECTED_FILE_COLOR    MC_White // color du texte pour une ligne de fichier    sélectionnée
-#define SELECTED_DIRECTORY_COLOR MC_Light // color du texte pour une ligne de repértoire sélectionnée
-#define SELECTED_BACKGROUND_COLOR       MC_Dark // color du fond  pour une ligne sélectionnée
+#define NORMAL_FILE_COLOR    MC_Light // color du texte pour une ligne de fichier non sÃ©lectionnÃ©
+#define NORMAL_DIRECTORY_COLOR MC_Dark // color du texte pour une ligne de rÃ©pertoire non sÃ©lectionnÃ©
+#define NORMAL_BACKGROUND_COLOR       MC_Black  // color du fond  pour une ligne non sÃ©lectionnÃ©e
+#define SELECTED_FILE_COLOR    MC_White // color du texte pour une ligne de fichier    sÃ©lectionnÃ©e
+#define SELECTED_DIRECTORY_COLOR MC_Light // color du texte pour une ligne de repÃ©rtoire sÃ©lectionnÃ©e
+#define SELECTED_BACKGROUND_COLOR       MC_Dark // color du fond  pour une ligne sÃ©lectionnÃ©e
 
 // -- Fileselector data
 
@@ -78,8 +82,8 @@
 
 // Conventions:
 //
-// * Le fileselect modifie le répertoire courant. Ceci permet de n'avoir
-//   qu'un findfirst dans le répertoire courant à faire:
+// * Le fileselect modifie le rÃ©pertoire courant. Ceci permet de n'avoir
+//   qu'un findfirst dans le rÃ©pertoire courant Ã  faire:
 
 void Recount_files(T_Fileselector *list)
 {
@@ -122,9 +126,9 @@
   }
 }
 
-// -- Destruction de la liste chaînée ---------------------------------------
+// -- Destruction de la liste chaÃ®nÃ©e ---------------------------------------
 void Free_fileselector_list(T_Fileselector *list)
-//  Cette procédure détruit la chaine des fichiers. Elle doit être appelée
+//  Cette procÃ©dure dÃ©truit la chaine des fichiers. Elle doit Ãªtre appelÃ©e
 // avant de rappeler la fonction Read_list_of_files, ainsi qu'en fin de
 // programme.
 {
@@ -133,11 +137,11 @@
 
   while (list->First!=NULL)
   {
-    // On mémorise l'adresse du premier élément de la liste
+    // On mÃ©morise l'adresse du premier Ã©lÃ©ment de la liste
     temp_item =list->First;
-    // On fait avancer la tête de la liste
+    // On fait avancer la tÃªte de la liste
     list->First=list->First->Next;
-    // Et on efface l'ancien premier élément de la liste
+    // Et on efface l'ancien premier Ã©lÃ©ment de la liste
     free(temp_item);
     temp_item = NULL;
   }
@@ -185,7 +189,7 @@
       result[c]=fname[c];
     }
 
-    // Ensuite on recopie la partie qui suit le point (si nécessaire):
+    // Ensuite on recopie la partie qui suit le point (si nÃ©cessaire):
     if (pos_last_dot != -1)
     {
       for (c = pos_last_dot+1,other_cursor=15;fname[c]!='\0' && other_cursor < 18;c++,other_cursor++)
@@ -198,7 +202,7 @@
 
 // -- Rajouter a la liste des elements de la liste un element ---------------
 void Add_element_to_list(T_Fileselector *list, const char * fname, int type)
-//  Cette procedure ajoute a la liste chainee un fichier passé en argument.
+//  Cette procedure ajoute a la liste chainee un fichier passÃ© en argument.
 {
   // Pointeur temporaire d'insertion
   T_Fileselector_item * temp_item;
@@ -238,7 +242,7 @@
   if (pos_last_dot == -1)
     return (filter[0] == '\0' || filter[0] == ';');
 
-  // Vérification caractère par caractère, case-insensitive.
+  // VÃ©rification caractÃ¨re par caractÃ¨re, case-insensitive.
   c = 0;
   while (1)
   {
@@ -256,47 +260,57 @@
 
 // -- Lecture d'une liste de fichiers ---------------------------------------
 void Read_list_of_files(T_Fileselector *list, byte selected_format)
-//  Cette procédure charge dans la liste chainée les fichiers dont l'extension
-// correspond au format demandé.
+//  Cette procÃ©dure charge dans la liste chainÃ©e les fichiers dont l'extension
+// correspond au format demandÃ©.
 {
-  DIR*  current_directory; //Répertoire courant
-  struct dirent* entry; // Structure de lecture des éléments
-  char * filter = "*"; // Extension demandée
+  DIR*  current_directory; //RÃ©pertoire courant
+  struct dirent* entry; // Structure de lecture des Ã©lÃ©ments
+  char * filter = "*"; // Extension demandÃ©e
   struct stat Infos_enreg;
   char * current_path;
+#if defined(FDOS)
+  char* bufr = malloc(PATH_MAX);
+  if (!bufr) {
+      return;
+  }
+#endif
 
-  // Tout d'abord, on déduit du format demandé un filtre à utiliser:
+  // Tout d'abord, on dÃ©duit du format demandÃ© un filtre Ã  utiliser:
   filter = Get_fileformat(selected_format)->Extensions;
 
   // Ensuite, on vide la liste actuelle:
   Free_fileselector_list(list);
-  // Après effacement, il ne reste ni fichier ni répertoire dans la liste
+  // AprÃ¨s effacement, il ne reste ni fichier ni rÃ©pertoire dans la liste
 
-  // On lit tous les répertoires:
+  // On lit tous les rÃ©pertoires:
+#if defined(FDOS)
+  current_path=getcwd(bufr, PATH_MAX);
+#else
   current_path=getcwd(NULL,0);
+#endif
   current_directory=opendir(current_path);
   while ((entry=readdir(current_directory)))
   {
-    // On ignore le répertoire courant
+    // On ignore le rÃ©pertoire courant
     if ( !strcmp(entry->d_name, "."))
     {
       continue;
     }
     stat(entry->d_name,&Infos_enreg);
-    // et que l'élément trouvé est un répertoire
+    // et que l'Ã©lÃ©ment trouvÃ© est un rÃ©pertoire
     if( S_ISDIR(Infos_enreg.st_mode) &&
       // et que c'est ".."
       (!strcmp(entry->d_name, PARENT_DIR) ||
-      // ou qu'il n'est pas caché
+      // ou qu'il n'est pas cachÃ©
        Config.Show_hidden_directories ||
      !isHidden(entry)))
     {
-      // On rajoute le répertoire à la liste
+      // On rajoute le rÃ©pertoire Ã  la liste
       Add_element_to_list(list, entry->d_name, 1);
       list->Nb_directories++;
     }
     else if (S_ISREG(Infos_enreg.st_mode) && //Il s'agit d'un fichier
-      (Config.Show_hidden_files || //Il n'est pas caché
+      (Config.Show_hidden_files || //Il n'est pas cachÃ©
       !isHidden(entry)))
     {
       const char * ext = filter;
@@ -304,7 +318,7 @@
       {      
         if (Check_extension(entry->d_name, ext))
         {
-          // On rajoute le fichier à la liste
+          // On rajoute le fichier Ã  la liste
           Add_element_to_list(list, entry->d_name, 0);
           list->Nb_files++;
           // Stop searching
@@ -391,11 +405,11 @@
     {
       if ( (1 << bit_index) & drive_bits )
       {
-        // On a ce lecteur, il faut maintenant déterminer son type "physique".
+        // On a ce lecteur, il faut maintenant dÃ©terminer son type "physique".
         // pour profiter des jolies icones de X-man.
         int drive_type;
         char drive_path[]="A:\\";
-        // Cette API Windows est étrange, je dois m'y faire...
+        // Cette API Windows est Ã©trange, je dois m'y faire...
         drive_path[0]='A'+bit_index;
         switch (GetDriveType(drive_path))
         {
@@ -424,11 +438,11 @@
   }
   #else
   {
-    //Sous les différents unix, on va mettre
+    //Sous les diffÃ©rents unix, on va mettre
     // un disque dur qui pointera vers la racine,
     // et un autre vers le home directory de l'utilisateur.
 
-    // Ensuite on utilise read_file_system_list pour compléter
+    // Ensuite on utilise read_file_system_list pour complÃ©ter
 
     struct mount_entry* mount_points_list;
     struct mount_entry* next;
@@ -472,15 +486,15 @@
 }
 
 
-// -- Tri de la liste des fichiers et répertoires ---------------------------
+// -- Tri de la liste des fichiers et rÃ©pertoires ---------------------------
 void Sort_list_of_files(T_Fileselector *list)
-// Tri la liste chainée existante dans l'ordre suivant:
+// Tri la liste chainÃ©e existante dans l'ordre suivant:
 //
-// * Les répertoires d'abord, dans l'ordre alphabétique de leur nom
-// * Les fichiers ensuite, dans l'ordre alphabétique de leur nom
+// * Les rÃ©pertoires d'abord, dans l'ordre alphabÃ©tique de leur nom
+// * Les fichiers ensuite, dans l'ordre alphabÃ©tique de leur nom
 {
-  byte   list_is_sorted; // Booléen "La liste est triée"
-  byte   need_swap;          // Booléen "Il faut inverser les éléments"
+  byte   list_is_sorted; // BoolÃ©en "La liste est triÃ©e"
+  byte   need_swap;          // BoolÃ©en "Il faut inverser les Ã©lÃ©ments"
   T_Fileselector_item * prev_item;
   T_Fileselector_item * current_item;
   T_Fileselector_item * next_item;
@@ -491,7 +505,7 @@
   {
     do
     {
-      // Par défaut, on considère que la liste est triée
+      // Par dÃ©faut, on considÃ¨re que la liste est triÃ©e
       list_is_sorted=1;
 
       current_item=list->First;
@@ -502,14 +516,14 @@
         // On commence par supposer qu'il n'y pas pas besoin d'inversion
         need_swap=0;
 
-        // Ensuite, on vérifie si les deux éléments sont bien dans l'ordre ou
+        // Ensuite, on vÃ©rifie si les deux Ã©lÃ©ments sont bien dans l'ordre ou
         // non:
 
-          // Si l'élément courant est un fichier est que le suivant est
-          // un répertoire -> need_swap
+          // Si l'Ã©lÃ©ment courant est un fichier est que le suivant est
+          // un rÃ©pertoire -> need_swap
         if ( current_item->Type < next_item->Type )
           need_swap=1;
-          // Si les deux éléments sont de même type et que le nom du suivant
+          // Si les deux Ã©lÃ©ments sont de mÃªme type et que le nom du suivant
           // est plus petit que celui du courant -> need_swap
         else if ( (current_item->Type==next_item->Type) &&
                   (strcmp(current_item->Full_name,next_item->Full_name)>0) )
@@ -518,39 +532,39 @@
 
         if (need_swap)
         {
-          // Si les deux éléments nécessitent d'être inversé:
+          // Si les deux Ã©lÃ©ments nÃ©cessitent d'Ãªtre inversÃ©:
 
           // On les inverses:
 
-          // On note avant tout les éléments qui encapsulent nos deux amis
+          // On note avant tout les Ã©lÃ©ments qui encapsulent nos deux amis
           prev_item         =current_item->Previous;
           next_to_next_item=next_item->Next;
 
-          // On permute le chaînage des deux éléments entree eux
+          // On permute le chaÃ®nage des deux Ã©lÃ©ments entree eux
           current_item->Next  =next_to_next_item;
           current_item->Previous=next_item;
           next_item->Next  =current_item;
           next_item->Previous=prev_item;
 
-          // On tente un chaînage des éléments encapsulant les compères:
+          // On tente un chaÃ®nage des Ã©lÃ©ments encapsulant les compÃ¨res:
           if (prev_item!=NULL)
             prev_item->Next=next_item;
           if (next_to_next_item!=NULL)
             next_to_next_item->Previous=current_item;
 
-          // On fait bien attention à modifier la tête de liste en cas de besoin
+          // On fait bien attention Ã  modifier la tÃªte de liste en cas de besoin
           if (current_item==list->First)
             list->First=next_item;
 
-          // Ensuite, on se prépare à étudier les éléments précédents:
+          // Ensuite, on se prÃ©pare Ã  Ã©tudier les Ã©lÃ©ments prÃ©cÃ©dents:
           current_item=prev_item;
 
-          // Et on constate que la liste n'était pas encore génialement triée
+          // Et on constate que la liste n'Ã©tait pas encore gÃ©nialement triÃ©e
           list_is_sorted=0;
         }
         else
         {
-          // Si les deux éléments sont dans l'ordre:
+          // Si les deux Ã©lÃ©ments sont dans l'ordre:
 
           // On passe aux suivants
           current_item=current_item->Next;
@@ -590,14 +604,14 @@
 }
 
 
-// -- Affichage des éléments de la liste de fichier / répertoire ------------
+// -- Affichage des Ã©lÃ©ments de la liste de fichier / rÃ©pertoire ------------
 void Display_file_list(T_Fileselector *list, short offset_first,short selector_offset)
 //
-// offset_first = Décalage entre le premier fichier visible dans le
-//                   sélecteur et le premier fichier de la liste
+// offset_first = DÃ©calage entre le premier fichier visible dans le
+//                   sÃ©lecteur et le premier fichier de la liste
 //
-// selector_offset  = Décalage entre le premier fichier visible dans le
-//                   sélecteur et le fichier sélectionné dans la liste
+// selector_offset  = DÃ©calage entre le premier fichier visible dans le
+//                   sÃ©lecteur et le fichier sÃ©lectionnÃ© dans la liste
 //
 {
   T_Fileselector_item * current_item;
@@ -606,16 +620,16 @@
   byte   background_color;
 
 
-  // On vérifie s'il y a au moins 1 fichier dans la liste:
+  // On vÃ©rifie s'il y a au moins 1 fichier dans la liste:
   if (list->Nb_elements>0)
   {
-    // On commence par chercher à pointer sur le premier fichier visible:
+    // On commence par chercher Ã  pointer sur le premier fichier visible:
     current_item = Get_item_by_index(list, offset_first);
 
-    // Pour chacun des 10 éléments inscriptibles à l'écran
+    // Pour chacun des 10 Ã©lÃ©ments inscriptibles Ã  l'Ã©cran
     for (index=0;index<10;index++)
     {
-      // S'il est sélectionné:
+      // S'il est sÃ©lectionnÃ©:
       if (!selector_offset)
       {
         // Si c'est un fichier
@@ -637,10 +651,10 @@
         background_color=NORMAL_BACKGROUND_COLOR;
       }
 
-      // On affiche l'élément
+      // On affiche l'Ã©lÃ©ment
       Print_in_window(8,95+index*8,current_item->Short_name,text_color,background_color);
 
-      // On passe à la ligne suivante
+      // On passe Ã  la ligne suivante
       selector_offset--;
       current_item=current_item->Next;
       if (!current_item)
@@ -651,30 +665,30 @@
 }
 
 
-// -- Récupérer le libellé d'un élément de la liste -------------------------
+// -- RÃ©cupÃ©rer le libellÃ© d'un Ã©lÃ©ment de la liste -------------------------
 void Get_selected_item(T_Fileselector *list, short offset_first,short selector_offset,char * label,int *type)
 //
-// offset_first = Décalage entre le premier fichier visible dans le
-//                   sélecteur et le premier fichier de la liste
+// offset_first = DÃ©calage entre le premier fichier visible dans le
+//                   sÃ©lecteur et le premier fichier de la liste
 //
-// selector_offset  = Décalage entre le premier fichier visible dans le
-//                   sélecteur et le fichier à récupérer
+// selector_offset  = DÃ©calage entre le premier fichier visible dans le
+//                   sÃ©lecteur et le fichier Ã  rÃ©cupÃ©rer
 //
-// label          = str de réception du libellé de l'élément
+// label          = str de rÃ©ception du libellÃ© de l'Ã©lÃ©ment
 //
-// type             = Récupération du type: 0 fichier, 1 repertoire, 2 lecteur.
-//                    Passer NULL si pas interessé.
+// type             = RÃ©cupÃ©ration du type: 0 fichier, 1 repertoire, 2 lecteur.
+//                    Passer NULL si pas interessÃ©.
 {
   T_Fileselector_item * current_item;
 
-  // On vérifie s'il y a au moins 1 fichier dans la liste:
+  // On vÃ©rifie s'il y a au moins 1 fichier dans la liste:
   if (list->Nb_elements>0)
   {
-    // On commence par chercher à pointer sur le premier fichier visible:
-    // Ensuite, on saute autant d'éléments que le décalage demandé:
+    // On commence par chercher Ã  pointer sur le premier fichier visible:
+    // Ensuite, on saute autant d'Ã©lÃ©ments que le dÃ©calage demandÃ©:
     current_item = Get_item_by_index(list, offset_first + selector_offset);
 
-    // On recopie la chaîne
+    // On recopie la chaÃ®ne
     strcpy(label, current_item->Full_name);
 
     if (type != NULL)
@@ -683,28 +697,28 @@
 }
 
 
-// ----------------- Déplacements dans la liste de fichiers -----------------
+// ----------------- DÃ©placements dans la liste de fichiers -----------------
 
 void Selector_scroll_down(short * offset_first,short * selector_offset)
-// Fait scroller vers le bas le sélecteur de fichier... (si possible)
+// Fait scroller vers le bas le sÃ©lecteur de fichier... (si possible)
 {
   if ( ((*selector_offset)<9)
     && ( (*selector_offset)+1 < Filelist.Nb_elements ) )
-    // Si la sélection peut descendre
+    // Si la sÃ©lection peut descendre
     Display_file_list(&Filelist, *offset_first,++(*selector_offset));
-  else // Sinon, descendre la fenêtre (si possible)
+  else // Sinon, descendre la fenÃªtre (si possible)
   if ((*offset_first)+10<Filelist.Nb_elements)
     Display_file_list(&Filelist, ++(*offset_first),*selector_offset);
 }
 
 
 void Selector_scroll_up(short * offset_first,short * selector_offset)
-// Fait scroller vers le haut le sélecteur de fichier... (si possible)
+// Fait scroller vers le haut le sÃ©lecteur de fichier... (si possible)
 {
   if ((*selector_offset)>0)
-    // Si la sélection peut monter
+    // Si la sÃ©lection peut monter
     Display_file_list(&Filelist, *offset_first,--(*selector_offset));
-  else // Sinon, monter la fenêtre (si possible)
+  else // Sinon, monter la fenÃªtre (si possible)
   if ((*offset_first)>0)
     Display_file_list(&Filelist, --(*offset_first),*selector_offset);
 }
@@ -781,9 +795,9 @@
 
 short Compute_click_offset_in_fileselector(void)
 /*
-  Renvoie le décalage dans le sélecteur de fichier sur lequel on a clické.
-  Renvoie le décalage du dernier fichier si on a clické au delà.
-  Renvoie -1 si le sélecteur est vide.
+  Renvoie le dÃ©calage dans le sÃ©lecteur de fichier sur lequel on a clickÃ©.
+  Renvoie le dÃ©calage du dernier fichier si on a clickÃ© au delÃ .
+  Renvoie -1 si le sÃ©lecteur est vide.
 */
 {
   short computed_offset;
@@ -800,7 +814,7 @@
   if (Config.Bookmark_directory[bookmark_number])
   {
     int label_size;
-    // Libellé
+    // LibellÃ©
     Print_in_window_limited(Button->Pos_X+3+10,Button->Pos_Y+2,Config.Bookmark_label[bookmark_number],8,MC_Black,MC_Light);
     label_size=strlen(Config.Bookmark_label[bookmark_number]);
     if (label_size<8)
@@ -815,7 +829,7 @@
   }
   else
   {
-    // Libellé
+    // LibellÃ©
     Print_in_window(Button->Pos_X+3+10,Button->Pos_Y+2,"--------",MC_Dark,MC_Light);
     // Menu apparait sur clic droit ou gauche
     Button->Active_button=RIGHT_SIDE|LEFT_SIDE;
@@ -829,42 +843,42 @@
 
 void Print_current_directory(void)
 //
-// Affiche Main_current_directory sur 37 caractères
+// Affiche Main_current_directory sur 37 caractÃ¨res
 //
 {
-  char temp_name[MAX_DISPLAYABLE_PATH+1]; // Nom tronqué
-  int  length; // length du répertoire courant
-  int  index;   // index de parcours de la chaine complète
+  char temp_name[MAX_DISPLAYABLE_PATH+1]; // Nom tronquÃ©
+  int  length; // length du rÃ©pertoire courant
+  int  index;   // index de parcours de la chaine complÃ¨te
 
   Window_rectangle(10,84,37*8,8,MC_Light);
 
   length=strlen(Main_current_directory);
   if (length>MAX_DISPLAYABLE_PATH)
-  { // Doh! il va falloir tronquer le répertoire (bouh !)
+  { // Doh! il va falloir tronquer le rÃ©pertoire (bouh !)
 
-    // On commence par copier bêtement les 3 premiers caractères (e.g. "C:\")
+    // On commence par copier bÃªtement les 3 premiers caractÃ¨res (e.g. "C:\")
     for (index=0;index<3;index++)
       temp_name[index]=Main_current_directory[index];
 
     // On y rajoute 3 petits points:
     strcpy(temp_name+3,"...");
 
-    //  Ensuite, on cherche un endroit à partir duquel on pourrait loger tout
+    //  Ensuite, on cherche un endroit Ã  partir duquel on pourrait loger tout
     // le reste de la chaine (Ouaaaaaah!!! Vachement fort le mec!!)
     for (index++;index<length;index++)
       if ( (Main_current_directory[index]==PATH_SEPARATOR[0]) &&
            (length-index<=MAX_DISPLAYABLE_PATH-6) )
       {
-        // Ouf: on vient de trouver un endroit dans la chaîne à partir duquel
+        // Ouf: on vient de trouver un endroit dans la chaÃ®ne Ã  partir duquel
         // on peut faire la copie:
         strcpy(temp_name+6,Main_current_directory+index);
         break;
       }
 
-    // Enfin, on peut afficher la chaîne tronquée
+    // Enfin, on peut afficher la chaÃ®ne tronquÃ©e
     Print_in_window(10,84,temp_name,MC_Black,MC_Light);
   }
-  else // Ahhh! La chaîne peut loger tranquillement dans la fenêtre
+  else // Ahhh! La chaÃ®ne peut loger tranquillement dans la fenÃªtre
     Print_in_window(10,84,Main_current_directory,MC_Black,MC_Light);
     
   Update_window_area(10,84,37*8,8);
@@ -880,7 +894,7 @@
   Update_window_area(82,48,27*8,8);
 }
 
-int   Selected_type; // Utilisé pour mémoriser le type d'entrée choisi
+int   Selected_type; // UtilisÃ© pour mÃ©moriser le type d'entrÃ©e choisi
                         // dans le selecteur de fichier.
 
 void Prepare_and_display_filelist(short Position, short offset, T_Scroller_button * button)
@@ -896,11 +910,11 @@
 
   Update_window_area(8-1,95-1,144+2,80+2);
 
-  // On récupère le nom du schmilblick à "accéder"
+  // On rÃ©cupÃ¨re le nom du schmilblick Ã  "accÃ©der"
   Get_selected_item(&Filelist, Position,offset,Selector_filename,&Selected_type);
   // On affiche le nouveau nom de fichier
   Print_filename_in_fileselector();
-  // On affiche le nom du répertoire courant
+  // On affiche le nom du rÃ©pertoire courant
   Print_current_directory();
 }
 
@@ -944,14 +958,14 @@
 
   strcpy(old_filename,Selector_filename);
 
-  // On regarde si la liste a bougé
+  // On regarde si la liste a bougÃ©
   if (file_scroller->Position!=Main_fileselector_position)
   {
-    // Si c'est le cas, il faut mettre à jour la jauge
+    // Si c'est le cas, il faut mettre Ã  jour la jauge
     file_scroller->Position=Main_fileselector_position;
     Window_draw_slider(file_scroller);
   }
-  // On récupére le nom du schmilblick à "accéder"
+  // On rÃ©cupÃ©re le nom du schmilblick Ã  "accÃ©der"
   Get_selected_item(&Filelist, Main_fileselector_position,Main_fileselector_offset,Selector_filename,&Selected_type);
   if (strcmp(old_filename,Selector_filename))
     New_preview_is_needed=1;
@@ -1046,12 +1060,12 @@
   T_Dropdown_button * formats_dropdown;
   T_Dropdown_button * bookmark_dropdown[4];
   short temp;
-  int dummy=0;       // Sert à appeler SDL_GetKeyState
+  int dummy=0;       // Sert Ã  appeler SDL_GetKeyState
   byte  save_or_load_image=0;
-  byte  has_clicked_ok=0;// Indique si on a clické sur Load ou Save ou sur
-                             //un bouton enclenchant Load ou Save juste après.
+  byte  has_clicked_ok=0;// Indique si on a clickÃ© sur Load ou Save ou sur
+                             //un bouton enclenchant Load ou Save juste aprÃ¨s.
   byte  initial_back_color;             // |  fout en l'air (c'te conne).
-  char  previous_directory[MAX_PATH_CHARACTERS]; // Répertoire d'où l'on vient après un CHDIR
+  char  previous_directory[MAX_PATH_CHARACTERS]; // RÃ©pertoire d'oÃ¹ l'on vient aprÃ¨s un CHDIR
   char  quicksearch_filename[MAX_PATH_CHARACTERS]="";
   char  save_filename[MAX_PATH_CHARACTERS];
   char  initial_comment[COMMENT_SIZE+1];
@@ -1156,7 +1170,7 @@
     Window_display_icon_sprite(bookmark_dropdown[temp]->Pos_X+3,bookmark_dropdown[temp]->Pos_Y+2,ICON_STAR);
     Display_bookmark(bookmark_dropdown[temp],temp);
   }
-  // On prend bien soin de passer dans le répertoire courant (le bon qui faut! Oui madame!)
+  // On prend bien soin de passer dans le rÃ©pertoire courant (le bon qui faut! Oui madame!)
   if (load)
   {
     chdir(Main_current_directory);
@@ -1173,8 +1187,8 @@
 
   if (!load)
   {
-    // On initialise le nom de fichier à celui en cours et non pas celui sous
-    // la barre de sélection
+    // On initialise le nom de fichier Ã  celui en cours et non pas celui sous
+    // la barre de sÃ©lection
     strcpy(Selector_filename,context->File_name);
     // On affiche le nouveau nom de fichier
     Print_filename_in_fileselector();
@@ -1247,9 +1261,9 @@
               // On efface le repertoire (si on peut)
               temp=(!rmdir(Selector_filename));
 
-            if (temp) // temp indique si l'effacement s'est bien passé
+            if (temp) // temp indique si l'effacement s'est bien passÃ©
             {
-              // On remonte si c'était le dernier élément de la liste
+              // On remonte si c'Ã©tait le dernier Ã©lÃ©ment de la liste
               if (Main_fileselector_position+Main_fileselector_offset==Filelist.Nb_elements-1)
               {
                 if (Main_fileselector_position)
@@ -1258,7 +1272,7 @@
                   if (Main_fileselector_offset)
                     Main_fileselector_offset--;
               }
-              else // Si ce n'était pas le dernier, il faut faire gaffe à ce
+              else // Si ce n'Ã©tait pas le dernier, il faut faire gaffe Ã  ce
               {    // que ses copains d'en dessous ne remontent pas trop.
                 if ( (Main_fileselector_position)
                   && (Main_fileselector_position+10==Filelist.Nb_elements) )
@@ -1275,8 +1289,8 @@
             else
               Error(0);
 
-            // On place la barre de sélection du brouillon au début s'il a le
-            // même répertoire que l'image principale.
+            // On place la barre de sÃ©lection du brouillon au dÃ©but s'il a le
+            // mÃªme rÃ©pertoire que l'image principale.
             if (!strcmp(Main_current_directory,Spare_current_directory))
             {
               Spare_fileselector_position=0;
@@ -1294,14 +1308,14 @@
         {
           if (temp!=Main_fileselector_offset)
           {
-            // On met à jour le décalage
+            // On met Ã  jour le dÃ©calage
             Main_fileselector_offset=temp;
 
-            // On récupére le nom du schmilblick à "accéder"
+            // On rÃ©cupÃ©re le nom du schmilblick Ã  "accÃ©der"
             Get_selected_item(&Filelist, Main_fileselector_position,Main_fileselector_offset,Selector_filename,&Selected_type);
             // On affiche le nouveau nom de fichier
             Print_filename_in_fileselector();
-            // On affiche à nouveau la liste
+            // On affiche Ã  nouveau la liste
             Display_file_list(&Filelist, Main_fileselector_position,Main_fileselector_offset);
 
             // On vient de changer de nom de fichier, donc on doit s'appreter
@@ -1311,10 +1325,10 @@
           }
           else
           {
-            //   En sauvegarde, si on a double-clické sur un répertoire, il
-            // faut mettre le nom de fichier au nom du répertoire. Sinon, dans
+            //   En sauvegarde, si on a double-clickÃ© sur un rÃ©pertoire, il
+            // faut mettre le nom de fichier au nom du rÃ©pertoire. Sinon, dans
             // certains cas, on risque de sauvegarder avec le nom du fichier
-            // actuel au lieu de changer de répertoire.
+            // actuel au lieu de changer de rÃ©pertoire.
             if (Main_fileselector_position+Main_fileselector_offset<Filelist.Nb_directories)
               Get_selected_item(&Filelist, Main_fileselector_position,Main_fileselector_offset,Selector_filename,&Selected_type);
 
@@ -1330,11 +1344,11 @@
       case  5 : // Scroller de fichiers
         Hide_cursor();
         Main_fileselector_position=Window_attribute2;
-        // On récupére le nom du schmilblick à "accéder"
+        // On rÃ©cupÃ©re le nom du schmilblick Ã  "accÃ©der"
         Get_selected_item(&Filelist, Main_fileselector_position,Main_fileselector_offset,Selector_filename,&Selected_type);
         // On affiche le nouveau nom de fichier
         Print_filename_in_fileselector();
-        // On affiche à nouveau la liste
+        // On affiche Ã  nouveau la liste
         Display_file_list(&Filelist, Main_fileselector_position,Main_fileselector_offset);
         Display_cursor();
         New_preview_is_needed=1;
@@ -1343,9 +1357,9 @@
 
       case  6 : // Scroller des formats
         Hide_cursor();
-        // On met à jour le format de browsing du fileselect:
+        // On met Ã  jour le format de browsing du fileselect:
         Main_format=Window_attribute2;
-        // Comme on change de liste, on se place en début de liste:
+        // Comme on change de liste, on se place en dÃ©but de liste:
         Main_fileselector_position=0;
         Main_fileselector_offset=0;
         // Affichage des premiers fichiers visibles:
@@ -1368,7 +1382,7 @@
 
         if (Readline(82,48,Selector_filename,27,2))
         {
-          //   On regarde s'il faut rajouter une extension. C'est-à-dire s'il
+          //   On regarde s'il faut rajouter une extension. C'est-Ã -dire s'il
           // n'y a pas de '.' dans le nom du fichier.
           for(temp=0,dummy=0; ((Selector_filename[temp]) && (!dummy)); temp++)
             if (Selector_filename[temp]=='.')
@@ -1427,7 +1441,7 @@
       case  9 : // Volume Select
           Hide_cursor();
           //   Comme on tombe sur un disque qu'on connait pas, on se place en
-          // début de liste:
+          // dÃ©but de liste:
           Main_fileselector_position=0;
           Main_fileselector_offset=0;
           // Affichage des premiers fichiers visibles:
@@ -1446,7 +1460,7 @@
             
             switch(Window_attribute2)
             {
-              case -1: // bouton lui-même: aller au répertoire mémorisé
+              case -1: // bouton lui-mÃªme: aller au rÃ©pertoire mÃ©morisÃ©
                 if (Config.Bookmark_directory[clicked_button-10])
                 {
                   *quicksearch_filename=0;
@@ -1483,7 +1497,7 @@
               case 1: // Rename
                 if (Config.Bookmark_directory[clicked_button-10])
                 {
-                  // On enlève les "..." avant l'édition
+                  // On enlÃ¨ve les "..." avant l'Ã©dition
                   char bookmark_label[8+1];
                   strcpy(bookmark_label, Config.Bookmark_label[clicked_button-10]);
                   if (bookmark_label[7]==ELLIPSIS_CHARACTER)
@@ -1570,10 +1584,10 @@
         break;
       case SDLK_BACKSPACE : // Backspace
         *quicksearch_filename=0;
-        // Si le choix ".." est bien en tête des propositions...
+        // Si le choix ".." est bien en tÃªte des propositions...
         if (!strcmp(Filelist.First->Full_name,PARENT_DIR))
         {                              
-          // On va dans le répertoire parent.
+          // On va dans le rÃ©pertoire parent.
           strcpy(Selector_filename,PARENT_DIR);
           Selected_type=1;
           has_clicked_ok=1;
@@ -1621,14 +1635,14 @@
 
     if (has_clicked_ok)
     {
-      //   Si c'est un répertoire, on annule "has_clicked_ok" et on passe
+      //   Si c'est un rÃ©pertoire, on annule "has_clicked_ok" et on passe
       // dedans.
       if (Selected_type!=0)
       {
         Hide_cursor();
         has_clicked_ok=0;
 
-        // On mémorise le répertoire dans lequel on était
+        // On mÃ©morise le rÃ©pertoire dans lequel on Ã©tait
         if (strcmp(Selector_filename,PARENT_DIR))
         {
           strcpy(previous_directory,PARENT_DIR);
@@ -1638,15 +1652,15 @@
             Extract_filename(previous_directory, Main_current_directory);
         }
 
-        // On doit rentrer dans le répertoire:
+        // On doit rentrer dans le rÃ©pertoire:
         if (!chdir(Selector_filename))
         {
           getcwd(Main_current_directory,256);
   
-          // On lit le nouveau répertoire
+          // On lit le nouveau rÃ©pertoire
           Read_list_of_files(&Filelist, Main_format);
           Sort_list_of_files(&Filelist);
-          // On place la barre de sélection sur le répertoire d'où l'on vient
+          // On place la barre de sÃ©lection sur le rÃ©pertoire d'oÃ¹ l'on vient
           Highlight_file(previous_directory);
         }
         else
@@ -1656,7 +1670,7 @@
         Display_cursor();
         New_preview_is_needed=1;
 
-        // On est dans un nouveau répertoire, donc on remet le quicksearch à 0
+        // On est dans un nouveau rÃ©pertoire, donc on remet le quicksearch Ã  0
         *quicksearch_filename=0;
       }
       else  // Sinon on essaye de charger ou sauver le fichier
@@ -1671,14 +1685,14 @@
     // Gestion du chrono et des previews
     if (New_preview_is_needed)
     {
-      // On efface les infos de la preview précédente s'il y en a une
-      // d'affichée
+      // On efface les infos de la preview prÃ©cÃ©dente s'il y en a une
+      // d'affichÃ©e
       if (Timer_state==2)
       {
         Hide_cursor();
-        // On efface le commentaire précédent
+        // On efface le commentaire prÃ©cÃ©dent
         Window_rectangle(45,70,32*8,8,MC_Light);
-        // On nettoie la zone où va s'afficher la preview:
+        // On nettoie la zone oÃ¹ va s'afficher la preview:
         Window_rectangle(183,95,120,80,MC_Light);
         // On efface les dimensions de l'image
         Window_rectangle(143,59,72,8,MC_Light);
@@ -1692,15 +1706,15 @@
           Print_in_window(45,70,context->Comment,MC_Black,MC_Light);
         }
         Display_cursor();
-        // Un update pour couvrir les 4 zones: 3 libellés plus le commentaire
+        // Un update pour couvrir les 4 zones: 3 libellÃ©s plus le commentaire
         Update_window_area(45,48,256,30);
         // Zone de preview
         Update_window_area(183,95,120,80);
       }
 
       New_preview_is_needed=0;
-      Timer_state=0;         // State du chrono = Attente d'un Xème de seconde
-      // On lit le temps de départ du chrono
+      Timer_state=0;         // State du chrono = Attente d'un XÃ¨me de seconde
+      // On lit le temps de dÃ©part du chrono
       Init_chrono(Config.Timer_delay);
     }
 
@@ -1724,7 +1738,7 @@
 
       }
 
-      Timer_state=2; // On arrête le chrono
+      Timer_state=2; // On arrÃªte le chrono
     }
   }
   while ( (!has_clicked_ok) && (clicked_button!=2) );
@@ -1743,7 +1757,7 @@
   }
   
 
-  //   On restaure les données de l'image qui ont certainement été modifiées
+  //   On restaure les donnÃ©es de l'image qui ont certainement Ã©tÃ© modifiÃ©es
   // par la preview.
   Set_palette(Main_palette);
   Back_color=initial_back_color;
diff -ruN gfx2orig/src/global.h grafx2/src/global.h
--- gfx2orig/src/global.h	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/global.h	2022-03-20 20:19:34.112495316 -0500
@@ -29,6 +29,9 @@
 #ifndef _GLOBAL_H_
 #define _GLOBAL_H_
 
+#if defined(FDOS)
+#include <stdio.h>
+#endif
 #include <SDL.h>
 #include "struct.h"
 
diff -ruN gfx2orig/src/graph.c grafx2/src/graph.c
--- gfx2orig/src/graph.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/graph.c	2022-03-20 20:19:34.112495316 -0500
@@ -60,8 +60,8 @@
 // Generic pixel-drawing function.
 Func_pixel Pixel_figure;
 
-// Fonction qui met à jour la zone de l'image donnée en paramètre sur l'écran.
-// Tient compte du décalage X et Y et du zoom, et fait tous les controles nécessaires
+// Fonction qui met Ã  jour la zone de l'image donnÃ©e en paramÃ¨tre sur l'Ã©cran.
+// Tient compte du dÃ©calage X et Y et du zoom, et fait tous les controles nÃ©cessaires
 void Update_part_of_screen(short x, short y, short width, short height)
 {
   short effective_w, effective_h;
@@ -69,7 +69,7 @@
   short effective_Y;
   short diff;
 
-  // Première étape, si L ou H est négatif, on doit remettre la zone à l'endroit
+  // PremiÃ¨re Ã©tape, si L ou H est nÃ©gatif, on doit remettre la zone Ã  l'endroit
   if (width < 0)
   {
     x += width;
@@ -82,7 +82,7 @@
     height = - height;
   }
 
-  // D'abord on met à jour dans la zone écran normale
+  // D'abord on met Ã  jour dans la zone Ã©cran normale
   diff = x-Main_offset_X;
   if (diff<0)
   {
@@ -106,8 +106,8 @@
     effective_Y = diff;
   }
 
-  // Normalement il ne faudrait pas updater au delà du split quand on est en mode loupe,
-  // mais personne ne devrait demander d'update en dehors de cette limite, même le fill est contraint
+  // Normalement il ne faudrait pas updater au delÃ  du split quand on est en mode loupe,
+  // mais personne ne devrait demander d'update en dehors de cette limite, mÃªme le fill est contraint
   // a rester dans la zone visible de l'image
   // ...Sauf l'affichage de brosse en preview - yr
   if(Main_magnifier_mode && effective_X + effective_w > Main_separator_position)
@@ -128,7 +128,7 @@
   */
   Update_rect(effective_X,effective_Y,effective_w,effective_h);
 
-  // Et ensuite dans la partie zoomée
+  // Et ensuite dans la partie zoomÃ©e
   if(Main_magnifier_mode)
   {
     // Clipping en X
@@ -173,7 +173,7 @@
     }
 
 
- // Très utile pour le debug :)
+ // TrÃ¨s utile pour le debug :)
     /*SDL_Rect r;
     r.x=effective_X;
     r.y=effective_Y;
@@ -196,7 +196,7 @@
 }
 
 
-//--------------------- Initialisation d'un mode vidéo -----------------------
+//--------------------- Initialisation d'un mode vidÃ©o -----------------------
 
 int Init_mode_video(int width, int height, int fullscreen, int pix_ratio)
 {
@@ -210,6 +210,13 @@
   int absolute_mouse_y=Mouse_Y*Pixel_height;
   static int Wrong_resize;
 
+#if defined(FDOS)
+  // Only one pixel ratio is supported.
+  pix_ratio = PIXEL_SIMPLE;
+  // Force non-fullscreen mode.
+  fullscreen = 0;
+#endif
+
 try_again:
   
   switch (pix_ratio)
@@ -291,7 +298,7 @@
     if (width < 320*pix_width || height < 200*pix_height)
       return 1;
   }
-  // La largeur doit être un multiple de 4
+  // La largeur doit Ãªtre un multiple de 4
   #ifdef __amigaos4__
       // On AmigaOS the systems adds some more constraints on that ...
       width = (width + 15) & 0xFFFFFFF0;
@@ -568,9 +575,9 @@
   if (fullscreen)
     Set_mouse_position();
   
-  Spare_offset_X=0; // |  Il faut penser à éviter les incohérences
-  Spare_offset_Y=0; // |- de décalage du brouillon par rapport à
-  Spare_magnifier_mode=0; // |  la résolution.
+  Spare_offset_X=0; // |  Il faut penser Ã  Ã©viter les incohÃ©rences
+  Spare_offset_Y=0; // |- de dÃ©calage du brouillon par rapport Ã 
+  Spare_magnifier_mode=0; // |  la rÃ©solution.
 
   if (Main_magnifier_mode)
   {
@@ -603,7 +610,7 @@
 
 
 
-  // -- Redimentionner l'image (nettoie l'écran virtuel) --
+  // -- Redimentionner l'image (nettoie l'Ã©cran virtuel) --
 
 void Resize_image(word chosen_width,word chosen_height)
 {
@@ -619,7 +626,7 @@
 
   if (Backup_with_new_dimensions(1,Main_backups->Pages->Nb_layers,chosen_width,chosen_height))
   {
-    // La nouvelle page a pu être allouée, elle est pour l'instant pleine de
+    // La nouvelle page a pu Ãªtre allouÃ©e, elle est pour l'instant pleine de
     // 0s. Elle fait Main_image_width de large.
 
     Main_image_is_modified=1;
@@ -649,11 +656,11 @@
 {
   short x_pos; // Variable de balayage de la brosse
   short y_pos; // Variable de balayage de la brosse
-  byte  used[256]; // Tableau de booléens "La couleur est utilisée"
+  byte  used[256]; // Tableau de boolÃ©ens "La couleur est utilisÃ©e"
   int   color;
   byte layer;
 
-  // On commence par initialiser le tableau de booléens à faux
+  // On commence par initialiser le tableau de boolÃ©ens Ã  faux
   for (color=0;color<=255;color++)
     used[color]=0;
 
@@ -666,16 +673,16 @@
   //   On va maintenant se servir de la table "used" comme table de
   // conversion: pour chaque indice, la table donne une couleur de
   // remplacement.
-  // Note : Seules les couleurs utilisées on besoin d'êtres recalculées: les
-  //       autres ne seront jamais consultées dans la nouvelle table de
+  // Note : Seules les couleurs utilisÃ©es on besoin d'Ãªtres recalculÃ©es: les
+  //       autres ne seront jamais consultÃ©es dans la nouvelle table de
   //       conversion puisque elles n'existent pas dans l'image, donc elles
-  //       ne seront pas utilisées par Remap_general_lowlevel.
+  //       ne seront pas utilisÃ©es par Remap_general_lowlevel.
   for (color=0;color<=255;color++)
     if (used[color])
       used[color]=Best_color(Spare_palette[color].R,Spare_palette[color].G,Spare_palette[color].B);
 
   //   Maintenant qu'on a une super table de conversion qui n'a que le nom
-  // qui craint un peu, on peut faire l'échange dans la brosse de toutes les
+  // qui craint un peu, on peut faire l'Ã©change dans la brosse de toutes les
   // teintes.
   for (layer=0; layer<Spare_backups->Pages->Nb_layers; layer++)
     Remap_general_lowlevel(used,Spare_backups->Pages->Image[layer],Spare_image_width,Spare_image_height,Spare_image_width);
@@ -687,7 +694,7 @@
 {
   short x_pos; // Variable de balayage de la brosse
   short y_pos; // Variable de balayage de la brosse
-  byte  used[256]; // Tableau de booléens "La couleur est utilisée"
+  byte  used[256]; // Tableau de boolÃ©ens "La couleur est utilisÃ©e"
   int   color;
 
   if (Confirmation_box("Modify current palette ?"))
@@ -695,7 +702,7 @@
     // Backup with unchanged layers, only palette is modified
     Backup_layers(0);
 
-    // On commence par initialiser le tableau de booléen à faux
+    // On commence par initialiser le tableau de boolÃ©en Ã  faux
     for (color=0;color<=255;color++)
       used[color]=0;
 
@@ -704,7 +711,7 @@
       for (x_pos=0;x_pos<Brush_width;x_pos++)
         used[Read_pixel_from_brush(x_pos,y_pos)]=1;
 
-    // On recopie dans la palette principale les teintes des couleurs utilisées
+    // On recopie dans la palette principale les teintes des couleurs utilisÃ©es
     // dans la palette du brouillon
     for (color=0;color<=255;color++)
       if (used[color])
@@ -736,25 +743,25 @@
 void Fill(short * top_reached  , short * bottom_reached,
           short * left_reached, short * right_reached)
 //
-//   Cette fonction fait un remplissage classique d'une zone délimitée de
-// l'image. Les limites employées sont Limit_top, Limit_bottom, Limit_left
-// et Limit_right. Le point de départ du remplissage est Paintbrush_X,Paintbrush_Y
-// et s'effectue en théorie sur la couleur 1 et emploie la couleur 2 pour le
-// remplissage. Ces restrictions sont dûes à l'utilisation qu'on en fait dans
+//   Cette fonction fait un remplissage classique d'une zone dÃ©limitÃ©e de
+// l'image. Les limites employÃ©es sont Limit_top, Limit_bottom, Limit_left
+// et Limit_right. Le point de dÃ©part du remplissage est Paintbrush_X,Paintbrush_Y
+// et s'effectue en thÃ©orie sur la couleur 1 et emploie la couleur 2 pour le
+// remplissage. Ces restrictions sont dÃ»es Ã  l'utilisation qu'on en fait dans
 // la fonction principale "Fill_general", qui se charge de faire une gestion de
 // tous les effets.
-//   Cette fonction ne doit pas être directement appelée.
+//   Cette fonction ne doit pas Ãªtre directement appelÃ©e.
 //
 {
-  short x_pos;   // Abscisse de balayage du segment, utilisée lors de l'"affichage"
-  short line;   // Ordonnée de la ligne en cours de traitement
-  short start_x; // Abscisse de départ du segment traité
-  short end_x;   // Abscisse de fin du segment traité
-  int   changes_made;    // Booléen "On a fait une modif dans le dernier passage"
-  int   can_propagate; // Booléen "On peut propager la couleur dans le segment"
+  short x_pos;   // Abscisse de balayage du segment, utilisÃ©e lors de l'"affichage"
+  short line;   // OrdonnÃ©e de la ligne en cours de traitement
+  short start_x; // Abscisse de dÃ©part du segment traitÃ©
+  short end_x;   // Abscisse de fin du segment traitÃ©
+  int   changes_made;    // BoolÃ©en "On a fait une modif dans le dernier passage"
+  int   can_propagate; // BoolÃ©en "On peut propager la couleur dans le segment"
   short current_limit_bottom;  // Intervalle vertical restreint
   short current_limit_top;
-  int   line_is_modified;       // Booléen "On a fait une modif dans la ligne"
+  int   line_is_modified;       // BoolÃ©en "On a fait une modif dans la ligne"
 
   changes_made=1;
   current_limit_top=Paintbrush_Y;
@@ -770,22 +777,22 @@
     for (line=current_limit_top;line<=current_limit_bottom;line++)
     {
       line_is_modified=0;
-      // On va traiter le cas de la ligne n° line.
+      // On va traiter le cas de la ligne nÂ° line.
 
-      // On commence le traitement à la gauche de l'écran
+      // On commence le traitement Ã  la gauche de l'Ã©cran
       start_x=Limit_left;
 
       // Pour chaque segment de couleur 1 que peut contenir la ligne
       while (start_x<=Limit_right)
       {
-        // On cherche son début
+        // On cherche son dÃ©but
         while((start_x<=Limit_right) &&
                 (Read_pixel_from_current_layer(start_x,line)!=1))
              start_x++;
 
         if (start_x<=Limit_right)
         {
-          // Un segment de couleur 1 existe et commence à la position start_x.
+          // Un segment de couleur 1 existe et commence Ã  la position start_x.
           // On va donc en chercher la fin.
           for (end_x=start_x+1;(end_x<=Limit_right) &&
                (Read_pixel_from_current_layer(end_x,line)==1);end_x++);
@@ -793,19 +800,19 @@
           //   On sait qu'il existe un segment de couleur 1 qui commence en
           // start_x et qui se termine en end_x-1.
 
-          //   On va maintenant regarder si une couleur sur la périphérie
+          //   On va maintenant regarder si une couleur sur la pÃ©riphÃ©rie
           // permet de colorier ce segment avec la couleur 2.
 
           can_propagate=(
-            // Test de la présence d'un point à gauche du segment
+            // Test de la prÃ©sence d'un point Ã  gauche du segment
             ((start_x>Limit_left) &&
              (Read_pixel_from_current_layer(start_x-1,line)==2)) ||
-            // Test de la présence d'un point à droite du segment
+            // Test de la prÃ©sence d'un point Ã  droite du segment
             ((end_x-1<Limit_right) &&
              (Read_pixel_from_current_layer(end_x    ,line)==2))
                                );
 
-          // Test de la présence d'un point en haut du segment
+          // Test de la prÃ©sence d'un point en haut du segment
           if (!can_propagate && (line>Limit_top))
             for (x_pos=start_x;x_pos<end_x;x_pos++)
               if (Read_pixel_from_current_layer(x_pos,line-1)==2)
@@ -820,7 +827,7 @@
               *left_reached=start_x;
             if (end_x>*right_reached)
               *right_reached=end_x;
-            // On remplit le segment de start_x à end_x-1.
+            // On remplit le segment de start_x Ã  end_x-1.
             for (x_pos=start_x;x_pos<end_x;x_pos++)
               Pixel_in_current_layer(x_pos,line,2);
             // On vient d'effectuer des modifications.
@@ -841,8 +848,8 @@
 
     // Pour le prochain balayage vers le haut, on va se permettre d'aller
     // voir une ligne plus haut.
-    // Si on ne le fait pas, et que la première ligne (current_limit_top)
-    // n'était pas modifiée, alors cette limite ne serait pas remontée, donc
+    // Si on ne le fait pas, et que la premiÃ¨re ligne (current_limit_top)
+    // n'Ã©tait pas modifiÃ©e, alors cette limite ne serait pas remontÃ©e, donc
     // le filler ne progresserait pas vers le haut.
     if (current_limit_top>Limit_top)
       current_limit_top--;
@@ -850,21 +857,21 @@
     for (line=current_limit_bottom;line>=current_limit_top;line--)
     {
       line_is_modified=0;
-      // On va traiter le cas de la ligne n° line.
+      // On va traiter le cas de la ligne nÂ° line.
 
-      // On commence le traitement à la gauche de l'écran
+      // On commence le traitement Ã  la gauche de l'Ã©cran
       start_x=Limit_left;
 
       // Pour chaque segment de couleur 1 que peut contenir la ligne
       while (start_x<=Limit_right)
       {
-        // On cherche son début
+        // On cherche son dÃ©but
         for (;(start_x<=Limit_right) &&
              (Read_pixel_from_current_layer(start_x,line)!=1);start_x++);
 
         if (start_x<=Limit_right)
         {
-          // Un segment de couleur 1 existe et commence à la position start_x.
+          // Un segment de couleur 1 existe et commence Ã  la position start_x.
           // On va donc en chercher la fin.
           for (end_x=start_x+1;(end_x<=Limit_right) &&
                (Read_pixel_from_current_layer(end_x,line)==1);end_x++);
@@ -872,19 +879,19 @@
           //   On sait qu'il existe un segment de couleur 1 qui commence en
           // start_x et qui se termine en end_x-1.
 
-          //   On va maintenant regarder si une couleur sur la périphérie
+          //   On va maintenant regarder si une couleur sur la pÃ©riphÃ©rie
           // permet de colorier ce segment avec la couleur 2.
 
           can_propagate=(
-            // Test de la présence d'un point à gauche du segment
+            // Test de la prÃ©sence d'un point Ã  gauche du segment
             ((start_x>Limit_left) &&
              (Read_pixel_from_current_layer(start_x-1,line)==2)) ||
-            // Test de la présence d'un point à droite du segment
+            // Test de la prÃ©sence d'un point Ã  droite du segment
             ((end_x-1<Limit_right) &&
              (Read_pixel_from_current_layer(end_x    ,line)==2))
                                );
 
-          // Test de la présence d'un point en bas du segment
+          // Test de la prÃ©sence d'un point en bas du segment
           if (!can_propagate && (line<Limit_bottom))
             for (x_pos=start_x;x_pos<end_x;x_pos++)
               if (Read_pixel_from_current_layer(x_pos,line+1)==2)
@@ -899,7 +906,7 @@
               *left_reached=start_x;
             if (end_x>*right_reached)
               *right_reached=end_x;
-            // On remplit le segment de start_x à end_x-1.
+            // On remplit le segment de start_x Ã  end_x-1.
             for (x_pos=start_x;x_pos<end_x;x_pos++)
               Pixel_in_current_layer(x_pos,line,2);
             // On vient d'effectuer des modifications.
@@ -931,8 +938,8 @@
 
 void Fill_general(byte fill_color)
 //
-//  Cette fonction fait un remplissage qui gère tous les effets. Elle fait
-// appel à "Fill()".
+//  Cette fonction fait un remplissage qui gÃ¨re tous les effets. Elle fait
+// appel Ã  "Fill()".
 //
 {
   byte   cursor_shape_before_fill;
@@ -942,7 +949,7 @@
   byte   replace_table[256];
 
 
-  // Avant toute chose, on vérifie que l'on n'est pas en train de remplir
+  // Avant toute chose, on vÃ©rifie que l'on n'est pas en train de remplir
   // en dehors de l'image:
 
   if ( (Paintbrush_X>=Limit_left) &&
@@ -950,7 +957,7 @@
        (Paintbrush_Y>=Limit_top)   &&
        (Paintbrush_Y<=Limit_bottom) )
   {
-    // On suppose que le curseur est déjà caché.
+    // On suppose que le curseur est dÃ©jÃ  cachÃ©.
     // Hide_cursor();
 
     //   On va faire patienter l'utilisateur en lui affichant un joli petit
@@ -965,7 +972,7 @@
     // On fait attention au Feedback qui DOIT se faire avec le backup.
     Update_FX_feedback(0);
 
-    // On va maintenant "épurer" la zone visible de l'image:
+    // On va maintenant "Ã©purer" la zone visible de l'image:
     memset(replace_table,0,256);
     replace_table[Read_pixel_from_backup_layer(Paintbrush_X,Paintbrush_Y)]=1;
     Replace_colors_within_limits(replace_table);
@@ -974,13 +981,13 @@
     Fill(&top_reached  ,&bottom_reached,
          &left_reached,&right_reached);
 
-    //  On s'apprête à faire des opérations qui nécessitent un affichage. Il
-    // faut donc retirer de l'écran le curseur:
+    //  On s'apprÃªte Ã  faire des opÃ©rations qui nÃ©cessitent un affichage. Il
+    // faut donc retirer de l'Ã©cran le curseur:
     Hide_cursor();
     Cursor_shape=cursor_shape_before_fill;
 
     //  Il va maintenant falloir qu'on "turn" ce gros caca "into" un truc qui
-    // ressemble un peu plus à ce à quoi l'utilisateur peut s'attendre.
+    // ressemble un peu plus Ã  ce Ã  quoi l'utilisateur peut s'attendre.
     if (top_reached>Limit_top)
       Copy_part_of_image_to_another(Main_backups->Pages->Next->Image[Main_current_layer], // source
                                                Limit_left,Limit_top,       // Pos X et Y dans source
@@ -1016,12 +1023,12 @@
       for (x_pos=left_reached;x_pos<=right_reached;x_pos++)
         if (Read_pixel_from_current_layer(x_pos,y_pos)==2)
         {
-          //   Si le pixel en cours de traitement a été touché par le Fill()
-          // on se doit d'afficher le pixel modifié par la couleur de
+          //   Si le pixel en cours de traitement a Ã©tÃ© touchÃ© par le Fill()
+          // on se doit d'afficher le pixel modifiÃ© par la couleur de
           // remplissage:
 
-          //  Ceci se fait en commençant par restaurer la couleur qu'il y avait
-          // précédemment (c'est important pour que les effets ne s'emmèlent
+          //  Ceci se fait en commenÃ§ant par restaurer la couleur qu'il y avait
+          // prÃ©cÃ©demment (c'est important pour que les effets ne s'emmÃ¨lent
           // pas le pinceaux)
           Pixel_in_current_screen(x_pos,y_pos,Read_pixel_from_backup_layer(x_pos,y_pos),0);
 
@@ -1035,11 +1042,11 @@
     // Restore original feedback value
     Update_FX_feedback(Config.FX_Feedback);
 
-    //   A la fin, on n'a pas besoin de réafficher le curseur puisque c'est
+    //   A la fin, on n'a pas besoin de rÃ©afficher le curseur puisque c'est
     // l'appelant qui s'en charge, et on n'a pas besoin de rafficher l'image
-    // puisque les seuls points qui ont changé dans l'image ont été raffichés
+    // puisque les seuls points qui ont changÃ© dans l'image ont Ã©tÃ© raffichÃ©s
     // par l'utilisation de "Display_pixel()", et que les autres... eh bein
-    // on n'y a jamais touché à l'écran les autres: ils sont donc corrects.
+    // on n'y a jamais touchÃ© Ã  l'Ã©cran les autres: ils sont donc corrects.
     if(Main_magnifier_mode)
     {
       short w,h;
@@ -1058,7 +1065,7 @@
 
 
 //////////////////////////////////////////////////////////////////////////////
-////////////////// TRACéS DE FIGURES GéOMéTRIQUES STANDARDS //////////////////
+////////////////// TRACÃ©S DE FIGURES GÃ©OMÃ©TRIQUES STANDARDS //////////////////
 ////////////////////////// avec gestion de previews //////////////////////////
 //////////////////////////////////////////////////////////////////////////////
 
@@ -1072,7 +1079,7 @@
     Permanent_draw_next_refresh = SDL_GetTicks() + 100;
   }
 
-  // Affichage d'un point de façon définitive (utilisation du pinceau)
+  // Affichage d'un point de faÃ§on dÃ©finitive (utilisation du pinceau)
   void Pixel_figure_permanent(word x_pos,word y_pos,byte color)
   {
     Display_paintbrush(x_pos,y_pos,color,0);
@@ -1090,7 +1097,7 @@
     }
   }
 
-  // Affichage d'un point de façon définitive
+  // Affichage d'un point de faÃ§on dÃ©finitive
   void Pixel_clipped(word x_pos,word y_pos,byte color)
   {
     if ( (x_pos>=Limit_left) &&
@@ -1163,7 +1170,7 @@
   }
 
 
-  // -- Tracer général d'un cercle vide -------------------------------------
+  // -- Tracer gÃ©nÃ©ral d'un cercle vide -------------------------------------
 
 void Draw_empty_circle_general(short center_x,short center_y,short radius,byte color)
 {
@@ -1176,14 +1183,14 @@
   start_x=center_x-radius;
   start_y=center_y-radius;
 
-  // Affichage des extremitées du cercle sur chaque quart du cercle:
+  // Affichage des extremitÃ©es du cercle sur chaque quart du cercle:
   for (y_pos=start_y,Circle_cursor_Y=-radius;y_pos<center_y;y_pos++,Circle_cursor_Y++)
     for (x_pos=start_x,Circle_cursor_X=-radius;x_pos<center_x;x_pos++,Circle_cursor_X++)
       if (Pixel_in_circle())
       {
         // On vient de tomber sur le premier point sur la ligne horizontale
         // qui fait partie du cercle.
-        // Donc on peut l'afficher (lui et ses copains symétriques)
+        // Donc on peut l'afficher (lui et ses copains symÃ©triques)
 
          // Quart Haut-gauche
         Pixel_figure(x_pos,y_pos,color);
@@ -1215,7 +1222,7 @@
         break;
       }
 
-  // On affiche à la fin les points cardinaux:
+  // On affiche Ã  la fin les points cardinaux:
   Pixel_figure(center_x,center_y-radius,color); // Haut
   Pixel_figure(center_x-radius,center_y,color); // Gauche
   Pixel_figure(center_x+radius,center_y,color); // Droite
@@ -1224,7 +1231,7 @@
   if(Main_magnifier_mode) Update_part_of_screen(center_x-radius,center_y-radius,2*radius+1,2*radius+1);
 }
 
-  // -- Tracé définitif d'un cercle vide --
+  // -- TracÃ© dÃ©finitif d'un cercle vide --
 
 void Draw_empty_circle_permanent(short center_x,short center_y,short radius,byte color)
 {
@@ -1268,7 +1275,7 @@
   end_x=center_x+radius;
   end_y=center_y+radius;
 
-  // Correction des bornes d'après les limites
+  // Correction des bornes d'aprÃ¨s les limites
   if (start_y<Limit_top)
     start_y=Limit_top;
   if (end_y>Limit_bottom)
@@ -1288,7 +1295,7 @@
 }
 
 
-  // -- Tracer général d'une ellipse vide -----------------------------------
+  // -- Tracer gÃ©nÃ©ral d'une ellipse vide -----------------------------------
 
 void Draw_empty_ellipse_general(short center_x,short center_y,short horizontal_radius,short vertical_radius,byte color)
 {
@@ -1303,7 +1310,7 @@
   // Calcul des limites de l'ellipse
   Ellipse_compute_limites(horizontal_radius+1,vertical_radius+1);
 
-  // Affichage des extremitées de l'ellipse sur chaque quart de l'ellipse:
+  // Affichage des extremitÃ©es de l'ellipse sur chaque quart de l'ellipse:
   for (y_pos=start_y,Ellipse_cursor_Y=-vertical_radius;y_pos<center_y;y_pos++,Ellipse_cursor_Y++)
     for (x_pos=start_x,Ellipse_cursor_X=-horizontal_radius;x_pos<center_x;x_pos++,Ellipse_cursor_X++)
       if (Pixel_in_ellipse())
@@ -1311,7 +1318,7 @@
         // On vient de tomber sur le premier point qui sur la ligne
         // horizontale fait partie de l'ellipse.
 
-        // Donc on peut l'afficher (lui et ses copains symétriques)
+        // Donc on peut l'afficher (lui et ses copains symÃ©triques)
 
          // Quart Haut-gauche
         Pixel_figure(x_pos,y_pos,color);
@@ -1323,7 +1330,7 @@
         Pixel_figure((center_x<<1)-x_pos,(center_y<<1)-y_pos,color);
 
         // On peut ensuite afficher tous les points qui le suivent dont le
-        // pixel voisin du haut n'appartient pas à l'ellipse:
+        // pixel voisin du haut n'appartient pas Ã  l'ellipse:
         for (Ellipse_cursor_Y--,x_pos++,Ellipse_cursor_X++;x_pos<center_x;x_pos++,Ellipse_cursor_X++)
           if (!Pixel_in_ellipse())
           {
@@ -1343,7 +1350,7 @@
         break;
       }
 
-  // On affiche à la fin les points cardinaux:
+  // On affiche Ã  la fin les points cardinaux:
 
   // points verticaux:
   x_pos=center_x;
@@ -1367,7 +1374,7 @@
   Update_part_of_screen(center_x-horizontal_radius,center_y-vertical_radius,2*horizontal_radius+1,2*vertical_radius+1);
 }
 
-  // -- Tracé définitif d'une ellipse vide --
+  // -- TracÃ© dÃ©finitif d'une ellipse vide --
 
 void Draw_empty_ellipse_permanent(short center_x,short center_y,short horizontal_radius,short vertical_radius,byte color)
 {
@@ -1414,7 +1421,7 @@
   // Calcul des limites de l'ellipse
   Ellipse_compute_limites(horizontal_radius+1,vertical_radius+1);
 
-  // Correction des bornes d'après les limites
+  // Correction des bornes d'aprÃ¨s les limites
   if (start_y<Limit_top)
     start_y=Limit_top;
   if (end_y>Limit_bottom)
@@ -1433,7 +1440,7 @@
 }
 
 /******************
-* TRACÉ DE LIGNES *
+* TRACÃ DE LIGNES *
 ******************/
 
 /// Alters bx and by so the (AX,AY)-(BX,BY) segment becomes either horizontal,
@@ -1564,7 +1571,7 @@
   return;
 }
 
-  // -- Tracer général d'une ligne ------------------------------------------
+  // -- Tracer gÃ©nÃ©ral d'une ligne ------------------------------------------
 
 void Draw_line_general(short start_x,short start_y,short end_x,short end_y, byte color)
 {
@@ -1634,7 +1641,7 @@
 
 }
 
-  // -- Tracer définitif d'une ligne --
+  // -- Tracer dÃ©finitif d'une ligne --
 
 void Draw_line_permanent(short start_x,short start_y,short end_x,short end_y, byte color)
 {
@@ -1706,7 +1713,7 @@
   short y_pos;
 
 
-  // On vérifie que les bornes soient dans le bon sens:
+  // On vÃ©rifie que les bornes soient dans le bon sens:
   if (start_x>end_x)
   {
     temp=start_x;
@@ -1749,7 +1756,7 @@
   short y_pos;
 
 
-  // On vérifie que les bornes sont dans le bon sens:
+  // On vÃ©rifie que les bornes sont dans le bon sens:
   if (start_x>end_x)
   {
     temp=start_x;
@@ -1763,7 +1770,7 @@
     end_y=temp;
   }
 
-  // Correction en cas de dépassement des limites de l'image
+  // Correction en cas de dÃ©passement des limites de l'image
   if (end_x>Limit_right)
     end_x=Limit_right;
   if (end_y>Limit_bottom)
@@ -1773,7 +1780,7 @@
   for (y_pos=start_y;y_pos<=end_y;y_pos++)
     for (x_pos=start_x;x_pos<=end_x;x_pos++)
       // Display_pixel traite chaque pixel avec tous les effets ! (smear, ...)
-      // Donc on ne peut pas otimiser en traçant ligne par ligne avec memset :(
+      // Donc on ne peut pas otimiser en traÃ§ant ligne par ligne avec memset :(
       Display_pixel(x_pos,y_pos,color);
   Update_part_of_screen(start_x,start_y,end_x-start_x,end_y-start_y);
 
@@ -1782,7 +1789,7 @@
 
 
 
-  // -- Tracer une courbe de Bézier --
+  // -- Tracer une courbe de BÃ©zier --
 
 void Draw_curve_general(short x1, short y1,
                            short x2, short y2,
@@ -1806,7 +1813,7 @@
   cy[2]= - 3*y1 + 3*y2;
   cy[3]= +   y1;
 
-  // Traçage de la courbe
+  // TraÃ§age de la courbe
   old_x=x1;
   old_y=y1;
   Pixel_figure(old_x,old_y,color);
@@ -1829,7 +1836,7 @@
   Update_part_of_screen(x,y,old_x+1,old_y+1);
 }
 
-  // -- Tracer une courbe de Bézier définitivement --
+  // -- Tracer une courbe de BÃ©zier dÃ©finitivement --
 
 void Draw_curve_permanent(short x1, short y1,
                              short x2, short y2,
@@ -1842,7 +1849,7 @@
   Draw_curve_general(x1,y1,x2,y2,x3,y3,x4,y4,color);
 }
 
-  // -- Tracer la preview d'une courbe de Bézier --
+  // -- Tracer la preview d'une courbe de BÃ©zier --
 
 void Draw_curve_preview(short x1, short y1,
                            short x2, short y2,
@@ -1854,7 +1861,7 @@
   Draw_curve_general(x1,y1,x2,y2,x3,y3,x4,y4,color);
 }
 
-  // -- Effacer la preview d'une courbe de Bézier --
+  // -- Effacer la preview d'une courbe de BÃ©zier --
 
 void Hide_curve_preview(short x1, short y1,
                             short x2, short y2,
@@ -1902,9 +1909,9 @@
   }
   else
   {
-    //   On essaye de se balader dans la table des flux de façon à ce que ce
-    // ne soit pas toujours la dernière couleur qui soit affichée en dernier
-    // Pour ça, on part d'une couleur au pif dans une direction aléatoire.
+    //   On essaye de se balader dans la table des flux de faÃ§on Ã  ce que ce
+    // ne soit pas toujours la derniÃ¨re couleur qui soit affichÃ©e en dernier
+    // Pour Ã§a, on part d'une couleur au pif dans une direction alÃ©atoire.
     direction=rand()&1;
     for (index=0,color_index=rand()/*%256*/; index<256; index++)
     {
@@ -1939,7 +1946,7 @@
   //////////////////////////////////////////////////////////////////////////
 
 
-  // -- Gestion d'un dégradé de base (le plus moche) --
+  // -- Gestion d'un dÃ©gradÃ© de base (le plus moche) --
 
 void Gradient_basic(long index,short x_pos,short y_pos)
 {
@@ -1948,21 +1955,21 @@
   // On fait un premier calcul partiel
   position=(index*Gradient_bounds_range);
 
-  // On gère un déplacement au hasard
+  // On gÃ¨re un dÃ©placement au hasard
   position+=(Gradient_total_range*(rand()%Gradient_random_factor)) >>6;
   position-=(Gradient_total_range*Gradient_random_factor) >>7;
 
   position/=Gradient_total_range;
 
-  //   On va vérifier que nos petites idioties n'ont pas éjecté la valeur hors
-  // des valeurs autorisées par le dégradé défini par l'utilisateur.
+  //   On va vÃ©rifier que nos petites idioties n'ont pas Ã©jectÃ© la valeur hors
+  // des valeurs autorisÃ©es par le dÃ©gradÃ© dÃ©fini par l'utilisateur.
 
   if (position<0)
     position=0;
   else if (position>=Gradient_bounds_range)
     position=Gradient_bounds_range-1;
 
-  // On ramène ensuite la position dans le dégradé vers un numéro de couleur
+  // On ramÃ¨ne ensuite la position dans le dÃ©gradÃ© vers un numÃ©ro de couleur
   if (Gradient_is_inverted)
     Gradient_pixel(x_pos,y_pos,Gradient_upper_bound-position);
   else
@@ -1970,7 +1977,7 @@
 }
 
 
-  // -- Gestion d'un dégradé par trames simples --
+  // -- Gestion d'un dÃ©gradÃ© par trames simples --
 
 void Gradient_dithered(long index,short x_pos,short y_pos)
 {
@@ -1978,22 +1985,22 @@
   long position_in_segment;
 
   //
-  //   But de l'opération: en plus de calculer la position de base (désignée
-  // dans cette procédure par "position_in_gradient", on calcule la position
-  // de l'indice dans le schéma suivant:
+  //   But de l'opÃ©ration: en plus de calculer la position de base (dÃ©signÃ©e
+  // dans cette procÃ©dure par "position_in_gradient", on calcule la position
+  // de l'indice dans le schÃ©ma suivant:
   //
-  //         | Les indices qui traînent de ce côté du segment se voient subir
-  //         | une incrémentation conditionnelle à leur position dans l'écran.
+  //         | Les indices qui traÃ®nent de ce cÃ´tÃ© du segment se voient subir
+  //         | une incrÃ©mentation conditionnelle Ã  leur position dans l'Ã©cran.
   //         v
   //  |---|---|---|---- - - -
   //   ^
-  //   |_ Les indices qui traînent de ce côté du segment se voient subir une
-  //      décrémentation conditionnelle à leur position dans l'écran.
+  //   |_ Les indices qui traÃ®nent de ce cÃ´tÃ© du segment se voient subir une
+  //      dÃ©crÃ©mentation conditionnelle Ã  leur position dans l'Ã©cran.
 
   // On fait d'abord un premier calcul partiel
   position_in_gradient=(index*Gradient_bounds_range);
 
-  // On gère un déplacement au hasard...
+  // On gÃ¨re un dÃ©placement au hasard...
   position_in_gradient+=(Gradient_total_range*(rand()%Gradient_random_factor)) >>6;
   position_in_gradient-=(Gradient_total_range*Gradient_random_factor) >>7;
 
@@ -2003,11 +2010,11 @@
   // ... qui nous permet de calculer la position dans le segment
   position_in_segment=((position_in_gradient<<2)/Gradient_total_range)&3;
 
-  // On peut ensuite terminer le calcul de l'indice dans le dégradé
+  // On peut ensuite terminer le calcul de l'indice dans le dÃ©gradÃ©
   position_in_gradient/=Gradient_total_range;
 
   // On va pouvoir discuter de la valeur de position_in_gradient en fonction
-  // de la position dans l'écran et de la position_in_segment.
+  // de la position dans l'Ã©cran et de la position_in_segment.
 
   switch (position_in_segment)
   {
@@ -2016,23 +2023,23 @@
         position_in_gradient--;
       break;
 
-      // On n'a pas à traiter les cas 1 et 2 car ils représentent des valeurs
-      // suffisament au centre du segment pour ne pas avoir à subir la trame
+      // On n'a pas Ã  traiter les cas 1 et 2 car ils reprÃ©sentent des valeurs
+      // suffisament au centre du segment pour ne pas avoir Ã  subir la trame
 
     case 3 : // On est sur la droite du segment
-      if (((x_pos+y_pos)&1)!=0) // Note: on doit faire le test inverse au cas gauche pour synchroniser les 2 côtés de la trame.
+      if (((x_pos+y_pos)&1)!=0) // Note: on doit faire le test inverse au cas gauche pour synchroniser les 2 cÃ´tÃ©s de la trame.
         position_in_gradient++;
   }
 
-  //   On va vérifier que nos petites idioties n'ont pas éjecté la valeur hors
-  // des valeurs autorisées par le dégradé défini par l'utilisateur.
+  //   On va vÃ©rifier que nos petites idioties n'ont pas Ã©jectÃ© la valeur hors
+  // des valeurs autorisÃ©es par le dÃ©gradÃ© dÃ©fini par l'utilisateur.
 
   if (position_in_gradient<0)
     position_in_gradient=0;
   else if (position_in_gradient>=Gradient_bounds_range)
     position_in_gradient=Gradient_bounds_range-1;
 
-  // On ramène ensuite la position dans le dégradé vers un numéro de couleur
+  // On ramÃ¨ne ensuite la position dans le dÃ©gradÃ© vers un numÃ©ro de couleur
   if (Gradient_is_inverted)
     position_in_gradient=Gradient_upper_bound-position_in_gradient;
   else
@@ -2042,7 +2049,7 @@
 }
 
 
-  // -- Gestion d'un dégradé par trames étendues --
+  // -- Gestion d'un dÃ©gradÃ© par trames Ã©tendues --
 
 void Gradient_extra_dithered(long index,short x_pos,short y_pos)
 {
@@ -2050,22 +2057,22 @@
   long position_in_segment;
 
 //
-  //   But de l'opération: en plus de calculer la position de base (désignée
-  // dans cette procédure par "position_in_gradient", on calcule la position
-  // de l'indice dans le schéma suivant:
+  //   But de l'opÃ©ration: en plus de calculer la position de base (dÃ©signÃ©e
+  // dans cette procÃ©dure par "position_in_gradient", on calcule la position
+  // de l'indice dans le schÃ©ma suivant:
   //
-  //         | Les indices qui traînent de ce côté du segment se voient subir
-  //         | une incrémentation conditionnelle à leur position dans l'écran.
+  //         | Les indices qui traÃ®nent de ce cÃ´tÃ© du segment se voient subir
+  //         | une incrÃ©mentation conditionnelle Ã  leur position dans l'Ã©cran.
   //         v
   //  |---|---|---|---- - - -
   //   ^
-  //   |_ Les indices qui traînent de ce côté du segment se voient subir une
-  //      décrémentation conditionnelle à leur position dans l'écran.
+  //   |_ Les indices qui traÃ®nent de ce cÃ´tÃ© du segment se voient subir une
+  //      dÃ©crÃ©mentation conditionnelle Ã  leur position dans l'Ã©cran.
 
   // On fait d'abord un premier calcul partiel
   position_in_gradient=(index*Gradient_bounds_range);
 
-  // On gère un déplacement au hasard
+  // On gÃ¨re un dÃ©placement au hasard
   position_in_gradient+=(Gradient_total_range*(rand()%Gradient_random_factor)) >>6;
   position_in_gradient-=(Gradient_total_range*Gradient_random_factor) >>7;
 
@@ -2075,15 +2082,15 @@
   // Qui nous permet de calculer la position dans le segment
   position_in_segment=((position_in_gradient<<3)/Gradient_total_range)&7;
 
-  // On peut ensuite terminer le calcul de l'indice dans le dégradé
+  // On peut ensuite terminer le calcul de l'indice dans le dÃ©gradÃ©
   position_in_gradient/=Gradient_total_range;
 
   // On va pouvoir discuter de la valeur de position_in_gradient en fonction
-  // de la position dans l'écran et de la position_in_segment.
+  // de la position dans l'Ã©cran et de la position_in_segment.
 
   switch (position_in_segment)
   {
-    case 0 : // On est sur l'extrême gauche du segment
+    case 0 : // On est sur l'extrÃªme gauche du segment
       if (((x_pos+y_pos)&1)==0)
         position_in_gradient--;
       break;
@@ -2094,8 +2101,8 @@
         position_in_gradient--;
       break;
 
-      // On n'a pas à traiter les cas 3 et 4 car ils représentent des valeurs
-      // suffisament au centre du segment pour ne pas avoir à subir la trame
+      // On n'a pas Ã  traiter les cas 3 et 4 car ils reprÃ©sentent des valeurs
+      // suffisament au centre du segment pour ne pas avoir Ã  subir la trame
 
     case 5 : // On est sur la droite du segment
     case 6 : // On est sur la droite du segment
@@ -2104,19 +2111,19 @@
       break;
 
     case 7 : // On est sur l'extreme droite du segment
-      if (((x_pos+y_pos)&1)!=0) // Note: on doit faire le test inverse au cas gauche pour synchroniser les 2 côtés de la trame.
+      if (((x_pos+y_pos)&1)!=0) // Note: on doit faire le test inverse au cas gauche pour synchroniser les 2 cÃ´tÃ©s de la trame.
         position_in_gradient++;
   }
 
-  //   On va vérifier que nos petites idioties n'ont pas éjecté la valeur hors
-  // des valeurs autorisées par le dégradé défini par l'utilisateur.
+  //   On va vÃ©rifier que nos petites idioties n'ont pas Ã©jectÃ© la valeur hors
+  // des valeurs autorisÃ©es par le dÃ©gradÃ© dÃ©fini par l'utilisateur.
 
   if (position_in_gradient<0)
     position_in_gradient=0;
   else if (position_in_gradient>=Gradient_bounds_range)
     position_in_gradient=Gradient_bounds_range-1;
 
-  // On ramène ensuite la position dans le dégradé vers un numéro de couleur
+  // On ramÃ¨ne ensuite la position dans le dÃ©gradÃ© vers un numÃ©ro de couleur
   if (Gradient_is_inverted)
     position_in_gradient=Gradient_upper_bound-position_in_gradient;
   else
@@ -2127,7 +2134,7 @@
 
 
 
-  // -- Tracer un cercle degradé (une sphère) --
+  // -- Tracer un cercle degradÃ© (une sphÃ¨re) --
 
 void Draw_grad_circle(short center_x,short center_y,short radius,short spot_x,short spot_y)
 {
@@ -2137,15 +2144,15 @@
   long y_pos;
   long end_x;
   long end_y;
-  long distance_x; // Distance (au carré) sur les X du point en cours au centre d'éclairage
-  long distance_y; // Distance (au carré) sur les Y du point en cours au centre d'éclairage
+  long distance_x; // Distance (au carrÃ©) sur les X du point en cours au centre d'Ã©clairage
+  long distance_y; // Distance (au carrÃ©) sur les Y du point en cours au centre d'Ã©clairage
 
   start_x=center_x-radius;
   start_y=center_y-radius;
   end_x=center_x+radius;
   end_y=center_y+radius;
 
-  // Correction des bornes d'après les limites
+  // Correction des bornes d'aprÃ¨s les limites
   if (start_y<Limit_top)
     start_y=Limit_top;
   if (end_y>Limit_bottom)
@@ -2183,7 +2190,7 @@
 }
 
 
-  // -- Tracer une ellipse degradée --
+  // -- Tracer une ellipse degradÃ©e --
 
 void Draw_grad_ellipse(short center_x,short center_y,short horizontal_radius,short vertical_radius,short spot_x,short spot_y)
 {
@@ -2193,8 +2200,8 @@
   long y_pos;
   long end_x;
   long end_y;
-  long distance_x; // Distance (au carré) sur les X du point en cours au centre d'éclairage
-  long distance_y; // Distance (au carré) sur les Y du point en cours au centre d'éclairage
+  long distance_x; // Distance (au carrÃ©) sur les X du point en cours au centre d'Ã©clairage
+  long distance_y; // Distance (au carrÃ©) sur les Y du point en cours au centre d'Ã©clairage
 
 
   start_x=center_x-horizontal_radius;
@@ -2221,7 +2228,7 @@
   if (Gradient_total_range==0)
     Gradient_total_range=1;
 
-  // Correction des bornes d'après les limites
+  // Correction des bornes d'aprÃ¨s les limites
   if (start_y<Limit_top)
     start_y=Limit_top;
   if (end_y>Limit_bottom)
@@ -2249,12 +2256,12 @@
 }
 
 
-// Tracé d'un rectangle (rax ray - rbx rby) dégradé selon le vecteur (vax vay - vbx - vby)
+// TracÃ© d'un rectangle (rax ray - rbx rby) dÃ©gradÃ© selon le vecteur (vax vay - vbx - vby)
 void Draw_grad_rectangle(short rax,short ray,short rbx,short rby,short vax,short vay, short vbx, short vby)
 {
     short y_pos, x_pos;
 
-    // On commence par s'assurer que le rectangle est à l'endroit
+    // On commence par s'assurer que le rectangle est Ã  l'endroit
     if(rbx < rax)
     {
       x_pos = rbx;
@@ -2269,7 +2276,7 @@
       ray = y_pos;
     }
 
-    // Correction des bornes d'après les limites
+    // Correction des bornes d'aprÃ¨s les limites
     if (ray<Limit_top)
       ray=Limit_top;
     if (rby>Limit_bottom)
@@ -2281,7 +2288,7 @@
 
     if(vbx == vax)
     {
-      // Le vecteur est vertical, donc on évite la partie en dessous qui foirerait avec une division par 0...
+      // Le vecteur est vertical, donc on Ã©vite la partie en dessous qui foirerait avec une division par 0...
       if (vby == vay) return;  // L'utilisateur fait n'importe quoi
       Gradient_total_range = abs(vby - vay);
       for(y_pos=ray;y_pos<=rby;y_pos++)
@@ -2302,7 +2309,7 @@
       for (y_pos=ray;y_pos<=rby;y_pos++)
         for (x_pos = rax;x_pos<=rbx;x_pos++)
         {
-          // On calcule ou on en est dans le dégradé
+          // On calcule ou on en est dans le dÃ©gradÃ©
           distance_x = pow((y_pos - vay),2)+pow((x_pos - vax),2);
           distance_y = pow((-a * x_pos + y_pos - b),2)/(a*a+1);
       
@@ -2315,7 +2322,7 @@
 
 
 
-// -- Tracer un polygône plein --
+// -- Tracer un polygÃ´ne plein --
 
 typedef struct T_Polygon_edge      /* an active edge */
 {
@@ -2534,7 +2541,7 @@
   free(initial_edge);
   initial_edge = NULL;
 
-  // On ne connait pas simplement les xmin et xmax ici, mais de toutes façon ce n'est pas utilisé en preview
+  // On ne connait pas simplement les xmin et xmax ici, mais de toutes faÃ§on ce n'est pas utilisÃ© en preview
   Update_part_of_screen(0,top,Main_image_width,bottom-top+1);
 }
 
@@ -2551,7 +2558,7 @@
   }
 
   // Comme pour le Fill, cette operation fait un peu d'"overdraw"
-  // (pixels dessinés plus d'une fois) alors on force le FX Feedback à OFF
+  // (pixels dessinÃ©s plus d'une fois) alors on force le FX Feedback Ã  OFF
   Update_FX_feedback(0);
 
   Pixel_figure=Pixel_clipped;    
@@ -2573,7 +2580,7 @@
 
 
 
-//------------ Remplacement de la couleur pointée par une autre --------------
+//------------ Remplacement de la couleur pointÃ©e par une autre --------------
 
 void Replace(byte New_color)
 {
@@ -2607,32 +2614,32 @@
   int temp;
 
 
-  // On initialise les deux tables de conversion en Identité
+  // On initialise les deux tables de conversion en IdentitÃ©
   for (index=0;index<256;index++)
   {
     table_inc[index]=index;
     table_dec[index]=index;
   }
 
-  // On s'apprête à examiner l'ensemble de la liste
+  // On s'apprÃªte Ã  examiner l'ensemble de la liste
   for (index=0;index<512;index++)
   {
-    // On recherche la première case de la liste non vide (et non inhibée)
+    // On recherche la premiÃ¨re case de la liste non vide (et non inhibÃ©e)
     while ((index<512) && (list[index]>255))
       index++;
 
-    // On note la position de la première case de la séquence
+    // On note la position de la premiÃ¨re case de la sÃ©quence
     first=index;
 
-    // On recherche la position de la dernière case de la séquence
+    // On recherche la position de la derniÃ¨re case de la sÃ©quence
     for (last=first;list[last+1]<256;last++);
 
-    // Pour toutes les cases non vides (et non inhibées) qui suivent
+    // Pour toutes les cases non vides (et non inhibÃ©es) qui suivent
     switch (mode)
     {
       case SHADE_MODE_NORMAL :
         for (;(index<512) && (list[index]<256);index++)
-        { // On met à jour les tables de conversion
+        { // On met Ã  jour les tables de conversion
           color=list[index];
           table_inc[color]=list[(index+step<=last)?index+step:last];
           table_dec[color]=list[(index-step>=first)?index-step:first];
@@ -2641,7 +2648,7 @@
       case SHADE_MODE_LOOP :
         temp=1+last-first;
         for (;(index<512) && (list[index]<256);index++)
-        { // On met à jour les tables de conversion
+        { // On met Ã  jour les tables de conversion
           color=list[index];
           table_inc[color]=list[first+((step+index-first)%temp)];
           table_dec[color]=list[first+(((temp-step)+index-first)%temp)];
@@ -2649,7 +2656,7 @@
         break;
       default : // SHADE_MODE_NOSAT
         for (;(index<512) && (list[index]<256);index++)
-        { // On met à jour les tables de conversion
+        { // On met Ã  jour les tables de conversion
           color=list[index];
           if (index+step<=last)
             table_inc[color]=list[index+step];
@@ -2662,17 +2669,17 @@
 
 
 
-// -- Interface avec l'image, affectée par le facteur de grossissement -------
+// -- Interface avec l'image, affectÃ©e par le facteur de grossissement -------
 
-  // fonction d'affichage "Pixel" utilisée pour les opérations définitivement
-  // Ne doit à aucune condition être appelée en dehors de la partie visible
-  // de l'image dans l'écran (ça pourrait être grave)
+  // fonction d'affichage "Pixel" utilisÃ©e pour les opÃ©rations dÃ©finitivement
+  // Ne doit Ã  aucune condition Ãªtre appelÃ©e en dehors de la partie visible
+  // de l'image dans l'Ã©cran (Ã§a pourrait Ãªtre grave)
 void Display_pixel(word x,word y,byte color)
   // x & y    sont la position d'un point dans l'IMAGE
   // color  est la couleur du point
-  // Le Stencil est géré.
-  // Les effets sont gérés par appel à Effect_function().
-  // La Loupe est gérée par appel à Pixel_preview().
+  // Le Stencil est gÃ©rÃ©.
+  // Les effets sont gÃ©rÃ©s par appel Ã  Effect_function().
+  // La Loupe est gÃ©rÃ©e par appel Ã  Pixel_preview().
 {
   if ( ( (!Sieve_mode)   || (Effect_sieve(x,y)) )
     && (!((Stencil_mode) && (Stencil[Read_pixel_from_current_layer(x,y)])))
@@ -2685,7 +2692,7 @@
 
 
 
-// -- Calcul des différents effets -------------------------------------------
+// -- Calcul des diffÃ©rents effets -------------------------------------------
 
   // -- Aucun effet en cours --
 
@@ -2845,13 +2852,13 @@
     b+=weight*Main_palette[c].B;
   }
 
-  return (total_weight)? // On regarde s'il faut éviter le 0/0.
+  return (total_weight)? // On regarde s'il faut Ã©viter le 0/0.
     Best_color(Round_div(r,total_weight),
                       Round_div(g,total_weight),
                       Round_div(b,total_weight)):
-    Read_pixel_from_current_screen(x,y); // C'est bien l'écran courant et pas
-                                       // l'écran feedback car il s'agit de ne
-}                                      // pas modifier l'écran courant.
+    Read_pixel_from_current_screen(x,y); // C'est bien l'Ã©cran courant et pas
+                                       // l'Ã©cran feedback car il s'agit de ne
+}                                      // pas modifier l'Ã©cran courant.
 
 void Horizontal_grid_line(word x_pos,word y_pos,word width)
 {
diff -ruN gfx2orig/src/help.c grafx2/src/help.c
--- gfx2orig/src/help.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/help.c	2022-03-20 20:19:34.108495316 -0500
@@ -29,7 +29,7 @@
 #elif defined(__macosx__) || defined(__FreeBSD__)
     #include <sys/param.h>
     #include <sys/mount.h>
-#elif defined (__linux__)
+#elif defined (__linux__) || defined(FDOS)
     #include <sys/vfs.h>
 #endif
 
@@ -62,7 +62,7 @@
   return &(Config_Key[shortcut_number & 0xFF][0]);
 }
 
-// Nom de la touche actuallement assignée à un raccourci d'après son numéro
+// Nom de la touche actuallement assignÃ©e Ã  un raccourci d'aprÃ¨s son numÃ©ro
 // de type 0x100+BOUTON_* ou SPECIAL_*
 const char * Keyboard_shortcut_value(word shortcut_number)
 {
@@ -140,7 +140,7 @@
     }
   }
   */
-  config_index=order_index; // Comprends pas... ça devrait pas marcher
+  config_index=order_index; // Comprends pas... Ã§a devrait pas marcher
   
   Open_window(302,131,"Keyboard shortcut");
   Window_set_normal_button(181,111,55,14,"Cancel",0,1,KEY_ESC); // 1
@@ -235,11 +235,11 @@
 
 void Display_help(void)
 {
-  short  x;                   // Indices d'affichage d'un caractère
+  short  x;                   // Indices d'affichage d'un caractÃ¨re
   short  y;
   short  x_position;          // Parcours de remplissage du buffer de ligne
   short  line_index;     // 0-15 (16 lignes de textes)
-  short  char_index; // Parcours des caractères d'une ligne
+  short  char_index; // Parcours des caractÃ¨res d'une ligne
   short  start_line=Help_position;
   short  repeat_menu_x_factor;
   short  repeat_menu_y_factor;
@@ -248,11 +248,11 @@
   byte * char_pixel;
   short  width;             // Largeur physique d'une ligne de texte
   char   line_type;           // N: Normale, T: Titre, S: Sous-titre
-                              // -: Ligne inférieur de sous-titre
+                              // -: Ligne infÃ©rieur de sous-titre
   const char * line;
-  char   buffer[45];          // buffer texte utilisé pour formater les noms de 
+  char   buffer[45];          // buffer texte utilisÃ© pour formater les noms de 
                               // raccourcis clavier
-  short  link_position=0;     // Position du premier caractère "variable"
+  short  link_position=0;     // Position du premier caractÃ¨re "variable"
   short  link_size=0;       // Taille de la partie variable
 
   real_x_pos=Window_pos_X+(13*Menu_factor_X);
@@ -266,8 +266,8 @@
       Block (real_x_pos,
            real_y_pos,
            44*6*Menu_factor_X,
-           // 44 = Nb max de char (+1 pour éviter les plantages en mode X
-           // causés par une largeur = 0)
+           // 44 = Nb max de char (+1 pour Ã©viter les plantages en mode X
+           // causÃ©s par une largeur = 0)
            (Menu_factor_Y<<3) * (16 - line_index),
            MC_Black);
       break;
@@ -275,7 +275,7 @@
     // On affiche la ligne
     line = Help_section[Current_help_section].Help_table[start_line + line_index].Text;
     line_type = Help_section[Current_help_section].Help_table[start_line + line_index].Line_type;
-    // Si c'est une sous-ligne de titre, on utilise le texte de la ligne précédente
+    // Si c'est une sous-ligne de titre, on utilise le texte de la ligne prÃ©cÃ©dente
     if (line_type == '-' && (start_line + line_index > 0))
       line = Help_section[Current_help_section].Help_table[start_line + line_index - 1].Text;
     else if (line_type == 'K')
@@ -313,20 +313,20 @@
     if (line_type == 'T' || line_type == '-')
       width = width*2;
 
-    // Pour chaque ligne dans la fenêtre:
+    // Pour chaque ligne dans la fenÃªtre:
     for (y=0;y<8;y++)
     {
       x_position=0;
-      // On crée une nouvelle ligne à splotcher
+      // On crÃ©e une nouvelle ligne Ã  splotcher
       for (char_index=0;char_index<width;char_index++)
       {
-        // Recherche du caractère dans les fontes de l'aide.
-        // Ligne titre : Si l'indice est impair on dessine le quart de caractère
+        // Recherche du caractÃ¨re dans les fontes de l'aide.
+        // Ligne titre : Si l'indice est impair on dessine le quart de caractÃ¨re
         // qui va a gauche, sinon celui qui va a droite.
         if (line_type=='T')
         {
           if (line[char_index/2]>'_' || line[char_index/2]<' ')
-            char_pixel=&(Gfx->Help_font_norm['!'][0][0]); // Caractère pas géré
+            char_pixel=&(Gfx->Help_font_norm['!'][0][0]); // CaractÃ¨re pas gÃ©rÃ©
           else if (char_index & 1)
             char_pixel=&(Gfx->Help_font_t2[(unsigned char)(line[char_index/2])-' '][0][0]);
           else
@@ -335,7 +335,7 @@
         else if (line_type=='-')
         {
           if (line[char_index/2]>'_' || line[char_index/2]<' ')
-            char_pixel=&(Gfx->Help_font_norm['!'][0][0]); // Caractère pas géré
+            char_pixel=&(Gfx->Help_font_norm['!'][0][0]); // CaractÃ¨re pas gÃ©rÃ©
           else if (char_index & 1)
             char_pixel=&(Gfx->Help_font_t4[(unsigned char)(line[char_index/2])-' '][0][0]);
           else
@@ -378,8 +378,8 @@
     Block (real_x_pos+width*Menu_factor_X*6,
            real_y_pos-(8*Menu_factor_Y),
            ((44*6*Menu_factor_X)-width*Menu_factor_X*6)+1,
-           // 44 = Nb max de char (+1 pour éviter les plantages en mode X
-           // causés par une largeur = 0)
+           // 44 = Nb max de char (+1 pour Ã©viter les plantages en mode X
+           // causÃ©s par une largeur = 0)
            Menu_factor_Y<<3,
            MC_Black);
   }
@@ -414,8 +414,8 @@
   }
   Window_help(-1, NULL);
 }
-// Ouvre l'ecran d'aide. Passer -1 pour la section par défaut (ou derniere,)
-// Ou un nombre de l'enumération BUTTON_NUMBERS pour l'aide contextuelle.
+// Ouvre l'ecran d'aide. Passer -1 pour la section par dÃ©faut (ou derniere,)
+// Ou un nombre de l'enumÃ©ration BUTTON_NUMBERS pour l'aide contextuelle.
 void Window_help(int section, const char *sub_section)
 {
   short clicked_button;
@@ -443,7 +443,7 @@
 
   Open_window(310,175,"Help / About...");
 
-  // dessiner de la fenêtre où va défiler le texte
+  // dessiner de la fenÃªtre oÃ¹ va dÃ©filer le texte
   Window_display_frame_in(8,17,274,132);
   Block(Window_pos_X+(Menu_factor_X*9),
         Window_pos_Y+(Menu_factor_Y*18),
@@ -490,7 +490,7 @@
                 case 'K':
                   Window_set_shortcut(Help_section[Current_help_section].Help_table[Help_position+line].Line_parameter);
                 break;
-                // Ici on peut gérer un cas 'lien hypertexte'
+                // Ici on peut gÃ©rer un cas 'lien hypertexte'
                 default:
                 break;
               }
@@ -521,7 +521,7 @@
     }
 
 
-    // Gestion des touches de déplacement dans la liste
+    // Gestion des touches de dÃ©placement dans la liste
     switch (Key)
     {
       case SDLK_UP : // Haut
@@ -620,7 +620,7 @@
 
   Window_set_normal_button(120,153,70,14,"OK",0,1,KEY_ESC); // 1
 
-  // Affichage du numéro de version
+  // Affichage du numÃ©ro de version
   Print_in_window(10,19,"Program version:",STATS_TITLE_COLOR,MC_Black);
   sprintf(buffer,"%s.%s",Program_version, SVN_revision);
   Print_in_window(146,19,buffer,STATS_DATA_COLOR,MC_Black);
@@ -628,7 +628,7 @@
   Print_in_window(146,35,TrueType_is_supported()?"TTF fonts":"no TTF fonts",STATS_DATA_COLOR,MC_Black);
 
 
-  // Affichage de la mémoire restante
+  // Affichage de la mÃ©moire restante
   Print_in_window(10,51,"Free memory: ",STATS_TITLE_COLOR,MC_Black);
 
   freeRam = Memory_free();
@@ -663,7 +663,7 @@
       GetDiskFreeSpaceEx(Main_current_directory,&tailleU,NULL,NULL);
       mem_size = tailleU.QuadPart;
     }
-#elif defined(__linux__) || defined(__macosx__) || defined(__FreeBSD__)
+#elif defined(__linux__) || defined(__macosx__) || defined(__FreeBSD__) || defined(FDOS)
     // Note: under MacOSX, both macros are defined anyway.
     {
       struct statfs disk_info;
@@ -694,13 +694,13 @@
   sprintf(buffer,"%dx%d",Main_image_width,Main_image_height);
   Print_in_window(122,91,buffer,STATS_DATA_COLOR,MC_Black);
 
-  // Affichage du nombre de couleur utilisé
+  // Affichage du nombre de couleur utilisÃ©
   Print_in_window(18,99,"Colors used:",STATS_TITLE_COLOR,MC_Black);
   memset(color_usage,0,sizeof(color_usage));
   sprintf(buffer,"%d",Count_used_colors(color_usage));
   Print_in_window(122,99,buffer,STATS_DATA_COLOR,MC_Black);
 
-  // Affichage des dimensions de l'écran
+  // Affichage des dimensions de l'Ã©cran
   Print_in_window(10,115,"Resolution:",STATS_TITLE_COLOR,MC_Black);
   sprintf(buffer,"%dx%d",Screen_width,Screen_height);
   Print_in_window(106,115,buffer,STATS_DATA_COLOR,MC_Black);
diff -ruN gfx2orig/src/helpfile.h grafx2/src/helpfile.h
--- gfx2orig/src/helpfile.h	2010-03-22 04:36:40.000000000 -0500
+++ grafx2/src/helpfile.h	2022-03-20 20:19:34.108495316 -0500
@@ -198,8 +198,8 @@
   HELP_LINK ("Restore brush:       %s",   0x200+BUTTON_BRUSH)
   HELP_LINK ("Flip brush X:        %s",   SPECIAL_FLIP_X)
   HELP_LINK ("Flip brush Y:        %s",   SPECIAL_FLIP_Y)
-  HELP_LINK ("90° brush rotation:  %s",   SPECIAL_ROTATE_90)
-  HELP_LINK ("180° brush rotation: %s",   SPECIAL_ROTATE_180)
+  HELP_LINK ("90\xB0 brush rotation:  %s",SPECIAL_ROTATE_90)
+  HELP_LINK ("180\xB0 brush rotation: %s",SPECIAL_ROTATE_180)
   HELP_LINK ("Stretch brush:       %s",   SPECIAL_STRETCH)
   HELP_LINK ("Distort brush:       %s",   SPECIAL_DISTORT)
   HELP_LINK ("Outline brush:       %s",   SPECIAL_OUTLINE)
@@ -398,7 +398,8 @@
   HELP_BOLD ("           LINUX BINARIES")
   HELP_TEXT ("")
   HELP_TEXT ("  Gentoo : Matteo 'Peach' Pescarin")
-  HELP_TEXT ("  Debian : Gürkan Sengün")
+//  HELP_TEXT ("  Debian : GÃ¼rkan SengÃ¼n")
+  HELP_TEXT ("  Debian : Gurkan Sengun")
   HELP_TEXT ("")
   HELP_BOLD ("               MAC OS X PORT")
   HELP_TEXT ("")
@@ -422,7 +423,8 @@
   HELP_TEXT ("  anibiqme      blumunkee     BDCIron       ")
   HELP_TEXT ("  Ced           DawnBringer   El Topo       ")
   HELP_TEXT ("  falenblood    fano          fogbot121     ")
-  HELP_TEXT ("  Frost         Grimmy        Gürkan Sengün ")
+  //HELP_TEXT ("  Frost         Grimmy        GÃ¼rkan SengÃ¼n ")
+  HELP_TEXT ("  Frost         Grimmy        Gurkan Sengun ")
   HELP_TEXT ("  Hatch         HoraK-FDF     iLKke         ")
   HELP_TEXT ("  Iw2evk        Jamon         keito         ")
   HELP_TEXT ("  kusma         Lord Graga    lorenzo gatti ")
@@ -430,7 +432,8 @@
   HELP_TEXT ("  MooZ          Pasi Kallinen the Peach     ")
   HELP_TEXT ("  petter        richienyhus   tape.wyrm     ")
   HELP_TEXT ("  TeeEmCee      tempest       Timo Kurrpa   ")
-  HELP_TEXT ("  titus^Rab     Tobé          yakumo9275    ")
+//  HELP_TEXT ("  titus^Rab     TobÃ©          yakumo9275    ")
+  HELP_TEXT ("  titus^Rab     Tobe          yakumo9275    ")
   HELP_TEXT ("  00ai99")
   HELP_TEXT ("")
   HELP_TEXT ("  ... posted the annoying bug reports.")
@@ -477,7 +480,8 @@
   HELP_TEXT ("  Acryl         Fred          Prowler")
   HELP_TEXT ("  Alexel        FreddyV       Puznik")
   HELP_TEXT ("  Alias         Frost         Quick")
-  HELP_TEXT ("  Amiral        Gaël(GDC)     Ra")
+//  HELP_TEXT ("  Amiral        GaÃ«l(GDC)     Ra")
+  HELP_TEXT ("  Amiral        Gael(GDC)     Ra")
   HELP_TEXT ("  Arrakis       GainX         Raster")
   HELP_TEXT ("  Avocado       Gandalf       Ravian")
   HELP_TEXT ("  Baloo         Goblin        RedBug")
@@ -488,10 +492,12 @@
   HELP_TEXT ("  BlackAxe      Haplo         Sam")
   HELP_TEXT ("  Bonnie        Hof           SandMan")
   HELP_TEXT ("  Boo           Hornet        Scape")
-  HELP_TEXT ("  Boz           Hulud         Sébastien")
+  // HELP_TEXT ("  Boz           Hulud         SÃ©bastien")
+  HELP_TEXT ("  Boz           Hulud         Sebastien")
   HELP_TEXT ("  Carine        Java          Shodan")
   HELP_TEXT ("  Chandra       JBT           Skal")
-  HELP_TEXT ("  Cheetah       Jérôme        Skyfire")
+//  HELP_TEXT ("  Cheetah       JÃ©rÃ´me        Skyfire")
+  HELP_TEXT ("  Cheetah       Jerome        Skyfire")
   HELP_TEXT ("  Chill         Julien(JCA)   Sphair")
   HELP_TEXT ("  Cougar        KalMinDo      Sprocket")
   HELP_TEXT ("  Cremax        KaneWood      Stef")
@@ -706,7 +712,8 @@
   HELP_TEXT ("")
   HELP_TEXT ("In 'Ratio' mode, you can set 2 numbers for")
   HELP_TEXT ("each dimension, and the resizing factor will")
-  HELP_TEXT ("be of 'new'÷'old'. For example you can use")
+  //HELP_TEXT ("be of 'new'Ã·'old'. For example you can use")
+  HELP_TEXT ("be of 'new'\xF7'old'. For example you can use")
   HELP_TEXT ("1:3 to divide the image by three, 2:1 to")
   HELP_TEXT ("double it, and any fraction like 15:16.")
   HELP_TEXT ("")
@@ -723,12 +730,12 @@
   HELP_TEXT ("")
   HELP_BOLD ("ROTATE")
   HELP_TEXT ("")
-  HELP_TEXT ("-90°: Rotates the image by 90°")
+  HELP_TEXT ("-90\xB0: Rotates the image by 90\xB0")
   HELP_TEXT ("      clockwise.")
   HELP_TEXT ("")
-  HELP_TEXT ("+90°: Rotates the image by 90°")
+  HELP_TEXT ("+90\xB0: Rotates the image by 90\xB0")
   HELP_TEXT ("      counter-clockwise.")
-  HELP_TEXT ("180°: Rotates the image by 180°")
+  HELP_TEXT ("180\xB0: Rotates the image by 180\xB0")
   HELP_TEXT ("")
   HELP_TEXT ("")
 };
@@ -1193,10 +1200,10 @@
   HELP_LINK ("- Y: (Key:%s)",SPECIAL_FLIP_Y)
   HELP_TEXT ("Flip vertically.")
   HELP_TEXT ("")
-  HELP_LINK ("- Rotate by 90°: (Key:%s)",SPECIAL_ROTATE_90)
+  HELP_LINK ("- Rotate by 90\xB0: (Key:%s)",SPECIAL_ROTATE_90)
   HELP_TEXT ("Rotates the brush by an angle of 90 degrees.")
   HELP_TEXT ("")
-  HELP_LINK ("- Rotate by 180°: (Key:%s)",SPECIAL_ROTATE_180)
+  HELP_LINK ("- Rotate by 180\xB0: (Key:%s)",SPECIAL_ROTATE_180)
   HELP_TEXT ("Rotates the brush by an angle of 180")
   HELP_TEXT ("degrees.")
   HELP_TEXT ("")
diff -ruN gfx2orig/src/hotkeys.c grafx2/src/hotkeys.c
--- gfx2orig/src/hotkeys.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/hotkeys.c	2022-03-20 20:19:34.108495316 -0500
@@ -638,17 +638,17 @@
   SDLK_y, // Y
   0},
   {72,
-  "90° brush rotation",
-  "Rotate the user-defined brush by 90°",
+  "90\xB0 brush rotation",
+  "Rotate the user-defined brush by 90\xB0",
   "(counter-clockwise).",
   "",
   true,
   SDLK_z, // Z (W en AZERTY)
   0},
   {73,
-  "180° brush rotation",
+  "180\xB0 brush rotation",
   "Rotate the user-defined brush by",
-  "180°.",
+  "180\xB0.",
   "",
   true,
   SDLK_z|MOD_SHIFT, // Shift + Z
@@ -715,7 +715,7 @@
   "pixel in the picture into the",
   "foreground or background color.",
   true,
-  SDLK_BACKQUOTE, // `~ (Key sous le Esc - ² en AZERTY)
+  SDLK_BACKQUOTE, // `~ (Key sous le Esc - en AZERTY)
   0},
   {82,
   "Swap foreground/background colors",
@@ -987,7 +987,7 @@
   "user-defined brush to its center.",
   "",
   true,
-  SDLK_KP5|MOD_CTRL, // Ctrl + 5 (pavé numérique)
+  SDLK_KP5|MOD_CTRL, // Ctrl + 5 (pav numrique)
   0},
   {113,
   "Top-left brush attachment point",
@@ -1067,7 +1067,7 @@
   "previous in the user-defined color",
   "series.",
   true,
-  SDLK_MINUS, // "-_" (")°" en AZERTY
+  SDLK_MINUS, // "-_" (")" en AZERTY
   0},
   {128,
   "Next user-defined backcolor",
@@ -1083,7 +1083,7 @@
   "previous in the user-defined color",
   "series.",
   true,
-  SDLK_MINUS|MOD_SHIFT, // Shift + "-_" (")°" en AZERTY
+  SDLK_MINUS|MOD_SHIFT, // Shift + "-_" (")" en AZERTY
   0},
   {121,
   "Shrink paintbrush",
@@ -1513,8 +1513,8 @@
   0x200+BUTTON_AIRBRUSH,            // Spray menu
   0x100+BUTTON_FLOODFILL,           // Floodfill
   0x200+BUTTON_FLOODFILL,           // Replace color
-  0x100+BUTTON_CURVES,              // Bézier's curves
-  0x200+BUTTON_CURVES,              // Bézier's curve with 3 or 4 points
+  0x100+BUTTON_CURVES,              // Bezier's curves
+  0x200+BUTTON_CURVES,              // Bezier's curve with 3 or 4 points
   0x100+BUTTON_RECTANGLES,          // Empty rectangle
   0x100+BUTTON_FILLRECT,            // Filled rectangle
   0x100+BUTTON_CIRCLES,             // Empty circle
@@ -1557,8 +1557,8 @@
   0x200+BUTTON_BRUSH,               // Restore brush
   SPECIAL_FLIP_X,                   // Flip X
   SPECIAL_FLIP_Y,                   // Flip Y
-  SPECIAL_ROTATE_90,                // 90° brush rotation
-  SPECIAL_ROTATE_180,               // 180° brush rotation
+  SPECIAL_ROTATE_90,                // 90 brush rotation
+  SPECIAL_ROTATE_180,               // 180 brush rotation
   SPECIAL_STRETCH,                  // Stretch brush
   SPECIAL_DISTORT,                  // Distort brush
   SPECIAL_OUTLINE,                  // Outline brush
diff -ruN gfx2orig/src/init.c grafx2/src/init.c
--- gfx2orig/src/init.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/init.c	2022-03-20 20:19:34.112495316 -0500
@@ -252,8 +252,8 @@
   int i,j;
   int cursor_x=0,cursor_y=0;
   byte color;
-  byte neutral_color; // color neutre utilisée pour délimiter les éléments GUI
-  int char_1=0;  // Indices utilisés pour les 4 "fontes" qui composent les
+  byte neutral_color; // color neutre utilisÃ©e pour dÃ©limiter les Ã©lÃ©ments GUI
+  int char_1=0;  // Indices utilisÃ©s pour les 4 "fontes" qui composent les
   int char_2=0;  // grands titres de l'aide. Chaque indice avance dans 
   int char_3=0;  // l'une des fontes dans l'ordre :  1 2
   int char_4=0;  //                                  3 4
@@ -275,7 +275,7 @@
   // Read the default palette
   Get_SDL_Palette(SDLPal, gfx->Default_palette);
 
-  // Carré "noir"
+  // CarrÃ© "noir"
   gfx->Color_black = Get_SDL_pixel_8(gui,cursor_x,cursor_y);
   do
   {
@@ -286,7 +286,7 @@
     }
     color=Get_SDL_pixel_8(gui,cursor_x,cursor_y);
   } while(color==gfx->Color_black);
-  // Carré "foncé"
+  // CarrÃ© "foncÃ©"
   gfx->Color_dark = color;
   do
   {
@@ -297,7 +297,7 @@
     }
     color=Get_SDL_pixel_8(gui,cursor_x,cursor_y);
   } while(color==gfx->Color_dark);
-  // Carré "clair"
+  // CarrÃ© "clair"
   gfx->Color_light = color;
   do
   {
@@ -308,7 +308,7 @@
     }
     color=Get_SDL_pixel_8(gui,cursor_x,cursor_y);
   } while(color==gfx->Color_light);
-  // Carré "blanc"
+  // CarrÃ© "blanc"
   gfx->Color_white = color;
   do
   {
@@ -319,7 +319,7 @@
     }
     color=Get_SDL_pixel_8(gui,cursor_x,cursor_y);
   } while(color==gfx->Color_white);
-  // Carré "transparent"
+  // CarrÃ© "transparent"
   gfx->Color_trans=color;
   do
   {
@@ -974,7 +974,7 @@
                        0);
   }
 
-  // Ici viennent les déclarations des boutons que l'on sait gérer
+  // Ici viennent les dÃ©clarations des boutons que l'on sait gÃ©rer
 
   Init_button(BUTTON_PAINTBRUSHES,
                      0,1,
@@ -1297,7 +1297,7 @@
 
   Init_button(BUTTON_CHOOSE_COL,
                      MENU_WIDTH+1,2,
-                     1,32, // La largeur est mise à jour à chq chngmnt de mode
+                     1,32, // La largeur est mise Ã  jour Ã  chq chngmnt de mode
                      BUTTON_SHAPE_NO_FRAME,
                      Button_Select_forecolor,Button_Select_backcolor,
                      0,0,
@@ -1382,9 +1382,9 @@
 
 
 
-// Initialisation des opérations:
+// Initialisation des opÃ©rations:
 
-  // Initialiseur d'une opération:
+  // Initialiseur d'une opÃ©ration:
 
 void Init_operation(byte operation_number,
                            byte mouse_button,
@@ -1402,17 +1402,17 @@
 }
 
 
-  // Initiliseur de toutes les opérations:
+  // Initiliseur de toutes les opÃ©rations:
 
 void Init_operations(void)
 {
-  byte number; // Numéro de l'option en cours d'auto-initialisation
+  byte number; // NumÃ©ro de l'option en cours d'auto-initialisation
   byte Button; // Button souris en cours d'auto-initialisation
   byte stack_index; // Taille de la pile en cours d'auto-initialisation
   #define HIDE_CURSOR 1
   #define FAST_MOUSE 1
 
-  // Auto-initialisation des opérations (vers des actions inoffensives)
+  // Auto-initialisation des opÃ©rations (vers des actions inoffensives)
 
   for (number=0;number<NB_OPERATIONS;number++)
     for (Button=0;Button<3;Button++)
@@ -1420,7 +1420,7 @@
         Init_operation(number,Button,stack_index,Print_coordinates,0,FAST_MOUSE);
 
 
-  // Ici viennent les déclarations détaillées des opérations
+  // Ici viennent les dÃ©clarations dÃ©taillÃ©es des opÃ©rations
   Init_operation(OPERATION_CONTINUOUS_DRAW,1,0,
                         Freehand_mode1_1_0,HIDE_CURSOR,0);
   Init_operation(OPERATION_CONTINUOUS_DRAW,1,2,
@@ -1800,9 +1800,9 @@
 
 
 
-//-- Définition des modes vidéo: --------------------------------------------
+//-- DÃ©finition des modes vidÃ©o: --------------------------------------------
 
-  // Définition d'un mode:
+  // DÃ©finition d'un mode:
 
 void Set_video_mode(short  width,
                         short  height,
@@ -1834,7 +1834,7 @@
   Nb_video_modes ++;
 }
 
-// Utilisé pour trier les modes retournés par SDL
+// UtilisÃ© pour trier les modes retournÃ©s par SDL
 int Compare_video_modes(const void *p1, const void *p2)
 {
   const T_Video_mode *mode1 = (const T_Video_mode *)p1;
@@ -1998,7 +1998,7 @@
     && (cfg_header.Version2== 0)
     && (cfg_header.Beta1== 96))
   {
-    // Les touches (scancodes) sont à convertir)
+    // Les touches (scancodes) sont Ã  convertir)
     key_conversion = 1;
   }
   // Version SDL jusqu'a 98%
@@ -2077,7 +2077,7 @@
             goto Erreur_lecture_config;
         }
         break;
-      case CHUNK_VIDEO_MODES: // Modes vidéo
+      case CHUNK_VIDEO_MODES: // Modes vidÃ©o
         for (index=0; index<(long)(Chunk.Size/sizeof(cfg_video_mode)); index++)
         {
           if (!Read_byte(Handle, &cfg_video_mode.State) ||
@@ -2095,9 +2095,9 @@
             if (Video_mode[index2].Width==cfg_video_mode.Width &&
                 Video_mode[index2].Height==cfg_video_mode.Height)
             {
-              // On ne prend le paramètre utilisateur que si la résolution
-              // est effectivement supportée par SDL
-              // Seules les deux petits bits sont récupérés, car les anciens fichiers
+              // On ne prend le paramÃ¨tre utilisateur que si la rÃ©solution
+              // est effectivement supportÃ©e par SDL
+              // Seules les deux petits bits sont rÃ©cupÃ©rÃ©s, car les anciens fichiers
               // de configuration (DOS 96.5%) utilisaient d'autres bits.
               if (! (Video_mode[index2].State & 128))
                 Video_mode[index2].State=cfg_video_mode.State&3;
@@ -2158,7 +2158,7 @@
             goto Erreur_lecture_config;
         }
         break;
-      case CHUNK_GRADIENTS: // Infos sur les dégradés
+      case CHUNK_GRADIENTS: // Infos sur les dÃ©gradÃ©s
         if (reload_all)
         {
           if (! Read_byte(Handle, &Current_gradient))
@@ -2319,7 +2319,7 @@
       goto Erreur_sauvegarde_config;
   }
 
-  // D'abord compter les modes pour lesquels l'utilisateur a mis une préférence
+  // D'abord compter les modes pour lesquels l'utilisateur a mis une prÃ©fÃ©rence
   modes_to_save=0;
 #if defined(__GP2X__)
   index = 0;
@@ -2330,7 +2330,7 @@
     if (Video_mode[index].State==0 || Video_mode[index].State==2 || Video_mode[index].State==3)
       modes_to_save++;
 
-  // Sauvegarde de l'état de chaque mode vidéo
+  // Sauvegarde de l'Ã©tat de chaque mode vidÃ©o
   Chunk.Number=CHUNK_VIDEO_MODES;
   Chunk.Size=modes_to_save * sizeof(cfg_video_mode);
 
@@ -2355,7 +2355,7 @@
         goto Erreur_sauvegarde_config;
     }
 
-  // Ecriture des données du Shade (précédées du shade en cours)
+  // Ecriture des donnÃ©es du Shade (prÃ©cÃ©dÃ©es du shade en cours)
   Chunk.Number=CHUNK_SHADE;
   Chunk.Size=sizeof(Shade_list)+sizeof(Shade_current);
   if (!Write_byte(Handle, Chunk.Number) ||
@@ -2393,7 +2393,7 @@
   if (!Write_bytes(Handle, Stencil,256))
     goto Erreur_sauvegarde_config;
 
-  // Sauvegarde des informations des dégradés
+  // Sauvegarde des informations des dÃ©gradÃ©s
   Chunk.Number=CHUNK_GRADIENTS;
   Chunk.Size=sizeof(Gradient_array)+1;
   if (!Write_byte(Handle, Chunk.Number) ||
@@ -2422,7 +2422,7 @@
       if (!Write_byte(Handle, Smooth_matrix[index][index2]))
         goto Erreur_sauvegarde_config;
 
-  // Sauvegarde des couleurs à exclure
+  // Sauvegarde des couleurs Ã  exclure
   Chunk.Number=CHUNK_EXCLUDE_COLORS;
   Chunk.Size=sizeof(Exclude_color);
   if (!Write_byte(Handle, Chunk.Number) ||
@@ -2468,7 +2468,7 @@
   return ERROR_SAVING_CFG;
 }
 
-// (Ré)assigne toutes les valeurs de configuration par défaut
+// (RÃ©)assigne toutes les valeurs de configuration par dÃ©faut
 void Set_config_defaults(void)
 {
   int index, index2;
@@ -2501,7 +2501,7 @@
     for (index2=0; index2<512; index2++)
       Shade_list[index].List[index2]=256;
   }
-  // Shade par défaut pour la palette standard
+  // Shade par dÃ©faut pour la palette standard
   for (index=0; index<7; index++)
     for (index2=0; index2<16; index2++)
       Shade_list[0].List[index*17+index2]=index*16+index2+16;
@@ -2519,7 +2519,7 @@
   for (index=0; index<256; index++)
     Stencil[index]=1;
 
-  // Dégradés
+  // DÃ©gradÃ©s
   Current_gradient=0;
   for(index=0;index<16;index++)
   {
diff -ruN gfx2orig/src/input.c grafx2/src/input.c
--- gfx2orig/src/input.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/input.c	2022-03-20 20:19:34.108495316 -0500
@@ -133,7 +133,7 @@
       Input_new_mouse_X=Screen_width-1;
       mouse_blocked=1;
   }
-  //Gestion "avancée" du curseur: interdire la descente du curseur dans le
+  //Gestion "avancÃ©e" du curseur: interdire la descente du curseur dans le
   //menu lorsqu'on est en train de travailler dans l'image
   if (Operation_stack_size != 0)
   {
@@ -191,6 +191,9 @@
     {
       Mouse_X=Input_new_mouse_X;
       Mouse_Y=Input_new_mouse_Y;
+#if defined(FDOS)
+      SDL_WarpMouse(Mouse_X, Mouse_Y);
+#endif
     }
     Mouse_K=Input_new_mouse_K;
     
@@ -494,7 +497,7 @@
     }
     #endif
     Key = (KEY_JOYBUTTON+event.button)|Key_modifiers(SDL_GetModState());
-    // TODO: systeme de répétition
+    // TODO: systeme de rï¿½pï¿½tition
     
     return Move_cursor_with_constraints();
 }
@@ -622,7 +625,7 @@
 int Get_input(void)
 {
     SDL_Event event;
-    int user_feedback_required = 0; // Flag qui indique si on doit arrêter de traiter les évènements ou si on peut enchainer
+    int user_feedback_required = 0; // Flag qui indique si on doit arrÃªter de traiter les Ã©vÃ¨nements ou si on peut enchainer
                 
     Key_ANSI = 0;
     Key = 0;
@@ -637,6 +640,7 @@
     {
         switch(event.type)
         {
+#if !defined(FDOS)
             case SDL_VIDEORESIZE:
                 Handle_window_resize(event.resize);
                 user_feedback_required = 1;
@@ -646,6 +650,7 @@
                 Handle_window_exit(event.quit);
                 user_feedback_required = 1;
                 break;
+#endif
 
             case SDL_MOUSEMOTION:
                 user_feedback_required = Handle_mouse_move(event.motion);
diff -ruN gfx2orig/src/io.c grafx2/src/io.c
--- gfx2orig/src/io.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/io.c	2022-03-20 20:19:34.112495316 -0500
@@ -20,7 +20,7 @@
     along with Grafx2; if not, see <http://www.gnu.org/licenses/>
 */
 
-// Fonctions de lecture/ecriture file, gèrent les systèmes big-endian et
+// Fonctions de lecture/ecriture file, gÃ¨rent les systÃ¨mes big-endian et
 // little-endian.
 
 #define _XOPEN_SOURCE 500
@@ -153,10 +153,10 @@
   return fwrite(&dw, 1, sizeof(dword), file) == sizeof(dword);
 }
 
-// Détermine la position du dernier '/' ou '\\' dans une chaine,
-// typiquement pour séparer le nom de file d'un chemin.
+// DÃ©termine la position du dernier '/' ou '\\' dans une chaine,
+// typiquement pour sÃ©parer le nom de file d'un chemin.
 // Attention, sous Windows, il faut s'attendre aux deux car 
-// par exemple un programme lancé sous GDB aura comme argv[0]:
+// par exemple un programme lancÃ© sous GDB aura comme argv[0]:
 // d:\Data\C\GFX2\grafx2/grafx2.exe
 char * Find_last_slash(const char * str)
 {
@@ -170,7 +170,7 @@
       position = str;
   return (char *)position;
 }
-// Récupère la partie "nom de file seul" d'un chemin
+// RÃ©cupÃ¨re la partie "nom de file seul" d'un chemin
 void Extract_filename(char *dest, const char *source)
 {
   const char * position = Find_last_slash(source);
@@ -180,7 +180,7 @@
   else
     strcpy(dest,source);
 }
-// Récupère la partie "répertoire+/" d'un chemin.
+// RÃ©cupÃ¨re la partie "rÃ©pertoire+/" d'un chemin.
 void Extract_path(char *dest, const char *source)
 {
   char * position=NULL;
@@ -194,8 +194,8 @@
 }
 
 int File_exists(char * fname)
-//   Détermine si un file passé en paramètre existe ou non dans le
-// répertoire courant.
+//   DÃ©termine si un file passÃ© en paramÃ¨tre existe ou non dans le
+// rÃ©pertoire courant.
 {
     struct stat buf;
     int result;
@@ -208,17 +208,17 @@
 
 }
 int Directory_exists(char * directory)
-//   Détermine si un répertoire passé en paramètre existe ou non dans le
-// répertoire courant.
+//   DÃ©termine si un rÃ©pertoire passÃ© en paramÃ¨tre existe ou non dans le
+// rÃ©pertoire courant.
 {
-  DIR* entry;    // Structure de lecture des éléments
+  DIR* entry;    // Structure de lecture des Ã©lÃ©ments
 
   if (strcmp(directory,PARENT_DIR)==0)
     return 1;
   else
   {
-    //  On va chercher si le répertoire existe à l'aide d'un Opendir. S'il
-    //  renvoie NULL c'est que le répertoire n'est pas accessible...
+    //  On va chercher si le rÃ©pertoire existe Ã  l'aide d'un Opendir. S'il
+    //  renvoie NULL c'est que le rÃ©pertoire n'est pas accessible...
 
     entry=opendir(directory);
     if (entry==NULL)
@@ -249,14 +249,14 @@
 
 void For_each_file(const char * directory_name, void Callback(const char *))
 {
-  // Pour scan de répertoire
-  DIR*  current_directory; //Répertoire courant
-  struct dirent* entry; // Structure de lecture des éléments
+  // Pour scan de rÃ©pertoire
+  DIR*  current_directory; //RÃ©pertoire courant
+  struct dirent* entry; // Structure de lecture des Ã©lÃ©ments
   char full_filename[MAX_PATH_CHARACTERS];
   int filename_position;
   strcpy(full_filename, directory_name);
   current_directory=opendir(directory_name);
-  if(current_directory == NULL) return;        // Répertoire invalide ...
+  if(current_directory == NULL) return;        // RÃ©pertoire invalide ...
   filename_position = strlen(full_filename);
   if (filename_position==0 || strcmp(full_filename+filename_position-1,PATH_SEPARATOR))
   {
@@ -326,12 +326,15 @@
     // Usually write-protected media
     return -1;
   }
+#if !defined(FDOS)
+  // Lock file is useless on DOS.
   if (lockf(Lock_file_handle, F_TLOCK, 0)==-1)
   {
     close(Lock_file_handle);
     // Usually write-protected media
     return -1;
   }
+#endif
   #endif
   return 0;
 }
diff -ruN gfx2orig/src/io.h grafx2/src/io.h
--- gfx2orig/src/io.h	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/io.h	2022-03-20 20:19:34.112495316 -0500
@@ -33,6 +33,10 @@
 /// If you don't, you break another platform.
 //////////////////////////////////////////////////////////////////////////////
 
+#if defined(FDOS)
+#include <stdio.h>
+#endif
+
 /// Reads a single byte from an open file. Returns true if OK, false if a file i/o error occurred.
 int Read_byte(FILE *file, byte *dest);
 /// Writes a single byte to an open file. Returns true if OK, false if a file i/o error occurred.
diff -ruN gfx2orig/src/keyboard.c grafx2/src/keyboard.c
--- gfx2orig/src/keyboard.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/keyboard.c	2022-03-20 20:19:34.108495316 -0500
@@ -331,7 +331,7 @@
   word key_code = 0;
   word mod;
 
-  // On ignore shift, alt et control isolés.
+  // On ignore shift, alt et control isols.
   if (keysym.sym == SDLK_RSHIFT || keysym.sym == SDLK_LSHIFT ||
       keysym.sym == SDLK_RCTRL  || keysym.sym == SDLK_LCTRL ||
       keysym.sym == SDLK_RALT   || keysym.sym == SDLK_LALT ||
@@ -339,8 +339,8 @@
       keysym.sym == SDLK_MODE) // AltGr
   return 0;
   
-  // Les touches qui n'ont qu'une valeur unicode (très rares)
-  // seront codées sur 11 bits, le 12e bit est mis à 1 (0x0800)
+  // Les touches qui n'ont qu'une valeur unicode (tres rares)
+  // seront codes sur 11 bits, le 12e bit est mis  1 (0x0800)
   if (keysym.sym != 0)
     key_code = keysym.sym;
   else if (keysym.scancode != 0)
@@ -519,7 +519,7 @@
     return buffer;
   }
                              
-  // Touches au libellé connu
+  // Touches au libell connu
   for (index=0; index < (long)sizeof(key_labels)/(long)sizeof(T_key_label);index++)
   {
     if (Key == key_labels[index].keysym)
@@ -534,9 +534,9 @@
 
 }
 
-// Obtient le caractère ANSI tapé, à partir d'un keysym.
-// (Valeur 32 à 255)
-// Renvoie 0 s'il n'y a pas de caractère associé (shift, backspace, etc)
+// Obtient le caractre ANSI tap,  partir d'un keysym.
+// (Valeur 32  255)
+// Renvoie 0 s'il n'y a pas de caractre associ (shift, backspace, etc)
 word Keysym_to_ANSI(SDL_keysym keysym)
 {
   // This part was removed from the MacOSX port, but I put it back for others
@@ -567,66 +567,68 @@
     return keysym.unicode; // Pas de souci, on est en ASCII standard
   }
   
+#if !defined(FDOS)
   // Quelques conversions Unicode-ANSI
   switch(keysym.unicode)
   {
     case 0x8100:
-      return 'ü'; // ü
+      return ' '; // 
     case 0x1A20:
-      return 'é'; // é
+      return ' '; // 
     case 0x201A:
-      return 'è'; // è
+      return ' '; // 
     case 0x9201:
-      return 'â'; // â
+      return ' '; // 
     case 0x1E20:
-      return 'ä'; // ä
+      return ' '; // 
     case 0x2620:
-      return 'à'; // à
+      return ' '; // 
     case 0x2020: 
-      return 'å'; // å
+      return ' '; // 
     case 0x2120: 
-      return 'ç'; // ç
+      return ' '; // 
     case 0xC602: 
-      return 'ê'; // ê
+      return ' '; // 
     case 0x3020: 
-      return 'ë'; // ë
+      return ' '; // 
     case 0x6001: 
-      return 'è'; // è
+      return ' '; // 
     case 0x3920: 
-      return 'ï'; // ï
+      return ' '; // 
     case 0x5201: 
-      return 'î'; // î
+      return ' '; // 
     case 0x8D00: 
-      return 'ì'; // ì
+      return ' '; // 
     case 0x1C20: 
-      return 'ô'; // ô
+      return ' '; // 
     case 0x1D20: 
-      return 'ö'; // ö
+      return ' '; // 
     case 0x2220: 
-      return 'ò'; // ò
+      return ' '; // 
     case 0x1320: 
-      return 'û'; // û
+      return ' '; // 
     case 0x1420: 
-      return 'ù'; // ù
+      return ' '; // 
     case 0xDC02: 
-      return 'ÿ'; // ÿ
+      return ' '; // 
     case 0x5301: 
-      return '£'; // £
+      return ' '; // 
     case 0xA000: 
-      return 'á'; // á
+      return ' '; // 
     case 0xA100: 
-      return 'í'; // í
+      return ' '; // 
     case 0xA200: 
-      return 'ó'; // ó
+      return ' '; // 
     case 0xA300: 
-      return 'ú'; // ú
+      return ' '; // 
     case 0xA400: 
-      return 'ñ'; // ñ
+      return ' '; // 
     case 0xA700: 
-      return 'º'; // º
+      return ' '; // 
     case 0xC600: 
-      return 'ã'; // ã
+      return ' '; // 
   }
+#endif
   
   // Key entre 127 et 255
   if (keysym.unicode<256)
@@ -647,6 +649,6 @@
     return keysym.unicode;
   }
 
- // Sinon c'est une touche spéciale, on retourne son scancode
+ // Sinon c'est une touche spciale, on retourne son scancode
   return keysym.sym;
 }
diff -ruN gfx2orig/src/layers.c grafx2/src/layers.c
--- gfx2orig/src/layers.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/layers.c	2022-03-20 20:19:34.108495316 -0500
@@ -19,6 +19,9 @@
     You should have received a copy of the GNU General Public License
     along with Grafx2; if not, see <http://www.gnu.org/licenses/>
 */
+#if defined(FDOS)
+#include <stddef.h> // NULL
+#endif
 #include "const.h"
 #include "struct.h"
 #include "global.h"
diff -ruN gfx2orig/src/layers.h grafx2/src/layers.h
--- gfx2orig/src/layers.h	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/layers.h	2022-03-20 20:19:34.108495316 -0500
@@ -19,6 +19,8 @@
     You should have received a copy of the GNU General Public License
     along with Grafx2; if not, see <http://www.gnu.org/licenses/>
 */
+#ifndef LAYERS_H
+#define LAYERS_H
 
 void Button_Layer_add(void);
 void Button_Layer_remove(void);
@@ -33,3 +35,4 @@
 void Layer_activate(byte layer, short side);
 
 
+#endif /* LAYERS_H */
diff -ruN gfx2orig/src/libraw2crtc.c grafx2/src/libraw2crtc.c
--- gfx2orig/src/libraw2crtc.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/libraw2crtc.c	2022-03-20 20:19:34.108495316 -0500
@@ -2,7 +2,7 @@
 */
 /* GFX2CRTC - libraw2crtc.c
  * CloudStrife - 20080921
- * Diffusé sous licence libre CeCILL v2
+ * DiffusÃ© sous licence libre CeCILL v2
  * Voire LICENCE
  */
 
@@ -66,7 +66,7 @@
   unsigned char minAddrIsDefined = 0;
   unsigned short maxAddr = 0;
 
-  unsigned char nbPixPerByte;
+  unsigned short nbPixPerByte = 0;
   int y,x;
   unsigned char r6;
   unsigned short i;
@@ -112,18 +112,22 @@
       exit(4);
     }
   }
+#if defined(FDOS)
+  // Silence 'assigned but not used' compiler warning.
+  (void)nbPixPerByte;
+#endif
 
   tmpBuffer = (unsigned char*)malloc(0xFFFF);
   if (tmpBuffer == NULL)
   {
-    printf("Allocation tmpBuffer raté\n");
+    printf("Allocation tmpBuffer ratÃ©\n");
     exit(4);
   }
 
   allocationBuffer = (unsigned char*)malloc(0xFFFF);
   if(allocationBuffer == NULL)
   {
-    printf("Allocation allocationBuffer raté\n");
+    printf("Allocation allocationBuffer ratÃ©\n");
     exit(4);
   }
   memset(allocationBuffer, 0, 0xFFFF);
@@ -151,7 +155,7 @@
   {
     if(*(allocationBuffer + i) > 1)
     {
-      printf("Attention : Ecriture multiple a l'adresse mémoire %d\n",i);
+      printf("Attention : Ecriture multiple a l'adresse mÃ©moire %d\n",i);
     }
     if(*(allocationBuffer + i) > 0)
     {
@@ -169,7 +173,7 @@
   outBuffer = (unsigned char*)malloc((*outSize));
   if (outBuffer == NULL)
   {
-    printf("Allocation outBuffer raté\n");
+    printf("Allocation outBuffer ratÃ©\n");
     exit(4);
   }
 
diff -ruN gfx2orig/src/libraw2crtc.h grafx2/src/libraw2crtc.h
--- gfx2orig/src/libraw2crtc.h	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/libraw2crtc.h	2022-03-20 20:19:34.108495316 -0500
@@ -2,7 +2,7 @@
 */
 /* GFX2CRTC - libraw2crtc.h
  * CloudStrife - 20080921
- * Diffusé sous licence libre CeCILL v2
+ * DiffusÃ© sous licence libre CeCILL v2
  * Voire LICENCE
  */
 
diff -ruN gfx2orig/src/loadsave.c grafx2/src/loadsave.c
--- gfx2orig/src/loadsave.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/loadsave.c	2022-03-20 20:19:34.112495316 -0500
@@ -166,7 +166,7 @@
     
   switch (context->Type)
   {
-    // Chargement des pixels dans l'écran principal
+    // Chargement des pixels dans l'Ã©cran principal
     case CONTEXT_MAIN_IMAGE:
       Pixel_in_current_screen(x_pos,y_pos,color,0);
       break;
@@ -266,7 +266,7 @@
         )
         
       {
-          // Si on charge une image monochrome, le fileselect ne sera plus visible. Dans ce cas on force quelques couleurs à des valeurs sures
+          // Si on charge une image monochrome, le fileselect ne sera plus visible. Dans ce cas on force quelques couleurs Ã  des valeurs sures
     
           int black =
               Main_palette[MC_Black].R +
@@ -354,12 +354,12 @@
 
 
 
-// Création d'une palette fake
+// CrÃ©ation d'une palette fake
 void Set_palette_fake_24b(T_Palette palette)
 {
   int color;
 
-  // Génération de la palette
+  // GÃ©nÃ©ration de la palette
   for (color=0;color<256;color++)
   {
     palette[color].R=((color & 0xE0)>>5)<<5;
@@ -387,8 +387,8 @@
   {
     // Preview
     case CONTEXT_PREVIEW:
-      // Préparation du chargement d'une preview:
-      // Affichage des données "Image size:"
+      // PrÃ©paration du chargement d'une preview:
+      // Affichage des donnÃ©es "Image size:"
       if ((width<10000) && (height<10000))
       {
         Num2str(width,str,4);
@@ -417,7 +417,7 @@
       }
       else
       {
-        // Le fichier fait plus de 100 Mega octets (cas très rare :))
+        // Le fichier fait plus de 100 Mega octets (cas trÃ¨s rare :))
         Print_in_window(236,59,"LARGE!!",MC_Black,MC_Light);
       }
   
@@ -427,13 +427,13 @@
         Print_in_window( 59,59,Get_fileformat(format)->Label,MC_Black,MC_Light);
       }
   
-      // On efface le commentaire précédent
+      // On efface le commentaire prÃ©cÃ©dent
       Window_rectangle(45,70,32*8,8,MC_Light);
       // Affichage du commentaire
       if (Get_fileformat(format)->Comment)
         Print_in_window(45,70,Main_comment,MC_Black,MC_Light);
   
-      // Calcul des données nécessaires à l'affichage de la preview:
+      // Calcul des donnÃ©es nÃ©cessaires Ã  l'affichage de la preview:
       if (ratio == PIXEL_WIDE && 
           Pixel_ratio != PIXEL_WIDE &&
           Pixel_ratio != PIXEL_WIDE2)
@@ -457,10 +457,10 @@
       context->Preview_pos_X=Window_pos_X+183*Menu_factor_X;
       context->Preview_pos_Y=Window_pos_Y+ 95*Menu_factor_Y;
   
-      // On nettoie la zone où va s'afficher la preview:
+      // On nettoie la zone oÃ¹ va s'afficher la preview:
       Window_rectangle(183,95,120,80,MC_Light);
       
-      // Un update pour couvrir les 4 zones: 3 libellés plus le commentaire
+      // Un update pour couvrir les 4 zones: 3 libellÃ©s plus le commentaire
       Update_window_area(45,48,256,30);
       // Zone de preview
       Update_window_area(183,95,120,80);
@@ -470,9 +470,9 @@
     case CONTEXT_MAIN_IMAGE:
       if (Backup_with_new_dimensions(0,1,width,height))
       {
-        // La nouvelle page a pu être allouée, elle est pour l'instant pleine
+        // La nouvelle page a pu Ãªtre allouÃ©e, elle est pour l'instant pleine
         // de 0s. Elle fait Main_image_width de large.
-        // Normalement tout va bien, tout est sous contrôle...
+        // Normalement tout va bien, tout est sous contrÃ´le...
         
         // Load into layer 0, by default.
         context->Nb_layers=1;
@@ -487,7 +487,7 @@
       else
       {
         // Afficher un message d'erreur
-        // Pour être sûr que ce soit lisible.
+        // Pour Ãªtre sÃ»r que ce soit lisible.
         Compute_optimal_menu_colors(context->Palette);
         Message_out_of_memory();
         File_error=1; // 1 => On n'a pas perdu l'image courante
@@ -553,7 +553,7 @@
 }
 
 /////////////////////////////////////////////////////////////////////////////
-//                    Gestion des lectures et écritures                    //
+//                    Gestion des lectures et Ã©critures                    //
 /////////////////////////////////////////////////////////////////////////////
 
 byte * Write_buffer;
@@ -588,12 +588,12 @@
 
 /////////////////////////////////////////////////////////////////////////////
 
-// -------- Modifier la valeur du code d'erreur d'accès à un fichier --------
-//   On n'est pas obligé d'utiliser cette fonction à chaque fois mais il est
+// -------- Modifier la valeur du code d'erreur d'accÃ¨s Ã  un fichier --------
+//   On n'est pas obligÃ© d'utiliser cette fonction Ã  chaque fois mais il est
 // important de l'utiliser dans les cas du type:
 //   if (!File_error) *** else File_error=***;
-// En fait, dans le cas où l'on modifie File_error alors qu'elle contient
-// dèjà un code d'erreur.
+// En fait, dans le cas oÃ¹ l'on modifie File_error alors qu'elle contient
+// dÃ¨jÃ  un code d'erreur.
 void Set_file_error(int value)
 {
   if (File_error>=0)
@@ -605,10 +605,10 @@
 void Load_image(T_IO_Context *context)
 {
   unsigned int index; // index de balayage des formats
-  T_Format *format = &(File_formats[2]); // Format du fichier à charger
+  T_Format *format = &(File_formats[2]); // Format du fichier Ã  charger
 
 
-  // On place par défaut File_error à vrai au cas où on ne sache pas
+  // On place par dÃ©faut File_error Ã  vrai au cas oÃ¹ on ne sache pas
   // charger le format du fichier:
   File_error=1;
 
@@ -621,8 +621,8 @@
 
   if (File_error)
   {
-    //  Sinon, on va devoir scanner les différents formats qu'on connait pour
-    // savoir à quel format est le fichier:
+    //  Sinon, on va devoir scanner les diffÃ©rents formats qu'on connait pour
+    // savoir Ã  quel format est le fichier:
     for (index=0; index < NB_KNOWN_FORMATS; index++)
     {
       format = Get_fileformat(index);
@@ -632,7 +632,7 @@
         
       // On appelle le testeur du format:
       format->Test(context);
-      // On s'arrête si le fichier est au bon format:
+      // On s'arrÃªte si le fichier est au bon format:
       if (File_error==0)
         break;
     }
@@ -646,8 +646,8 @@
 
     if (File_error)
     { 
-      // Sinon, l'appelant sera au courant de l'échec grace à File_error;
-      // et si on s'apprêtait à faire un chargement définitif de l'image (pas
+      // Sinon, l'appelant sera au courant de l'Ã©chec grace Ã  File_error;
+      // et si on s'apprÃªtait Ã  faire un chargement dÃ©finitif de l'image (pas
       // une preview), alors on flash l'utilisateur.
       //if (Pixel_load_function!=Pixel_load_in_preview)
       //  Error(0);
@@ -655,12 +655,12 @@
     }
   }
   else
-  // Si on a su déterminer avec succès le format du fichier:
+  // Si on a su dÃ©terminer avec succÃ¨s le format du fichier:
   {
     context->Format = format->Identifier;
     // On peut charger le fichier:
     // Dans certains cas il est possible que le chargement plante
-    // après avoir modifié la palette. TODO
+    // aprÃ¨s avoir modifiÃ© la palette. TODO
     format->Load(context);
   }
 
@@ -743,7 +743,7 @@
         strcpy(Main_backups->Pages->Filename,context->File_name);
         strcpy(Main_backups->Pages->File_directory,context->File_directory);
         
-        // On considère que l'image chargée n'est plus modifiée
+        // On considÃ¨re que l'image chargÃ©e n'est plus modifiÃ©e
         Main_image_is_modified=0;
         // Et on documente la variable Main_fileformat avec la valeur:
         Main_fileformat=format->Identifier;
@@ -768,15 +768,15 @@
     }
     else if (File_error!=1)
     {
-      // On considère que l'image chargée est encore modifiée
+      // On considÃ¨re que l'image chargÃ©e est encore modifiÃ©e
       Main_image_is_modified=1;
       // Et on documente la variable Main_fileformat avec la valeur:
       Main_fileformat=format->Identifier;
     }
     else
     {
-      // Dans ce cas, on sait que l'image n'a pas changé, mais ses
-      // paramètres (dimension, palette, ...) si. Donc on les restaures.
+      // Dans ce cas, on sait que l'image n'a pas changÃ©, mais ses
+      // paramÃ¨tres (dimension, palette, ...) si. Donc on les restaures.
       Download_infos_page_main(Main_backups->Pages);
     }
   }
@@ -821,7 +821,7 @@
 {
   T_Format *format;
   
-  // On place par défaut File_error à vrai au cas où on ne sache pas
+  // On place par dÃ©faut File_error Ã  vrai au cas oÃ¹ on ne sache pas
   // sauver le format du fichier: (Est-ce vraiment utile??? Je ne crois pas!)
   File_error=1;
 
@@ -996,7 +996,7 @@
         return;
       }
 
-  // Ouf, sauvé
+  // Ouf, sauvÃ©
   fclose(file);
 }
 
diff -ruN gfx2orig/src/main.c grafx2/src/main.c
--- gfx2orig/src/main.c	2010-03-22 04:36:40.000000000 -0500
+++ grafx2/src/main.c	2022-03-20 20:19:34.108495316 -0500
@@ -78,13 +78,19 @@
   extern DECLSPEC int SDLCALL SDL_putenv(const char *variable);
 #endif
 
-//--- Affichage de la syntaxe, et de la liste des modes vidéos disponibles ---
+//--- Affichage de la syntaxe, et de la liste des modes vidÃ©os disponibles ---
 void Display_syntax(void)
 {
   int mode_index;
   printf("Syntax: grafx2 [<arguments>] [<picture1>] [<picture2>]\n\n");
   printf("<arguments> can be:]\n");
   printf("\t-? -h -H -help    for this help screen\n");
+#if defined(FDOS)
+  printf("\t-ls-alt -lt-ctrl  reassign LeftShift key as Alt or Ctrl key\n");
+  printf("\t-rs-alt -rs-ctrl  reassign RightShift key as Alt or Ctrl key\n");
+  printf("\t-cl-alt -cl-ctrl  reassign CapsLock key as Alt or Ctrl key\n");
+  printf("\t-nl-alt -nl-ctrl  reassign NumLock key as Alt or Ctrl key\n");
+#else
   printf("\t-wide             to emulate a video mode with wide pixels (2x1)\n");
   printf("\t-tall             to emulate a video mode with tall pixels (1x2)\n");
   printf("\t-double           to emulate a video mode with double pixels (2x2)\n");
@@ -92,6 +98,7 @@
   printf("\t-tall2            to emulate a video mode with double tall pixels (2x4)\n");
   printf("\t-triple           to emulate a video mode with triple pixels (3x3)\n");
   printf("\t-quadruple        to emulate a video mode with quadruple pixels (4x4)\n");
+#endif
   printf("\t-rgb n            to reduce RGB precision from 256 to n levels\n");
   printf("\t-skin <filename>  to use an alternate file with the menu graphics\n");
   printf("\t-mode <videomode> to set a video mode\n");
@@ -122,12 +129,17 @@
 {
   T_Palette temp_palette;
   int       index;
+#if defined(FDOS)
+  // Silence 'set but not used' compiler warning.
+  (void)temp_palette;
+  (void)index;
+#endif
   printf("Error number %d occured in file %s, line %d, function %s.\n", error_code, filename,line_number,function_name);
 
   if (error_code==0)
   {
-    // L'erreur 0 n'est pas une vraie erreur, elle fait seulement un flash rouge de l'écran pour dire qu'il y a un problème.
-    // Toutes les autres erreurs déclenchent toujours une sortie en catastrophe du programme !
+    // L'erreur 0 n'est pas une vraie erreur, elle fait seulement un flash rouge de l'Ã©cran pour dire qu'il y a un problÃ¨me.
+    // Toutes les autres erreurs dÃ©clenchent toujours une sortie en catastrophe du programme !
     memcpy(temp_palette,Main_palette,sizeof(T_Palette));
     for (index=0;index<=255;index++)
       temp_palette[index].R=255;
@@ -175,6 +187,11 @@
                                        break;
     }
 
+#if defined(FDOS)
+    // When quitting, the screen is reset which clears the error message.
+    printf("(Press ENTER to quit.)\n");
+    getchar();
+#endif
     SDL_Quit();
     exit(error_code);
   }
@@ -183,6 +200,16 @@
 enum CMD_PARAMS
 {
     CMDPARAM_HELP,
+#if defined(FDOS)
+    CMDPARAM_LEFTSHIFT_ALT,
+    CMDPARAM_LEFTSHIFT_CTRL,
+    CMDPARAM_RIGHTSHIFT_ALT,
+    CMDPARAM_RIGHTSHIFT_CTRL,
+    CMDPARAM_CAPSLOCK_ALT,
+    CMDPARAM_CAPSLOCK_CTRL,
+    CMDPARAM_NUMLOCK_ALT,
+    CMDPARAM_NUMLOCK_CTRL,
+#endif
     CMDPARAM_MODE,
     CMDPARAM_PIXELRATIO_TALL,
     CMDPARAM_PIXELRATIO_WIDE,
@@ -203,6 +230,16 @@
     {"h", CMDPARAM_HELP},
     {"H", CMDPARAM_HELP},
     {"help", CMDPARAM_HELP},
+#if defined(FDOS)
+    {"ls-alt", CMDPARAM_LEFTSHIFT_ALT},
+    {"ls-ctrl", CMDPARAM_LEFTSHIFT_CTRL},
+    {"rs-alt", CMDPARAM_RIGHTSHIFT_ALT},
+    {"rs-ctrl", CMDPARAM_RIGHTSHIFT_CTRL},
+    {"cl-alt", CMDPARAM_CAPSLOCK_ALT},
+    {"cl-ctrl", CMDPARAM_CAPSLOCK_CTRL},
+    {"nl-alt", CMDPARAM_NUMLOCK_ALT},
+    {"nl-ctrl", CMDPARAM_NUMLOCK_CTRL},
+#endif
     {"mode", CMDPARAM_MODE},
     {"tall", CMDPARAM_PIXELRATIO_TALL},
     {"wide", CMDPARAM_PIXELRATIO_WIDE},
@@ -270,6 +307,16 @@
       case CMDPARAM_HELP:
         Display_syntax();
         exit(0);
+#if defined(FDOS)
+      case CMDPARAM_LEFTSHIFT_ALT:   set_fake_modifiers(FAKE_MOD_LS_ALT ); break;
+      case CMDPARAM_LEFTSHIFT_CTRL:  set_fake_modifiers(FAKE_MOD_LS_CTRL); break;
+      case CMDPARAM_RIGHTSHIFT_ALT:  set_fake_modifiers(FAKE_MOD_RS_ALT ); break;
+      case CMDPARAM_RIGHTSHIFT_CTRL: set_fake_modifiers(FAKE_MOD_RS_CTRL); break;
+      case CMDPARAM_CAPSLOCK_ALT:    set_fake_modifiers(FAKE_MOD_CL_ALT ); break;
+      case CMDPARAM_CAPSLOCK_CTRL:   set_fake_modifiers(FAKE_MOD_CL_CTRL); break;
+      case CMDPARAM_NUMLOCK_ALT:     set_fake_modifiers(FAKE_MOD_NL_ALT ); break;
+      case CMDPARAM_NUMLOCK_CTRL:    set_fake_modifiers(FAKE_MOD_NL_CTRL); break;
+#endif
       case CMDPARAM_MODE:
         index++;
         if (index<argc)
@@ -353,10 +400,10 @@
         }
         break;
       default:
-        // Si ce n'est pas un paramètre, c'est le nom du fichier à ouvrir
+        // Si ce n'est pas un paramÃ¨tre, c'est le nom du fichier Ã  ouvrir
         if (file_in_command_line > 1)
         {
-          // Il y a déjà 2 noms de fichiers et on vient d'en trouver un 3ème
+          // Il y a dÃ©jÃ  2 noms de fichiers et on vient d'en trouver un 3Ã¨me
           Error(ERROR_COMMAND_LINE);
           Display_syntax();
           exit(0);
@@ -409,9 +456,9 @@
   
   
 
-  // On crée dès maintenant les descripteurs des listes de pages pour la page
+  // On crÃ©e dÃ¨s maintenant les descripteurs des listes de pages pour la page
   // principale et la page de brouillon afin que leurs champs ne soient pas
-  // invalide lors des appels aux multiples fonctions manipulées à
+  // invalide lors des appels aux multiples fonctions manipulÃ©es Ã 
   // l'initialisation du programme.
   Main_backups=(T_List_of_pages *)malloc(sizeof(T_List_of_pages));
   Spare_backups=(T_List_of_pages *)malloc(sizeof(T_List_of_pages));
@@ -425,13 +472,13 @@
   // Choose directory for settings (read/write)
   Set_config_directory(program_directory,Config_directory);
 
-  // On détermine le répertoire courant:
+  // On dÃ©termine le rÃ©pertoire courant:
   getcwd(Main_current_directory,256);
 
-  // On en profite pour le mémoriser dans le répertoire principal:
+  // On en profite pour le mÃ©moriser dans le rÃ©pertoire principal:
   strcpy(Initial_directory,Main_current_directory);
 
-  // On initialise les données sur le nom de fichier de l'image de brouillon:
+  // On initialise les donnÃ©es sur le nom de fichier de l'image de brouillon:
   strcpy(Spare_current_directory,Main_current_directory);
   
   Main_fileformat=DEFAULT_FILEFORMAT;
@@ -444,8 +491,8 @@
 
   // On initialise ce qu'il faut pour que les fileselects ne plantent pas:
   
-  Main_fileselector_position=0; // Au début, le fileselect est en haut de la liste des fichiers
-  Main_fileselector_offset=0; // Au début, le fileselect est en haut de la liste des fichiers
+  Main_fileselector_position=0; // Au dÃ©but, le fileselect est en haut de la liste des fichiers
+  Main_fileselector_offset=0; // Au dÃ©but, le fileselect est en haut de la liste des fichiers
   Main_format=FORMAT_ALL_IMAGES;
   Main_current_layer=0;
   Main_layers_visible=0xFFFFFFFF;
@@ -459,7 +506,7 @@
   Brush_fileselector_offset=0;
   Brush_format=FORMAT_ALL_IMAGES;
 
-  // On initialise les commentaires des images à des chaînes vides
+  // On initialise les commentaires des images Ã  des chaÃ®nes vides
   Main_comment[0]='\0';
   Brush_comment[0]='\0';
 
@@ -492,6 +539,11 @@
   Spare_magnifier_offset_Y=0;
   Keyboard_click_allowed = 0;
   
+#if defined(FDOS)
+  // Allow spacebar to act as mouse button.
+  Keyboard_click_allowed = 1;
+#endif
+
   Main_safety_backup_prefix = 'a';
   Spare_safety_backup_prefix = 'b';
   Main_time_of_safety_backup = 0;
@@ -512,7 +564,7 @@
   SDL_WM_SetCaption("GrafX2","GrafX2");
 
   {
-    // Routine pour définir l'icone.
+    // Routine pour dÃ©finir l'icone.
     char icon_path[MAX_PATH_CHARACTERS];
     SDL_Surface * icon;
     sprintf(icon_path, "%s%s", Data_directory, "gfx2.gif");
@@ -536,7 +588,7 @@
         memset(icon_mask,0,128);
         for (y=0;y<32;y++)
           for (x=0;x<32;x++)
-            if (Get_SDL_pixel_hicolor(icon, x, y) != pink)
+            if ((Uint32)Get_SDL_pixel_hicolor(icon, x, y) != pink)
               icon_mask[(y*32+x)/8] |=0x80>>(x&7);
         SDL_WM_SetIcon(icon,icon_mask);
         free(icon_mask);
@@ -550,27 +602,27 @@
   // Texte
   Init_text();
 
-  // On initialise tous les modes vidéo
+  // On initialise tous les modes vidÃ©o
   Set_all_video_modes();
   Pixel_ratio=PIXEL_SIMPLE;
-  // On initialise les données sur l'état du programme:
-  // Donnée sur la sortie du programme:
+  // On initialise les donnÃ©es sur l'Ã©tat du programme:
+  // DonnÃ©e sur la sortie du programme:
   Quit_is_required=0;
   Quitting=0;
-  // Données sur l'état du menu:
+  // DonnÃ©es sur l'Ã©tat du menu:
   Menu_is_visible=1;
-  // Données sur les couleurs et la palette:
+  // DonnÃ©es sur les couleurs et la palette:
   First_color_in_palette=0;
-  // Données sur le curseur:
+  // DonnÃ©es sur le curseur:
   Cursor_shape=CURSOR_SHAPE_TARGET;
   Cursor_hidden=0;
-  // Données sur le pinceau:
+  // DonnÃ©es sur le pinceau:
   Paintbrush_X=0;
   Paintbrush_Y=0;
   Paintbrush_shape=PAINTBRUSH_SHAPE_ROUND;
   Paintbrush_hidden=0;
 
-  // On initialise tout ce qui concerne les opérations et les effets
+  // On initialise tout ce qui concerne les opÃ©rations et les effets
   Operation_stack_size=0;
   Selected_freehand_mode=OPERATION_CONTINUOUS_DRAW;
   Selected_line_mode         =OPERATION_LINE;
@@ -588,10 +640,10 @@
     // On initialise les infos du mode smooth:
   Smooth_mode=0;
     // On initialise les infos du mode shade:
-  Shade_mode=0;     // Les autres infos du Shade sont chargées avec la config
+  Shade_mode=0;     // Les autres infos du Shade sont chargÃ©es avec la config
   Quick_shade_mode=0; // idem
-    // On initialise les infos sur les dégradés:
-  Gradient_pixel =Display_pixel; // Les autres infos sont chargées avec la config
+    // On initialise les infos sur les dÃ©gradÃ©s:
+  Gradient_pixel =Display_pixel; // Les autres infos sont chargÃ©es avec la config
     // On initialise les infos de la grille:
   Snap_mode=0;
   Snap_width=8;
@@ -599,13 +651,13 @@
   Snap_offset_X=0;
   Snap_offset_Y=0;
     // On initialise les infos du mode Colorize:
-  Colorize_mode=0;          // Mode colorize inactif par défaut
-  Colorize_opacity=50;      // Une interpolation de 50% par défaut
-  Colorize_current_mode=0; // Par défaut, la méthode par interpolation
+  Colorize_mode=0;          // Mode colorize inactif par dÃ©faut
+  Colorize_opacity=50;      // Une interpolation de 50% par dÃ©faut
+  Colorize_current_mode=0; // Par dÃ©faut, la mÃ©thode par interpolation
   Compute_colorize_table();
     // On initialise les infos du mode Tiling:
-  Tiling_mode=0;  //   Pas besoin d'initialiser les décalages car ça se fait
-                  // en prenant une brosse (toujours mis à 0).
+  Tiling_mode=0;  //   Pas besoin d'initialiser les dÃ©calages car Ã§a se fait
+                  // en prenant une brosse (toujours mis Ã  0).
     // On initialise les infos du mode Mask:
   Mask_mode=0;
 
@@ -615,11 +667,11 @@
   Airbrush_delay=1;
   Airbrush_mono_flow=10;
   memset(Airbrush_multi_flow,0,256);
-  srand(time(NULL)); // On randomize un peu tout ça...
+  srand(time(NULL)); // On randomize un peu tout Ã§a...
 
   // Initialisation des boutons
   Init_buttons();
-  // Initialisation des opérations
+  // Initialisation des opÃ©rations
   Init_operations();
 
   // Initialize the brush container
@@ -633,7 +685,7 @@
   switch(Load_CFG(1))
   {
     case ERROR_CFG_MISSING:
-      // Pas un problème, on a les valeurs par défaut.
+      // Pas un problÃ¨me, on a les valeurs par dÃ©faut.
       break;
     case ERROR_CFG_CORRUPTED:
       DEBUG("Corrupted CFG file.",0);
@@ -681,7 +733,7 @@
   if (!(Menu_font=Load_font(Config.Font_file)))
     if (!(Menu_font=Load_font("font_DPaint.png")))
       {
-        printf("Unable to open the default font file: %s\n", "font_Classic.png");
+        printf("Unable to open the default font file: %s\n", "font_DPaint.png");
         Error(ERROR_GUI_MISSING);
       }
 
@@ -690,7 +742,7 @@
   Fore_color=Best_color_nonexcluded(255,255,255);
   Back_color=Best_color_nonexcluded(0,0,0);
 
-  // Allocation de mémoire pour la brosse
+  // Allocation de mÃ©moire pour la brosse
   if (!(Brush         =(byte *)malloc(   1*   1))) Error(ERROR_MEMORY);
   if (!(Smear_brush   =(byte *)malloc(MAX_PAINTBRUSH_SIZE*MAX_PAINTBRUSH_SIZE))) Error(ERROR_MEMORY);
 
@@ -710,6 +762,15 @@
     Video_mode[starting_videomode].Fullscreen,
     Pixel_ratio);
 
+#if defined(FDOS)
+  // Set mouse co-ords to center of screen.
+  SDL_WarpMouse(
+    Video_mode[starting_videomode].Width / 2,
+    Video_mode[starting_videomode].Height / 2
+  );
+  mod_prev_mouse_position();
+#endif
+
   // Windows only: move back the window to its original position.
   #if defined(__WIN32__)
   if (!Video_mode[starting_videomode].Fullscreen)
@@ -731,11 +792,11 @@
   Spare_image_width=Screen_width/Pixel_width;
   Spare_image_height=Screen_height/Pixel_height;
   
-  // Allocation de mémoire pour les différents écrans virtuels (et brosse)
+  // Allocation de mÃ©moire pour les diffÃ©rents Ã©crans virtuels (et brosse)
   if (Init_all_backup_lists(Screen_width,Screen_height)==0)
     Error(ERROR_MEMORY);
 
-  // Nettoyage de l'écran virtuel (les autres recevront celui-ci par copie)
+  // Nettoyage de l'Ã©cran virtuel (les autres recevront celui-ci par copie)
   memset(Main_screen,0,Main_image_width*Main_image_height);
 
   // Initialisation de diverses variables par calcul:
@@ -748,7 +809,7 @@
   Display_paintbrush_in_menu();
   Display_sprite_in_menu(BUTTON_PAL_LEFT,18+(Config.Palette_vertical!=0));
 
-  // On affiche le curseur pour débutter correctement l'état du programme:
+  // On affiche le curseur pour dÃ©butter correctement l'Ã©tat du programme:
   Display_cursor();
 
   Spare_image_is_modified=0;
@@ -757,16 +818,16 @@
   // Gestionnaire de signaux, quand il ne reste plus aucun espoir
   Init_sighandler();
 
-  // Le programme débute en mode de dessin à la main
+  // Le programme dÃ©bute en mode de dessin Ã  la main
   Select_button(BUTTON_DRAW,LEFT_SIDE);
 
-  // On initialise la brosse initiale à 1 pixel blanc:
+  // On initialise la brosse initiale Ã  1 pixel blanc:
   Brush_width=1;
   Brush_height=1;
   Capture_brush(0,0,0,0,0);
   *Brush=MC_White;
   
-  // Test de recuperation de fichiers sauvés
+  // Test de recuperation de fichiers sauvÃ©s
   switch (Check_recovery())
   {
     T_IO_Context context;
@@ -866,15 +927,15 @@
   // Remove the safety backups, this is normal exit
   Delete_safety_backups();
 
-  // On libère le buffer de gestion de lignes
+  // On libÃ¨re le buffer de gestion de lignes
   free(Horizontal_line_buffer);
   Horizontal_line_buffer = NULL;
 
-  // On libère le pinceau spécial
+  // On libÃ¨re le pinceau spÃ©cial
   free(Paintbrush_sprite);
   Paintbrush_sprite = NULL;
 
-  // On libère les différents écrans virtuels et brosse:
+  // On libÃ¨re les diffÃ©rents Ã©crans virtuels et brosse:
   free(Brush);
   Brush = NULL;
   Set_number_of_backups(0);
@@ -883,10 +944,10 @@
   free(Gfx);
   Gfx=NULL;
 
-  // On prend bien soin de passer dans le répertoire initial:
+  // On prend bien soin de passer dans le rÃ©pertoire initial:
   if (chdir(Initial_directory)!=-1)
   {
-    // On sauvegarde les données dans le .CFG et dans le .INI
+    // On sauvegarde les donnÃ©es dans le .CFG et dans le .INI
     if (Config.Auto_save)
     {
       return_code=Save_CFG();
@@ -904,7 +965,7 @@
 }
 
 
-// -------------------------- Procédure principale ---------------------------
+// -------------------------- ProcÃ©dure principale ---------------------------
 int main(int argc,char * argv[])
 {
 
diff -ruN gfx2orig/src/Makefile grafx2/src/Makefile
--- gfx2orig/src/Makefile	2010-03-22 06:31:51.000000000 -0500
+++ grafx2/src/Makefile	2022-03-20 20:19:34.112495316 -0500
@@ -1,11 +1,5 @@
 #  Grafx2 - The Ultimate 256-color bitmap paint program
 #  
-#  Copyright 2009 Per Olofsson
-#  Copyright 2008 Peter Gordon
-#  Copyright 2008-2010 Yves Rizoud
-#  Copyright 2007-2010 Adrien Destugues
-#  Copyright 1996-2001 Sunset Design (Guillaume Dorme & Karl Maritaud)
-#  
 #  Grafx2 is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU General Public License
 #  as published by the Free Software Foundation; version 2
@@ -19,448 +13,112 @@
 #  You should have received a copy of the GNU General Public License
 #  along with Grafx2; if not, see <http://www.gnu.org/licenses/>
 
-# Overridable defaults
-  prefix = /usr/local
-  exec_prefix = $(prefix)
-  bindir = $(exec_prefix)/bin
-  datarootdir = $(prefix)/share
-  datadir = $(datarootdir)
-
-# Compile with OPTIM=0 to disable gcc optimizations, to enable debug.
-  STRIP = strip
-
-
-### PLATFORM DETECTION AND CONFIGURATION ###
-
-PLATFORMOBJ =
-
-# There is no uname under windows, but we can guess we are there with the COMSPEC env.var
-# Windows specific
-ifdef COMSPEC
-  DELCOMMAND = rm -f
-  MKDIR = mkdir -p
-  RMDIR = rmdir
-  CP = cp
-  BIN = ../bin/grafx2.exe
-  COPT = -W -Wall -Wdeclaration-after-statement -O$(OPTIM) -g -ggdb `sdl-config --cflags` $(TTFCOPT) $(JOYCOPT) $(LUACOPT) $(LAYERCOPT)
-  LOPT = `sdl-config --libs` -lSDL_image $(TTFLOPT) -lpng $(LUALOPT)
-  LUALOPT = -llua
-  CC = gcc
-  OBJDIR = ../obj/win32
-  # Resources (icon)
-  WINDRES = windres.exe
-  PLATFORMOBJ = $(OBJDIR)/winres.o
-  PLATFORM = win32
-  #some misc files we have to add to the release archive under windows.
-  PLATFORMFILES = bin/SDL.dll bin/SDL_image.dll bin/libpng13.dll bin/zlib1.dll $(TTFLIBS)
-  ZIP = zip
-else
-
-#For all other platforms, we can rely on uname
-  PLATFORM = $(shell uname)
-
-  #AmigaOS4 specific
-  ifeq ($(PLATFORM),AmigaOS) # 1
-    DELCOMMAND = rm -rf
-    MKDIR = mkdir -p
-    RMDIR = rmdir
-    CP = cp
-    BIN = ../bin/grafx2
-    COPT = -Wall -c -gstabs -mcrt=newlib `sdl-config --cflags` -I/SDK/Local/common/include/SDL -D__USE_INLINE__ $(TTFCOPT)
-    LOPT = `sdl-config --libs` -lSDL_image -lpng -ljpeg -lz $(TTFLOPT) -lft2
-    CC = gcc
-    OBJDIR = ../obj/amiga
-    ZIP = lha
-    ZIPOPT = a
-
-  else
-  ifeq ($(PLATFORM),Darwin) # 2
-  #Mac OS X specific
-  DELCOMMAND = rm -rf
-  MKDIR = mkdir -p
-  RMDIR = rmdir
-  CP = cp
-  ZIP = zip
-  PLATFORMFILES = gfx2.png
-  BIN = ../bin/grafx2
-  # Where the SDL frameworks are located
-  FWDIR = /Library/Frameworks
-  SDLCOPT = -arch i386 -I$(FWDIR)/SDL.framework/Headers -I$(FWDIR)/SDL_image.framework/Headers -I$(FWDIR)/SDL_ttf.framework/Headers -D_THREAD_SAFE
-  SDLLOPT = -arch i386 -L/usr/lib -framework SDL -framework SDL_image -framework SDL_ttf -framework Cocoa -framework Carbon -framework OpenGL
-  COPT = -D__macosx__ -D__linux__ -W -Wall -Wdeclaration-after-statement -O$(OPTIM) -std=c99 -c -g $(SDLCOPT) $(TTFCOPT) -I/usr/X11/include
-  LOPT = $(SDLLOPT) -L/usr/X11/lib -R/usr/X11/lib -lpng
-  # Use gcc for compiling. Use ncc to build a callgraph and analyze the code.
-  CC = gcc
-  #CC = nccgen -ncgcc -ncld -ncfabs
-  OBJDIR = ../obj/macosx
-  PLATFORMOBJ = $(OBJDIR)/SDLMain.o
-  X11LOPT = 
-  MACAPPEXE = Grafx2.app/Contents/MacOS/Grafx2
-
-  else
-  ifeq ($(PLATFORM),AROS) # 3
-  #AROS specific
-    DELCOMMAND = rm -rf
-    MKDIR = mkdir -p
-    RMDIR = rmdir
-    CP = cp
-    BIN = ../bin/grafx2
-    COPT = -Wall -g `sdl-config --cflags` $(TTFCOPT)
-    LOPT = -lSDL_image `sdl-config --libs` -lpng -ljpeg -lz $(TTFLOPT) -lfreetype2shared
-    CC = gcc
-    OBJDIR = ../obj/aros
-    STRIP = strip --strip-unneeded --remove-section .comment
-    ZIP = lha
-    ZIPOPT = a
-
-  else
-  ifeq ($(PLATFORM),MorphOS) # 4
-  #MorphOS specific
-    DELCOMMAND = rm -rf
-    MKDIR = mkdir -p
-    RMDIR = rmdir
-    CP = cp
-    BIN = ../bin/grafx2
-    COPT = -Wall -gstabs -c `sdl-config --cflags` $(TTFCOPT)
-    LOPT = -lSDL_image `sdl-config --libs` -lpng -ljpeg -lz $(TTFLOPT)
-    CC = gcc
-    OBJDIR = ../obj/morphos
-    ZIP = lha
-    ZIPOPT = a
-    PLATFORMFILES = ../misc/grafx2.info
-
-  else
-  ifeq ($(PLATFORM),AMIGA) # 5
-  # AmigaOS 3.x specific (building with gcc)
-    DELCOMMAND = rm -rf
-    MKDIR = mkdir -p
-    RMDIR = rmdir
-    CP = cp
-    BIN = ../bin/grafx2
-    COPT = -Wall -gstabs -c `sdl-config --cflags` $(TTFCOPT)
-    LOPT = -lSDL_image `sdl-config --libs` -lpng -ljpeg -lz $(TTFLOPT) -lfreetype
-    CC = gcc
-    OBJDIR = ../obj/amiga
-    ZIP = lha
-    ZIPOPT = a
-
-  else
-  ifeq ($(PLATFORM),BeOS) # 6
-  #BeOS specific
-    DELCOMMAND = rm -rf
-    MKDIR = mkdir -p
-    RMDIR = rmdir
-    CP = cp
-    BIN = ../bin/grafx2
-    COPT = -W -Wall -c -g `sdl-config --cflags` $(TTFCOPT) -I/boot/home/config/include
-    LOPT = `sdl-config --libs` -lSDL_image -lpng -ljpeg -lz $(TTFLOPT)
-    CC = gcc
-    OBJDIR = ../obj/beos
-    ZIP = zip
-
-  else
-  ifeq ($(PLATFORM),Haiku) # 7
-  #Haiku specific
-    DELCOMMAND = rm -rf
-    MKDIR = mkdir -p
-    RMDIR = rmdir
-    CP = cp
-    BIN = ../bin/grafx2
-    COPT = -W -Wall -c -g `sdl-config --cflags` $(TTFCOPT) -I/boot/common/include
-    LOPT = `sdl-config --libs` -lSDL_image -lpng -ljpeg -lz $(TTFLOPT)
-    CC = gcc
-    OBJDIR = ../obj/haiku
-    ZIP = zip
-
-  else
-  ifeq ($(PLATFORM),skyos) # 8
-  #SkyOS specific
-    DELCOMMAND = rm -rf
-    MKDIR = mkdir -p
-    RMDIR = rmdir
-    CP = cp
-    BIN = ../bin/grafx2
-    COPT = -W -Wall -Wdeclaration-after-statement -c -g `sdl-config --cflags` $(TTFCOPT)
-    LOPT = `sdl-config --libs` -lSDL_image -lpng -ljpeg -lz $(TTFLOPT)
-    CC = gcc
-    OBJDIR = ../obj/skyos
-    ZIP = zip
-
-  else
-  ifeq ($(PLATFORM),OSF1) #9
-  #OSF1 / tru64 alpha
-      DELCOMMAND = rm -rf
-      MKDIR = mkdir -p
-      RMDIR = rmdir
-      CP = cp
-      ZIP = zip
-      PLATFORMFILES = gfx2.png
-      BIN = ../bin/grafx2
-      COPT = -W -Wall -std=c99 -c -g -gstabs -D__TRU64__ `sdl-config --cflags` $(TTFCOPT) $(LUACOPT)
-      LOPT = `sdl-config --libs` -lSDL_image $(TTFLOPT) -lpng $(LUALOPT) -lm
-      OBJDIR = ../obj/unix
-      X11LOPT = -lX11
-      CC = gcc
-
-  else
-  ifeq ($(findstring Kickstart,$(shell version)),Kickstart) # 9
-    # Classic amiga without gcc. Use vbcc.
-    PLATFORM = amiga-vbcc
-    DELCOMMAND = delete
-    MKDIR = makedir
-    RMDIR= delete
-    CP = copy
-    BIN = ../bin/grafx2
-    COPT = -c99 -Ivbcc:PosixLib/include -D__amigaos__ $(TTFCOPT)
-    CC = vc
-    OBJDIR = ../obj/amiga-vbcc
-    ZIP = lha
-    ZIPOPT = a
-
-    NOTTF = 1
-
-  else
-  
-      # Finally, the default rules that work fine for most unix/gcc systems, linux and freebsd are tested.
-      # Linux and FreeBSD specific (default rules)
-      DELCOMMAND = rm -rf
-      MKDIR = mkdir -p
-      RMDIR = rmdir
-      CP = cp
-      ZIP = zip
-      PLATFORMFILES = gfx2.png
-      ifeq ($(NOLUA),1)
-        LUACOPT =
-        LUALOPT =
-      else
-        LUACOPT = `pkg-config lua5.1 --cflags`
-        LUALOPT = `pkg-config lua5.1 --libs`
-      endif
-
-      # These can only be used under linux and maybe freebsd. They allow to compile for the gp2x or to create a windows binary
-      ifdef WIN32CROSS
-        #cross compile a Win32 executable
-        CC = i586-mingw32msvc-gcc
-        BIN = ../bin/grafx2.exe
-        COPT = -W -Wall -Wdeclaration-after-statement -O$(OPTIM) -g -ggdb -Dmain=SDL_main `/usr/local/cross-tools/i386-mingw32/bin/sdl-config --cflags` $(TTFCOPT)
-        LOPT = -mwindows -lmingw32 -lSDLmain -lSDL -lshlwapi `/usr/local/cross-tools/i386-mingw32/bin/sdl-config --libs` -lSDL_image $(TTFLOPT)
-        OBJDIR = ../obj/win32
-        PLATFORM = win32
-      else
-      ifdef GP2XCROSS
-
-        #cross compile an exec for the gp2x
-        CC = /opt/open2x/gcc-4.1.1-glibc-2.3.6/arm-open2x-linux/bin/arm-open2x-linux-gcc
-        BIN = ../bin/grafx2.gpe
-        COPT = -W -Wall -Wdeclaration-after-statement -pedantic -std=c99 -static -g -O$(OPTIM) -I/opt/open2x/gcc-4.1.1-glibc-2.3.6/include `/opt/open2x/gcc-4.1.1-glibc-2.3.6/bin/sdl-config --cflags` $(TTFCOPT) -D__GP2X__ $(TTFCOPT) $(JOYCOPT) $(LUACOPT) $(LAYERCOPT)
-        LOPT = -static -lSDL_image `/opt/open2x/gcc-4.1.1-glibc-2.3.6/bin/sdl-config --static-libs` -ljpeg -lpng -lz -lm $(TTFLOPT) $(LUALOPT)
-        OBJDIR = ../obj/gp2x
-        NOTTF = 1
-        PLATFORM = gp2x
-        STRIP = /opt/open2x/gcc-4.1.1-glibc-2.3.6/arm-open2x-linux/bin/arm-open2x-linux-strip
-        JOYCOPT = -DUSE_JOYSTICK
-      else
-
-        # Compiles a regular linux executable for the native platform
-        BIN = ../bin/grafx2
-        COPT = -W -Wall -Wdeclaration-after-statement -std=c99 -c -g `sdl-config --cflags` $(TTFCOPT) $(LUACOPT)
-        LOPT = `sdl-config --libs` -lSDL_image $(TTFLOPT) -lpng $(LUALOPT) -lm
-        # Use gcc for compiling. Use ncc to build a callgraph and analyze the code.
-        CC = gcc
-        #CC = nccgen -ncgcc -ncld -ncfabs
-        OBJDIR = ../obj/unix
-        X11LOPT = -lX11
-      endif
-      endif
-  endif
-  endif
-  endif
-  endif
-  endif
-  endif
-  endif
-  endif
-  endif
-  endif
-endif
-
-### BUILD SETTINGS are set according to vars set in the platform selection, the "overridable defaults", and environment variables set before launching make
-
-#TrueType is optional: make NOTTF=1 to disable support and dependencies.
-ifeq ($(NOTTF),1)
-  TTFCOPT = -DNOTTF=1
-  TTFLOPT =
-  TTFLIBS =
-  TTFLABEL = -nottf
-else
-  TTFCOPT = 
-  TTFLOPT = -L/usr/local/lib -lSDL_ttf $(X11LOPT)
-  TTFLIBS = bin/libfreetype-6.dll bin/SDL_ttf.dll
-  TTFLABEL = 
-endif
-
-#Lua scripting is optional too
-ifeq ($(NOLUA),1)
-    LUACOPT =
-    LUALOPT =
-    LUALABEL = -nolua
-else
-    LUACOPT += -D__ENABLE_LUA__
-    LUALABEL =
-endif
-
-#To enable Joystick emulation of cursor, make USE_JOYSTICK=1 (for input.o)
-#This can be necessary to test cursor code on a PC, but by default for all
-#non-console platforms the joystick is disabled, to avoid reporting
-#'restless' movements when an analog joystick or a poorly-calibrated joypad
-#is plugged in.
-ifeq ($(USE_JOYSTICK),1)
-  JOYCOPT = -DUSE_JOYSTICK
-endif
-
-#To speed up rendering, can disable the layered editing
-# with NOLAYERS=1
-ifeq ($(NOLAYERS),1)
-  LAYERCOPT = -DNOLAYERS
-else
-  LAYERCOPT =
-endif
-
-### And now for the real build rules ###
-
-.PHONY : all debug release clean depend zip version force install uninstall
-
-# This is the list of the objects we want to build. Dependancies are built by "make depend" automatically.
-OBJ = $(OBJDIR)/main.o $(OBJDIR)/init.o $(OBJDIR)/graph.o $(OBJDIR)/sdlscreen.o  $(OBJDIR)/misc.o $(OBJDIR)/special.o $(OBJDIR)/buttons.o $(OBJDIR)/palette.o $(OBJDIR)/help.o $(OBJDIR)/operatio.o $(OBJDIR)/pages.o $(OBJDIR)/loadsave.o $(OBJDIR)/readline.o $(OBJDIR)/engine.o $(OBJDIR)/filesel.o $(OBJDIR)/op_c.o $(OBJDIR)/readini.o $(OBJDIR)/saveini.o $(OBJDIR)/shade.o $(OBJDIR)/keyboard.o $(OBJDIR)/io.o $(OBJDIR)/version.o $(OBJDIR)/text.o $(OBJDIR)/SFont.o $(OBJDIR)/setup.o $(OBJDIR)/pxsimple.o $(OBJDIR)/pxtall.o $(OBJDIR)/pxwide.o $(OBJDIR)/pxdouble.o $(OBJDIR)/pxtriple.o $(OBJDIR)/pxtall2.o $(OBJDIR)/pxwide2.o $(OBJDIR)/pxquad.o $(OBJDIR)/windows.o $(OBJDIR)/brush.o $(OBJDIR)/realpath.o $(OBJDIR)/mountlist.o $(OBJDIR)/input.o $(OBJDIR)/hotkeys.o $(OBJDIR)/transform.o $(OBJDIR)/pversion.o $(OBJDIR)/factory.o $(PLATFORMOBJ) $(OBJDIR)/fileformats.o $(OBJDIR)/miscfileformats.o $(OBJDIR)/libraw2crtc.o $(OBJDIR)/brush_ops.o $(OBJDIR)/buttons_effects.o $(OBJDIR)/layers.o 
-
-SKIN_FILES = ../share/grafx2/skins/skin_classic.png ../share/grafx2/skins/skin_modern.png ../share/grafx2/skins/skin_DPaint.png ../share/grafx2/skins/font_Classic.png ../share/grafx2/skins/font_Fun.png ../share/grafx2/skins/font_Fairlight.png ../share/grafx2/skins/font_Melon.png ../share/grafx2/skins/font_DPaint.png ../share/grafx2/skins/skin_scenish.png ../share/grafx2/skins/font_Seen.png
-
-SCRIPT_FILES = ../share/grafx2/scripts/bru_db_Amigaball.lua ../share/grafx2/scripts/bru_db_ColorSphere.lua ../share/grafx2/scripts/bru_db_FindAA.lua ../share/grafx2/scripts/bru_db_Fisheye.lua ../share/grafx2/scripts/bru_db_GrayscaleAvg.lua ../share/grafx2/scripts/bru_db_GrayscaleDesat.lua ../share/grafx2/scripts/bru_db_Halfsmooth.lua ../share/grafx2/scripts/bru_db_Mandelbrot.lua ../share/grafx2/scripts/bru_db_Waves.lua ../share/grafx2/scripts/pal_db_Desaturate.lua ../share/grafx2/scripts/pal_db_ExpandColors.lua ../share/grafx2/scripts/pal_db_FillColorCube.lua ../share/grafx2/scripts/pal_db_InvertedRGB.lua ../share/grafx2/scripts/pal_db_Set3bit.lua ../share/grafx2/scripts/pal_db_Set6bit.lua ../share/grafx2/scripts/pal_db_SetC64Palette.lua ../share/grafx2/scripts/pal_db_ShiftHue.lua ../share/grafx2/scripts/pic_db_Pic2isometric.lua ../share/grafx2/scripts/pic_db_Rainbow-Dark2Bright.lua ../share/grafx2/scripts/pic_db_SierpinskyCarpet.lua ../share/grafx2/scripts/pic_db_SierpinskyTriangle.lua ../share/grafx2/scripts/pic_ni_Colorspace12bit.lua ../share/grafx2/scripts/pic_ni_Colorspace15bit.lua ../share/grafx2/scripts/pic_ni_Colorspace18bit.lua ../share/grafx2/scripts/pic_ni_GlassGridFilter.lua ../share/grafx2/scripts/pic_ni_Grid8.lua ../share/grafx2/scripts/pic_ni_Grid8red.lua ../share/grafx2/scripts/pic_ni_GridIso.lua ../share/grafx2/scripts/pic_ni_PaletteX1.lua ../share/grafx2/scripts/pic_ni_PaletteX8.lua ../share/grafx2/scripts/scn_db_RemapImage2RGB.lua ../share/grafx2/scripts/scn_db_RemapImage2RGB_ed.lua ../share/grafx2/scripts/scn_db_RemapImageTo3bitPal.lua
-
-ifeq ($(PLATFORM),Darwin)
-all : $(MACAPPEXE)
-$(MACAPPEXE) : $(BIN)
-	rm -rf Grafx2.app
-	mkdir -p Grafx2.app Grafx2.app/Contents Grafx2.app/Contents/Frameworks Grafx2.app/Contents/MacOS Grafx2.app/Contents/Resources
-	echo 'APPL????' > Grafx2.app/Contents/PkgInfo
-	cp Info.plist Grafx2.app/Contents
-	cp -r English.lproj Grafx2.app/Contents/Resources
-	cp -r fonts Grafx2.app/Contents/Resources
-	cp -r skins Grafx2.app/Contents/Resources
-	cp -r gfx2def.ini Grafx2.app/Contents/Resources
-	cp -Rp $(FWDIR)/SDL.framework Grafx2.app/Contents/Frameworks
-	cp -Rp $(FWDIR)/SDL_image.framework Grafx2.app/Contents/Frameworks
-	cp -Rp $(FWDIR)/SDL_ttf.framework Grafx2.app/Contents/Frameworks
-	cp $(BIN) $(MACAPPEXE)
-else
-all : $(BIN)
-endif
+# FreeDOS considirations:
+#
+#   Deleting all object files in one command is too long for the FreeDOS command
+#   line, so we delete the entire directory instead of the object files.
+#
+#   The FreeDOS 'del' does not accept '/' as dir separator, but 'deltree' does,
+#   so we use 'deltree' to delete files or dirs.
+#
+#   Using the Makefile 'echo' command is troublesome. If the text to echo is not
+#   quoted, Makefile interprets semi-colons as a command separator (and will
+#   not echo them). If the text to echo is enclosed in quotes, when it is
+#   passed to the FreeDOS shell, the FreeDOS 'echo' command will output the
+#   quotes. Escaping semi-colons does not work. To work-aronud this problem,
+#   the 'qecho' command can be used.
 
 
-debug : $(BIN)
+PROG_VER = 2.2  # Grafx2 version.
+SVN_VER = 1404  # SVN version. Only for compatibility; it's mostly meaningless.
 
-# Make release will strip the executable to make it smaller but non-debugable
-release : version $(BIN)
-	$(STRIP) $(BIN)
 
-# Create a zip archive ready for upload to the website, including binaries and sourcecode
-ziprelease: version $(BIN) release
-	echo `sed "s/.*=\"\(.*\)\";/\1/" pversion.c`.`svnversion` | tr " :" "_-" | sed -e "s/\(wip\)\\./\1/I" > $(OBJDIR)/versiontag
-
-	tar cvzf "../src-`cat $(OBJDIR)/versiontag`.tgz" --strip=1 ../src/*.c ../src/*.h ../src/Makefile ../src/Makefile.dep ../src/gfx2.ico 
-	cd .. && $(ZIP) $(ZIPOPT) "grafx2-`cat $(OBJDIR:../%=%)/versiontag`$(TTFLABEL)-$(PLATFORM).$(ZIP)" $(BIN:../%=%) share/grafx2/gfx2def.ini $(SCRIPT_FILES:../%=%) $(SKIN_FILES:../%=%) share/grafx2/gfx2.gif share/icons/grafx2.svg doc/README.txt doc/COMPILING.txt doc/gpl-2.0.txt share/grafx2/fonts/8pxfont.png doc/README-zlib1.txt doc/README-SDL.txt doc/README-SDL_image.txt doc/README-SDL_ttf.txt doc/README-lua.txt share/grafx2/fonts/Tuffy.ttf src-`cat $(OBJDIR:../%=%)/versiontag`.tgz $(PLATFORMFILES:../%=%)
-	$(DELCOMMAND) "../src-`cat $(OBJDIR)/versiontag`.tgz"
-	tar cvzf "../grafx2-`cat $(OBJDIR)/versiontag`$(TTFLABEL)-src.tgz" --strip=1 --transform 's,^,grafx2/,g' ../src/*.c ../src/*.h ../src/Makefile ../src/Makefile.dep ../share/grafx2/gfx2def.ini $(SCRIPT_FILES) $(SKIN_FILES) ../src/gfx2.ico ../share/grafx2/gfx2.gif ../share/icons/grafx2.svg ../doc/README.txt ../doc/COMPILING.txt ../doc/gpl-2.0.txt ../misc/unix/grafx2.1 ../misc/unix/grafx2.xpm ../misc/unix/grafx2.desktop ../share/grafx2/fonts/8pxfont.png ../share/grafx2/fonts/Tuffy.ttf
-	$(DELCOMMAND) "$(OBJDIR)/versiontag"
+STRIP = strip
+DELCOMMAND = del
+RMDIR = deltree /y  # 'mkdirs' exists in the 'util' directory
+MKDIR = mkdirs      # 'qecho' exists in the 'util' directory
+ECHO = qecho
+CC = gcc
+
+
+OBJDIR = ../obj/dos
+BINDIR = ../bin
+BIN = $(BINDIR)/grafx2.exe
+
+
+
+#### Mandatory for building for FreeDOS
+DOSCOPT = -DFDOS
+
+
+#### Enable/Disable Joystick support (Joystick is not supported)
+#JOYCOPT = -DUSE_JOYSTICK
+JOYCOPT =
+
+
+#### Enable/Disable Layers (Disabling layered editing speeds up rendering)
+#LAYERCOPT = -DNOLAYERS
+LAYERCOPT =
+
+
+#### Enable/Disable Lua support
+LUACOPT = -D__ENABLE_LUA__ -I../../lua515/src
+LUALINC = -L../../lua515/src
+LUALOPT = -llua
+
+
+#### Enable/Disable PNG support
+PNGCOPT = -I../../libpng12 -I../../zlib
+PNGLINC = -L../../libpng12 -L../../zlib
+PNGLOPT = -lpng -lz
+
+
+#### Enable/Disable TTF support (True Type Fonts are not supported)
+TTFCOPT = -DNOTTF
+#TTFCOPT =
+
+
+COPT = -W -Wall -Wdeclaration-after-statement -O -g -ggdb -I. $(DOSCOPT) $(JOYCOPT) $(LAYERCOPT) $(LUACOPT) $(PNGCOPT) $(TTFCOPT)
+
+LOPT = $(LUALINC) $(PNGLINC) $(LUALOPT) $(PNGLOPT) $(TTFLOPT) 
+
 
-testsed :
+
+
+.PHONY : all debug release clean version
+
+OBJ = $(OBJDIR)/main.o $(OBJDIR)/init.o $(OBJDIR)/graph.o $(OBJDIR)/sdlscreen.o  $(OBJDIR)/misc.o $(OBJDIR)/special.o $(OBJDIR)/buttons.o $(OBJDIR)/palette.o $(OBJDIR)/help.o $(OBJDIR)/operatio.o $(OBJDIR)/pages.o $(OBJDIR)/loadsave.o $(OBJDIR)/readline.o $(OBJDIR)/engine.o $(OBJDIR)/filesel.o $(OBJDIR)/op_c.o $(OBJDIR)/readini.o $(OBJDIR)/saveini.o $(OBJDIR)/shade.o $(OBJDIR)/keyboard.o $(OBJDIR)/io.o $(OBJDIR)/version.o $(OBJDIR)/text.o $(OBJDIR)/SFont.o $(OBJDIR)/setup.o $(OBJDIR)/pxsimple.o $(OBJDIR)/pxtall.o $(OBJDIR)/pxwide.o $(OBJDIR)/pxdouble.o $(OBJDIR)/pxtriple.o $(OBJDIR)/pxtall2.o $(OBJDIR)/pxwide2.o $(OBJDIR)/pxquad.o $(OBJDIR)/windows.o $(OBJDIR)/brush.o $(OBJDIR)/realpath.o $(OBJDIR)/mountlist.o $(OBJDIR)/input.o $(OBJDIR)/hotkeys.o $(OBJDIR)/transform.o $(OBJDIR)/pversion.o $(OBJDIR)/factory.o $(OBJDIR)/fileformats.o $(OBJDIR)/miscfileformats.o $(OBJDIR)/libraw2crtc.o $(OBJDIR)/brush_ops.o $(OBJDIR)/buttons_effects.o $(OBJDIR)/layers.o $(OBJDIR)/shim.o  $(OBJDIR)/SDL.o $(OBJDIR)/readpng.o
+
+all : $(BIN)
+
+debug : $(BIN)
 
 $(BIN) : $(OBJ)
-	test -d ../bin || $(MKDIR) ../bin
+	$(MKDIR) ../bin
 	$(CC) $(OBJ) -o $(BIN) $(LOPT) $(LFLAGS)
 
-# SVN revision number
 version.c :
-	echo "char SVN_revision[]=\"`svnversion .`\";" > version.c
-ifeq ($(LABEL),)
-else
-	echo "char Program_version[]=\"$(LABEL)\";" > pversion.c
-endif
-
-version : delversion delpversion version.c pversion.c $(OBJDIR)/version.o $(OBJDIR)/pversion.o all
+	$(ECHO) "char SVN_revision[]=\"$(SVN_VER)\";" > version.c
 
+pversion.c :
+	$(ECHO) "char Program_version[]=\"$(PROG_VER)\";" > pversion.c
 
 delversion :
 	$(DELCOMMAND) version.c
 	
 delpversion :
-ifeq ($(LABEL),)
-else
 	$(DELCOMMAND) pversion.c
-endif
 
-$(OBJDIR)/%.o : %.c
-	$(if $(wildcard $(OBJDIR)),,$(MKDIR) $(OBJDIR))
-	$(CC) $(COPT) $(CFLAGS) -c $*.c -o $(OBJDIR)/$*.o
-
-$(OBJDIR)/%.o : %.m
-	$(if $(wildcard $(OBJDIR)),,$(MKDIR) $(OBJDIR))
-	$(CC) $(COPT) -c $*.m -o $(OBJDIR)/$*.o
-
-depend :
-	$(CC) -MM *.c | sed 's:^[^ ]:$$(OBJDIR)/&:' > Makefile.dep
+version : delversion delpversion version.c pversion.c $(OBJDIR)/version.o $(OBJDIR)/pversion.o all
 
-# Link the icons to the program under windows
-$(OBJDIR)/winres.o : gfx2.ico
-	echo "1 ICON \"gfx2.ico\"" | $(WINDRES) -o $(OBJDIR)/winres.o
+release : version $(BIN)
+	$(STRIP) $(BIN)
 
 clean :
-	$(DELCOMMAND) $(OBJ)
-	$(DELCOMMAND) $(BIN)
+	$(RMDIR) $(OBJDIR)
+	$(RMDIR) $(BINDIR)
 
-ifneq ($(PLATFORM),amiga-vbcc)
-# Linux installation of the program
-install : $(BIN)
-	# Create dirs
-	test -d $(DESTDIR)$(bindir) || $(MKDIR) $(DESTDIR)$(bindir)
-	test -d $(DESTDIR)$(datadir)/grafx2 || $(MKDIR) $(DESTDIR)$(datadir)/grafx2
-	test -d $(DESTDIR)$(datadir)/grafx2/fonts || $(MKDIR) $(DESTDIR)$(datadir)/grafx2/fonts
-	test -d $(DESTDIR)$(datadir)/grafx2/skins || $(MKDIR) $(DESTDIR)$(datadir)/grafx2/skins
-	test -d $(DESTDIR)$(datadir)/grafx2/scripts || $(MKDIR) $(DESTDIR)$(datadir)/grafx2/scripts
-	test -d $(DESTDIR)$(datadir)/applications || $(MKDIR) $(DESTDIR)$(datadir)/applications
-	test -d $(DESTDIR)$(datadir)/icons || $(MKDIR) $(DESTDIR)$(datadir)/icons
-	# Copy files
-	$(CP) $(BIN) $(DESTDIR)$(bindir)
-	$(CP) ../share/grafx2/gfx2def.ini $(DESTDIR)$(datadir)/grafx2/
-	$(CP) ../share/grafx2/gfx2.gif $(DESTDIR)$(datadir)/grafx2/
-	$(CP) ../share/grafx2/fonts/* $(DESTDIR)$(datadir)/grafx2/fonts/
-	$(CP) $(SKIN_FILES) $(DESTDIR)$(datadir)/grafx2/skins/
-	$(CP) $(SCRIPT_FILES) $(DESTDIR)$(datadir)/grafx2/scripts/
-	# Icon and desktop file for debian
-	$(CP) ../misc/unix/grafx2.desktop $(DESTDIR)$(datadir)/applications/
-	$(CP) ../misc/unix/grafx2.xpm $(DESTDIR)$(datadir)/icons/
-	$(CP) ../share/icons/grafx2.svg $(DESTDIR)$(datadir)/icons/
-	@echo Install complete
-  
-# Linux uninstallation of the program
-uninstall :
-	$(DELCOMMAND) $(DESTDIR)$(bindir)/grafx2
-	$(DELCOMMAND) $(DESTDIR)$(datadir)/grafx2/gfx2def.ini
-	$(DELCOMMAND) $(DESTDIR)$(datadir)/grafx2/gfx2.gif
-	$(DELCOMMAND) $(DESTDIR)$(datadir)/grafx2/fonts/*
-	$(if $(wildcard $(DESTDIR)$(datadir)/grafx2/fonts),,$(RMDIR) $(DESTDIR)$(datadir)/grafx2/fonts)
-	$(DELCOMMAND) $(SKIN_FILES:../share%=$(DESTDIR)$(datadir)%)
-	$(if $(wildcard $(DESTDIR)$(datadir)/grafx2/skins),,$(RMDIR) $(DESTDIR)$(datadir)/grafx2/skins)
-	$(DELCOMMAND) $(SCRIPT_FILES:../share%=$(DESTDIR)$(datadir)%)
-	$(if $(wildcard $(DESTDIR)$(datadir)/grafx2/scripts),,$(RMDIR) $(DESTDIR)$(datadir)/grafx2/scripts)
-	$(if $(wildcard $(DESTDIR)$(datadir)/grafx2),,$(RMDIR) $(DESTDIR)$(datadir)/grafx2)
-	# Icon and desktop file for debian
-	$(DELCOMMAND) $(DESTDIR)$(datadir)/applications/grafx2.desktop
-	$(DELCOMMAND) $(DESTDIR)$(datadir)/icons/grafx2.xpm
-	$(DELCOMMAND) $(DESTDIR)$(datadir)/icons/grafx2.svg
-	@echo Uninstall complete
-
-endif
-
--include Makefile.dep
 
+$(OBJDIR)/%.o : %.c
+	$(if $(wildcard $(OBJDIR)),,$(MKDIR) $(OBJDIR))
+	$(CC) $(COPT) $(CFLAGS) -c $*.c -o $(OBJDIR)/$*.o
diff -ruN gfx2orig/src/Makefile.dep grafx2/src/Makefile.dep
--- gfx2orig/src/Makefile.dep	2010-03-17 12:47:27.000000000 -0500
+++ grafx2/src/Makefile.dep	1969-12-31 18:00:00.000000000 -0600
@@ -1,96 +0,0 @@
-$(OBJDIR)/brush.o: brush.c global.h struct.h const.h graph.h misc.h errors.h \
- windows.h sdlscreen.h brush.h
-$(OBJDIR)/brush_ops.o: brush_ops.c brush.h struct.h const.h buttons.h engine.h \
- global.h graph.h misc.h operatio.h pages.h sdlscreen.h windows.h
-$(OBJDIR)/buttons.o: buttons.c const.h struct.h global.h misc.h graph.h engine.h \
- readline.h filesel.h loadsave.h init.h buttons.h operatio.h pages.h \
- palette.h errors.h readini.h saveini.h shade.h io.h help.h text.h \
- sdlscreen.h windows.h brush.h input.h special.h
-$(OBJDIR)/buttons_effects.o: buttons_effects.c buttons.h struct.h const.h engine.h \
- global.h graph.h help.h input.h misc.h readline.h sdlscreen.h windows.h
-$(OBJDIR)/engine.o: engine.c const.h struct.h global.h graph.h misc.h special.h \
- buttons.h operatio.h shade.h errors.h sdlscreen.h windows.h brush.h \
- input.h engine.h pages.h layers.h
-$(OBJDIR)/factory.o: factory.c brush.h struct.h const.h buttons.h engine.h errors.h \
- filesel.h loadsave.h global.h graph.h io.h misc.h pages.h readline.h \
- sdlscreen.h windows.h palette.h input.h help.h
-$(OBJDIR)/fileformats.o: fileformats.c errors.h global.h struct.h const.h \
- loadsave.h misc.h io.h windows.h pages.h
-$(OBJDIR)/filesel.o: filesel.c const.h struct.h global.h misc.h errors.h io.h \
- windows.h sdlscreen.h loadsave.h mountlist.h engine.h readline.h input.h \
- help.h filesel.h
-$(OBJDIR)/graph.o: graph.c global.h struct.h const.h engine.h buttons.h pages.h \
- errors.h sdlscreen.h graph.h misc.h pxsimple.h pxtall.h pxwide.h \
- pxdouble.h pxtriple.h pxwide2.h pxtall2.h pxquad.h windows.h input.h
-$(OBJDIR)/help.o: help.c const.h struct.h global.h misc.h engine.h helpfile.h \
- help.h sdlscreen.h text.h keyboard.h windows.h input.h hotkeys.h \
- errors.h pages.h
-$(OBJDIR)/hotkeys.o: hotkeys.c struct.h const.h global.h hotkeys.h
-$(OBJDIR)/init.o: init.c buttons.h struct.h const.h errors.h global.h graph.h \
- init.h io.h factory.h help.h hotkeys.h keyboard.h loadsave.h misc.h \
- mountlist.h operatio.h palette.h sdlscreen.h setup.h transform.h \
- windows.h layers.h
-$(OBJDIR)/input.o: input.c global.h struct.h const.h keyboard.h sdlscreen.h \
- windows.h errors.h misc.h input.h
-$(OBJDIR)/io.o: io.c struct.h const.h io.h realpath.h
-$(OBJDIR)/keyboard.o: keyboard.c global.h struct.h const.h keyboard.h
-$(OBJDIR)/layers.o: layers.c const.h struct.h global.h windows.h engine.h pages.h \
- sdlscreen.h input.h help.h misc.h
-$(OBJDIR)/libraw2crtc.o: libraw2crtc.c const.h global.h struct.h loadsave.h
-$(OBJDIR)/loadsave.o: loadsave.c buttons.h struct.h const.h errors.h global.h io.h \
- loadsave.h misc.h graph.h op_c.h pages.h palette.h sdlscreen.h windows.h \
- engine.h
-$(OBJDIR)/main.o: main.c const.h struct.h global.h graph.h misc.h init.h buttons.h \
- engine.h pages.h loadsave.h sdlscreen.h errors.h readini.h saveini.h \
- io.h text.h setup.h windows.h brush.h palette.h realpath.h
-$(OBJDIR)/misc.o: misc.c struct.h const.h sdlscreen.h global.h errors.h buttons.h \
- engine.h misc.h keyboard.h windows.h palette.h input.h graph.h pages.h
-$(OBJDIR)/miscfileformats.o: miscfileformats.c engine.h struct.h const.h errors.h \
- global.h io.h libraw2crtc.h loadsave.h misc.h sdlscreen.h windows.h
-$(OBJDIR)/mountlist.o: mountlist.c mountlist.h
-$(OBJDIR)/op_c.o: op_c.c op_c.h struct.h const.h errors.h
-$(OBJDIR)/operatio.o: operatio.c const.h struct.h global.h misc.h engine.h graph.h \
- operatio.h buttons.h pages.h errors.h sdlscreen.h brush.h windows.h
-$(OBJDIR)/pages.o: pages.c global.h struct.h const.h pages.h errors.h loadsave.h \
- misc.h windows.h
-$(OBJDIR)/palette.o: palette.c const.h struct.h global.h misc.h engine.h readline.h \
- buttons.h pages.h help.h sdlscreen.h errors.h op_c.h windows.h input.h \
- palette.h shade.h
-$(OBJDIR)/pversion.o: pversion.c
-$(OBJDIR)/pxdouble.o: pxdouble.c global.h struct.h const.h sdlscreen.h misc.h \
- graph.h pxdouble.h pxwide.h
-$(OBJDIR)/pxquad.o: pxquad.c global.h struct.h const.h sdlscreen.h misc.h graph.h \
- pxquad.h
-$(OBJDIR)/pxsimple.o: pxsimple.c global.h struct.h const.h sdlscreen.h misc.h \
- graph.h pxsimple.h
-$(OBJDIR)/pxtall2.o: pxtall2.c global.h struct.h const.h sdlscreen.h misc.h graph.h \
- pxtall2.h
-$(OBJDIR)/pxtall.o: pxtall.c global.h struct.h const.h sdlscreen.h misc.h graph.h \
- pxtall.h pxsimple.h
-$(OBJDIR)/pxtriple.o: pxtriple.c global.h struct.h const.h sdlscreen.h misc.h \
- graph.h pxtriple.h
-$(OBJDIR)/pxwide2.o: pxwide2.c global.h struct.h const.h sdlscreen.h misc.h graph.h \
- pxwide2.h
-$(OBJDIR)/pxwide.o: pxwide.c global.h struct.h const.h sdlscreen.h misc.h graph.h \
- pxwide.h
-$(OBJDIR)/readini.o: readini.c const.h errors.h global.h struct.h misc.h readini.h
-$(OBJDIR)/readline.o: readline.c const.h struct.h global.h misc.h errors.h \
- sdlscreen.h readline.h windows.h input.h
-$(OBJDIR)/realpath.o: realpath.c
-$(OBJDIR)/saveini.o: saveini.c const.h global.h struct.h readini.h io.h errors.h \
- misc.h saveini.h
-$(OBJDIR)/sdlscreen.o: sdlscreen.c global.h struct.h const.h sdlscreen.h errors.h \
- misc.h
-$(OBJDIR)/setup.o: setup.c struct.h const.h io.h setup.h
-$(OBJDIR)/SFont.o: SFont.c SFont.h
-$(OBJDIR)/shade.o: shade.c global.h struct.h const.h graph.h engine.h errors.h \
- misc.h readline.h help.h sdlscreen.h windows.h input.h shade.h
-$(OBJDIR)/special.o: special.c const.h struct.h global.h graph.h engine.h windows.h \
- special.h pages.h misc.h buttons.h
-$(OBJDIR)/text.o: text.c SFont.h struct.h const.h global.h sdlscreen.h io.h \
- errors.h
-$(OBJDIR)/transform.o: transform.c global.h struct.h const.h transform.h engine.h \
- sdlscreen.h windows.h input.h help.h misc.h readline.h buttons.h pages.h
-$(OBJDIR)/version.o: version.c
-$(OBJDIR)/windows.o: windows.c windows.h struct.h const.h engine.h errors.h \
- global.h graph.h input.h misc.h readline.h sdlscreen.h
diff -ruN gfx2orig/src/misc.c grafx2/src/misc.c
--- gfx2orig/src/misc.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/misc.c	2022-03-20 20:19:34.108495316 -0500
@@ -107,7 +107,7 @@
       usage[color]++; //Un point de plus pour cette couleur
     }
   }
-  //On va maintenant compter dans la table les couleurs utilisées:
+  //On va maintenant compter dans la table les couleurs utilisÃ©es:
   for (i = 0; i < 256; i++)
   {
     if (usage[i]!=0)
@@ -130,7 +130,7 @@
   // Init usage table
   for (i = 0; i < 256; i++) usage[i]=0;
 
-  // On parcourt l'écran courant pour compter les utilisations des couleurs
+  // On parcourt l'Ã©cran courant pour compter les utilisations des couleurs
   for (y = 0; y < height; y++)
   {
     for (x = 0; x < width; x++)
@@ -141,7 +141,7 @@
     }
   }
 
-  //On va maintenant compter dans la table les couleurs utilisées:
+  //On va maintenant compter dans la table les couleurs utilisÃ©es:
   for (i = 0; i < 256; i++)
   {
     if (usage[i]!=0)
@@ -175,7 +175,7 @@
 
 void Wait_end_of_click(void)
 {
-  // On désactive tous les raccourcis clavier
+  // On dÃ©sactive tous les raccourcis clavier
 
   while(Mouse_K) if(!Get_input()) SDL_Delay(20);
 }
@@ -210,7 +210,7 @@
 }
 
 void Init_chrono(dword delay)
-  // Démarrer le chrono
+  // DÃ©marrer le chrono
 {
   Timer_delay = delay;
   Timer_start = SDL_GetTicks()/55;
@@ -238,7 +238,7 @@
       if (Read_pixel_from_current_layer(x,y) == old_color)
         Pixel_in_current_screen(x,y,new_color,0);
   Update_rect(0,0,0,0); // On peut TOUT a jour
-  // C'est pas un problème car il n'y a pas de preview
+  // C'est pas un problÃ¨me car il n'y a pas de preview
 }
 // FIXME: move to graph.c, it's the only caller
 
@@ -285,7 +285,7 @@
   {
     memcpy(edi,esi,width);
 
-    // Passe à la ligne suivante
+    // Passe Ã  la ligne suivante
     esi+=source_width;
     edi+=destination_width;
   }
@@ -358,7 +358,7 @@
 
 void Copy_image_to_brush(short start_x,short start_y,short Brush_width,short Brush_height,word image_width)
 {
-  byte* src=start_y*image_width+start_x+Main_backups->Pages->Image[Main_current_layer]; //Adr départ image (ESI)
+  byte* src=start_y*image_width+start_x+Main_backups->Pages->Image[Main_current_layer]; //Adr dÃ©part image (ESI)
   byte* dest=Brush; //Adr dest brosse (EDI)
   int dx;
 
@@ -369,7 +369,7 @@
     // On fait une copie de la ligne
     memcpy(dest,src,Brush_width);
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     src+=image_width;
     dest+=Brush_width;
   }
@@ -454,7 +454,7 @@
   byte red_under=Main_palette[color_under].R;
   byte red=Main_palette[color].R;
 
-  // On récupère les 3 composantes RVB
+  // On rÃ©cupÃ¨re les 3 composantes RVB
 
   // blue
   blue = (Factors_inv_table[blue]
@@ -515,7 +515,7 @@
 
   while(ESI < EDI)
   {
-    // Il faut inverser les lignes pointées par ESI et
+    // Il faut inverser les lignes pointÃ©es par ESI et
     // EDI ("Brush_width" octets en tout)
 
     for(cx = width;cx>0;cx--)
@@ -528,9 +528,9 @@
     }
 
     // On change de ligne :
-    // ESI pointe déjà sur le début de la ligne suivante
+    // ESI pointe dÃ©jÃ  sur le dÃ©but de la ligne suivante
     // EDI pointe sur la fin de la ligne en cours, il
-    // doit pointer sur le début de la précédente...
+    // doit pointer sur le dÃ©but de la prÃ©cÃ©dente...
     EDI -= 2 * width; // On recule de 2 lignes
   }
 }
@@ -552,7 +552,7 @@
     line_start = ESI;
     line_end = EDI;
 
-    // On échange par colonnes
+    // On Ã©change par colonnes
     for(cx=height;cx>0;cx--)
     {
       tmp=*ESI;
@@ -564,16 +564,16 @@
 
     // On change de colonne
     // ESI > colonne suivante
-    // EDI > colonne précédente
+    // EDI > colonne prÃ©cÃ©dente
     ESI = line_start + 1;
     EDI = line_end - 1;
   }
 }
 
-// Rotate a pixel buffer 180º on itself.
+// Rotate a pixel buffer 180Âº on itself.
 void Rotate_180_deg_lowlevel(byte *src, short width, short height)
 {
-  // ESI pointe sur la partie supérieure de la brosse
+  // ESI pointe sur la partie supÃ©rieure de la brosse
   // EDI pointe sur la partie basse
   byte* ESI = src;
   byte* EDI = src + height*width - 1;
@@ -593,9 +593,9 @@
 
   while(ESI < EDI)
   {
-    // On échange les deux lignes pointées par EDI et
+    // On Ã©change les deux lignes pointÃ©es par EDI et
     // ESI (Brush_width octets)
-    // En même temps, on échange les pixels, donc EDI
+    // En mÃªme temps, on Ã©change les pixels, donc EDI
     // pointe sur la FIN de sa ligne
 
     for(cx=width;cx>0;cx--)
@@ -616,11 +616,11 @@
 
   int    x_pos_in_brush;   // Position courante dans l'ancienne brosse
   int    y_pos_in_brush;
-  int    delta_x_in_brush; // "Vecteur incrémental" du point précédent
+  int    delta_x_in_brush; // "Vecteur incrÃ©mental" du point prÃ©cÃ©dent
   int    delta_y_in_brush;
-  int    initial_x_pos;       // Position X de début de parcours de ligne
+  int    initial_x_pos;       // Position X de dÃ©but de parcours de ligne
 
-  // Calcul du "vecteur incrémental":
+  // Calcul du "vecteur incrÃ©mental":
   delta_x_in_brush=(src_width<<16) * (x_flipped?-1:1) / (dst_width);
   delta_y_in_brush=(src_height<<16) * (y_flipped?-1:1) / (dst_height);
 
@@ -641,7 +641,7 @@
   // Pour chaque ligne
   for (line=0;line<dst_height;line++)
   {
-    // On repart du début de la ligne:
+    // On repart du dÃ©but de la ligne:
     x_pos_in_brush=initial_x_pos;
 
     // Pour chaque colonne:
@@ -649,18 +649,18 @@
     {
       // On copie le pixel:
       dst_buffer[offset]=*(src_buffer + (x_pos_in_brush>>16) + (y_pos_in_brush>>16)*src_width);
-      // On passe à la colonne de brosse suivante:
+      // On passe Ã  la colonne de brosse suivante:
       x_pos_in_brush+=delta_x_in_brush;
       // On passe au pixel suivant de la nouvelle brosse:
       offset++;
     }
-    // On passe à la ligne de brosse suivante:
+    // On passe Ã  la ligne de brosse suivante:
     y_pos_in_brush+=delta_y_in_brush;
   }
 }
 
 void Slider_timer(byte speed)
-  //Boucle d'attente pour faire bouger les scrollbars à une vitesse correcte
+  //Boucle d'attente pour faire bouger les scrollbars Ã  une vitesse correcte
 {
   Uint32 end;
   byte original_mouse_k = Mouse_K;
@@ -675,7 +675,7 @@
 {
   byte* src = main_src; //source de la copie
   byte* dest = main_dest + y_offset * Main_image_width + x_offset;
-  const word length = Main_image_width - x_offset; // Nombre de pixels à copier à droite
+  const word length = Main_image_width - x_offset; // Nombre de pixels Ã  copier Ã  droite
   word y;
   for(y = Main_image_height - y_offset;y>0;y--)
   {
@@ -683,7 +683,7 @@
     memcpy(dest,src,length);
     memcpy(dest - x_offset,src+length,x_offset);
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     dest += Main_image_width;
     src += Main_image_width;
   }
@@ -734,12 +734,14 @@
   #include <proto/exec.h>
 #elif defined(__SKYOS__)
   #include <skyos/sysinfo.h>
+#elif defined(FDOS)
+  #include <dpmi.h> // __dpmi_get_free_memory_information
 #else
   #include <sys/sysinfo.h> // sysinfo() for free RAM
 #endif
 
 
-// Indique quelle est la mémoire disponible
+// Indique quelle est la mÃ©moire disponible
 unsigned long Memory_free(void)
 {
   // Memory is no longer relevant. If there is ANY problem or doubt here,
@@ -772,6 +774,24 @@
   return 10*1024*1024;
 #elif defined(__AROS__) || defined(__MORPHOS__) || defined(__amigaos__)
   return AvailMem(MEMF_ANY);
+#elif defined(FDOS)
+    // Free memory under DPMI is complicated. The '__dpmi_free_mem_info' struct
+    // contains the following members:
+    //     largest_available_free_block_in_bytes
+    //     maximum_unlocked_page_allocation_in_pages
+    //     maximum_locked_page_allocation_in_pages
+    //     linear_address_space_size_in_pages
+    //     total_number_of_unlocked_pages
+    //     total_number_of_free_pages
+    //     total_number_of_physical_pages
+    //     free_linear_address_space_in_pages
+    //     size_of_paging_file_partition_in_pages
+    long val;
+    __dpmi_free_mem_info info;
+    __dpmi_get_free_memory_information(&info); 
+    val = info.largest_available_free_block_in_bytes;
+    // Some DPMI servers may return -1. If so, per Grafx2 guidance, return 10Mb.
+    return (val > 0 ? val : 10*1024*1024);
 #else
   struct sysinfo info;
   sysinfo(&info);
@@ -780,7 +800,7 @@
 }
 
 
-// Arrondir un nombre réel à la valeur entière la plus proche
+// Arrondir un nombre rÃ©el Ã  la valeur entiÃ¨re la plus proche
 // TODO : this should probably be replaced with round() from C99...
 short Round(float value)
 {
@@ -795,7 +815,7 @@
 }
 
 
-// Arrondir le résultat d'une division à la valeur entière supérieure
+// Arrondir le rÃ©sultat d'une division Ã  la valeur entiÃ¨re supÃ©rieure
 short Round_div_max(short numerator,short divisor)
 {
   if (!(numerator % divisor))
@@ -827,7 +847,7 @@
 }
 
 
-// Fonction retournant le libellé d'une mode (ex: " 320x200")
+// Fonction retournant le libellÃ© d'une mode (ex: " 320x200")
 char * Mode_label(int mode)
 {
   static char str[24];
@@ -839,12 +859,12 @@
 }
 
 
-// Trouve un mode video à partir d'une chaine: soit "window",
+// Trouve un mode video Ã  partir d'une chaine: soit "window",
 // soit de la forme "320x200"
 // Renvoie -1 si la chaine n'est pas convertible
 int Convert_videomode_arg(const char *argument)
 {
-  // Je suis paresseux alors je vais juste tester les libellés
+  // Je suis paresseux alors je vais juste tester les libellÃ©s
   int mode_index;
   for (mode_index=0; mode_index<Nb_video_modes; mode_index++)
     // Attention les vieilles fonctions de lecture .ini mettent tout en MAJUSCULE.
diff -ruN gfx2orig/src/miscfileformats.c grafx2/src/miscfileformats.c
--- gfx2orig/src/miscfileformats.c	2010-03-17 13:11:14.000000000 -0500
+++ grafx2/src/miscfileformats.c	2022-03-20 20:19:34.108495316 -0500
@@ -59,11 +59,11 @@
   {
     // Lecture de la taille du fichier
     file_size = File_length_file(file);
-    // Le fichier ne peut être au format PAL que si sa taille vaut 768 octets
+    // Le fichier ne peut Ãªtre au format PAL que si sa taille vaut 768 octets
     if (file_size == sizeof(T_Palette))
       File_error = 0;
     else {
-      // Sinon c'est peut être un fichier palette ASCII "Jasc"
+      // Sinon c'est peut Ãªtre un fichier palette ASCII "Jasc"
       fread(filename, 1, 8, file);
       if (strncmp(filename,"JASC-PAL",8) == 0)
       {
@@ -90,7 +90,7 @@
   if ((file=fopen(filename, "rb")))
   {
     long file_size = File_length_file(file);
-    // Le fichier ne peut être au format PAL que si sa taille vaut 768 octets
+    // Le fichier ne peut Ãªtre au format PAL que si sa taille vaut 768 octets
     if (file_size == sizeof(T_Palette))
     {
       T_Palette palette_64;
@@ -135,7 +135,7 @@
     fclose(file);
   }
   else
-    // Si on n'a pas réussi à ouvrir le fichier, alors il y a eu une erreur
+    // Si on n'a pas rÃ©ussi Ã  ouvrir le fichier, alors il y a eu une erreur
     File_error=1;
 }
 
@@ -216,9 +216,9 @@
         Read_bytes(file,&header.Palette,sizeof(T_Palette)) &&
         Read_word_le(file,&header.Jump))
     {
-      // On regarde s'il y a la signature PKM suivie de la méthode 0.
-      // La constante "PKM" étant un chaîne, elle se termine toujours par 0.
-      // Donc pas la peine de s'emm...er à regarder si la méthode est à 0.
+      // On regarde s'il y a la signature PKM suivie de la mÃ©thode 0.
+      // La constante "PKM" Ã©tant un chaÃ®ne, elle se termine toujours par 0.
+      // Donc pas la peine de s'emm...er Ã  regarder si la mÃ©thode est Ã  0.
       if ( (!memcmp(&header,"PKM",4)) && header.Width && header.Height)
         File_error=0;
     }
@@ -298,7 +298,7 @@
                   File_error=2;
                 break;
 
-              case 1 : // Dimensions de l'écran d'origine
+              case 1 : // Dimensions de l'Ã©cran d'origine
                 if (Read_byte(file,&temp_byte))
                 {
                   if (temp_byte==4)
@@ -369,7 +369,7 @@
           Compteur_de_pixels=0;
           Taille_pack=(file_size)-sizeof(T_PKM_Header)-header.Jump;
 
-          // Boucle de décompression:
+          // Boucle de dÃ©compression:
           while ( (Compteur_de_pixels<image_size) && (Compteur_de_donnees_packees<Taille_pack) && (!File_error) )
           {
             if(Read_byte(file, &temp_byte)!=1) 
@@ -387,7 +387,7 @@
               Compteur_de_donnees_packees++;
               Compteur_de_pixels++;
             }
-            else // Sinon, On regarde si on va décompacter un...
+            else // Sinon, On regarde si on va dÃ©compacter un...
             { // ... nombre de pixels tenant sur un byte
                 if (temp_byte==header.Recog1)
                 {
@@ -453,10 +453,10 @@
     // On commence par compter l'utilisation de chaque couleurs
     Count_used_colors(Find_recon);
 
-    // Ensuite recog1 devient celle la moins utilisée de celles-ci
+    // Ensuite recog1 devient celle la moins utilisÃ©e de celles-ci
     *recog1=0;
     best=1;
-    NBest=INT_MAX; // Une même couleur ne pourra jamais être utilisée 1M de fois.
+    NBest=INT_MAX; // Une mÃªme couleur ne pourra jamais Ãªtre utilisÃ©e 1M de fois.
     for (index=1;index<=255;index++)
       if (Find_recon[index]<NBest)
       {
@@ -465,7 +465,7 @@
       }
     *recog1=best;
 
-    // Enfin recog2 devient la 2ème moins utilisée
+    // Enfin recog2 devient la 2Ã¨me moins utilisÃ©e
     *recog2=0;
     best=0;
     NBest=INT_MAX;
@@ -529,7 +529,7 @@
       Init_write_buffer();
 
       // Ecriture du commentaire
-      // (Compteur_de_pixels est utilisé ici comme simple index de comptage)
+      // (Compteur_de_pixels est utilisÃ© ici comme simple index de comptage)
       if (comment_size)
       {
         Write_one_byte(file,0);
@@ -537,7 +537,7 @@
         for (Compteur_de_pixels=0; Compteur_de_pixels<comment_size; Compteur_de_pixels++)
           Write_one_byte(file,context->Comment[Compteur_de_pixels]);
       }
-      // Ecriture des dimensions de l'écran
+      // Ecriture des dimensions de l'Ã©cran
       Write_one_byte(file,1);
       Write_one_byte(file,4);
       Write_one_byte(file,Screen_width&0xFF);
@@ -628,8 +628,8 @@
     File_error=1;
     fclose(file);
   }
-  //   S'il y a eu une erreur de sauvegarde, on ne va tout de même pas laisser
-  // ce fichier pourri traîner... Ca fait pas propre.
+  //   S'il y a eu une erreur de sauvegarde, on ne va tout de mÃªme pas laisser
+  // ce fichier pourri traÃ®ner... Ca fait pas propre.
   if (File_error)
     remove(filename);
 }
@@ -686,7 +686,7 @@
       Read_word_le(file,&header1.Height) )
   {
       //   Vu que ce header n'a pas de signature, il va falloir tester la
-      // cohérence de la dimension de l'image avec celle du fichier.
+      // cohÃ©rence de la dimension de l'image avec celle du fichier.
       
       size=file_size-sizeof(T_CEL_Header1);
       if ( (!size) || ( (((header1.Width+1)>>1)*header1.Height)!=size ) )
@@ -771,7 +771,7 @@
       }
       else
       {
-        // On réessaye avec le nouveau format
+        // On rÃ©essaye avec le nouveau format
 
         fseek(file,0,SEEK_SET);
         if (Read_bytes(file,header2.Signature,sizeof(header2.Signature))
@@ -799,7 +799,7 @@
 
             if (!File_error)
             {
-              // Effacement du décalage
+              // Effacement du dÃ©calage
               for (y_pos=0;y_pos<header2.Y_offset;y_pos++)
                 for (x_pos=0;x_pos<context->Width;x_pos++)
                   Set_pixel(context, x_pos,y_pos,0);
@@ -872,12 +872,12 @@
   Get_full_filename(filename, context->File_name, context->File_directory);
   if ((file=fopen(filename,"wb")))
   {
-    // On regarde si des couleurs >16 sont utilisées dans l'image
+    // On regarde si des couleurs >16 sont utilisÃ©es dans l'image
     for (x_pos=16;((x_pos<256) && (!Utilisation[x_pos]));x_pos++);
 
     if (x_pos==256)
     {
-      // Cas d'une image 16 couleurs (écriture à l'ancien format)
+      // Cas d'une image 16 couleurs (Ã©criture Ã  l'ancien format)
 
       header1.Width =context->Width;
       header1.Height=context->Height;
@@ -910,9 +910,9 @@
     }
     else
     {
-      // Cas d'une image 256 couleurs (écriture au nouveau format)
+      // Cas d'une image 256 couleurs (Ã©criture au nouveau format)
 
-      // Recherche du décalage
+      // Recherche du dÃ©calage
       for (y_pos=0;y_pos<context->Height;y_pos++)
       {
         for (x_pos=0;x_pos<context->Width;x_pos++)
@@ -1005,7 +1005,7 @@
     if (File_length_file(file)==sizeof(T_KCF_Header))
     {
       Read_bytes(file,&buffer,sizeof(T_KCF_Header));
-      // On vérifie une propriété de la structure de palette:
+      // On vÃ©rifie une propriÃ©tÃ© de la structure de palette:
       for (pal_index=0;pal_index<10;pal_index++)
         for (color_index=0;color_index<16;color_index++)
           if ((buffer.Palette[pal_index].color[color_index].Byte2>>4)!=0)
@@ -1064,7 +1064,7 @@
     file_size=File_length_file(file);
     if (file_size==sizeof(T_KCF_Header))
     {
-      // Fichier KCF à l'ancien format
+      // Fichier KCF Ã  l'ancien format
 
       if (Read_bytes(file,&buffer,sizeof(T_KCF_Header)))
       {
@@ -1184,12 +1184,12 @@
   {
     // Sauvegarde de la palette
 
-    // On regarde si des couleurs >16 sont utilisées dans l'image
+    // On regarde si des couleurs >16 sont utilisÃ©es dans l'image
     for (index=16;((index<256) && (!Utilisation[index]));index++);
 
     if (index==256)
     {
-      // Cas d'une image 16 couleurs (écriture à l'ancien format)
+      // Cas d'une image 16 couleurs (Ã©criture Ã  l'ancien format)
 
       for (pal_index=0;pal_index<10;pal_index++)
         for (color_index=0;color_index<16;color_index++)
@@ -1204,7 +1204,7 @@
     }
     else
     {
-      // Cas d'une image 256 couleurs (écriture au nouveau format)
+      // Cas d'une image 256 couleurs (Ã©criture au nouveau format)
 
       memcpy(header2.Signature,"KiSS",4); // Initialisation de la signature
       header2.Kind=0x10;              // Initialisation du type (PALette)
@@ -1212,8 +1212,8 @@
       header2.Filler1=0;              // Initialisation du filler 1 (?)
       header2.Width=256;            // Initialisation du nombre de couleurs
       header2.Height=1;              // Initialisation du nombre de palettes
-      header2.X_offset=0;           // Initialisation du décalage X
-      header2.Y_offset=0;           // Initialisation du décalage Y
+      header2.X_offset=0;           // Initialisation du dÃ©calage X
+      header2.Y_offset=0;           // Initialisation du dÃ©calage Y
       for (index=0;index<16;index++) // Initialisation du filler 2 (?)
         header2.Filler2[index]=0;
 
@@ -1255,9 +1255,9 @@
 
 void PI1_8b_to_16p(byte * src,byte * dest)
 {
-  int  i;           // index du pixel à calculer
+  int  i;           // index du pixel Ã  calculer
   word byte_mask;      // Masque de decodage
-  word w0,w1,w2,w3; // Les 4 words bien ordonnés de la source
+  word w0,w1,w2,w3; // Les 4 words bien ordonnÃ©s de la source
 
   byte_mask=0x8000;
   w0=(((word)src[0])<<8) | src[1];
@@ -1266,8 +1266,8 @@
   w3=(((word)src[6])<<8) | src[7];
   for (i=0;i<16;i++)
   {
-    // Pour décoder le pixel n°i, il faut traiter les 4 words sur leur bit
-    // correspondant à celui du masque
+    // Pour dÃ©coder le pixel nÂ°i, il faut traiter les 4 words sur leur bit
+    // correspondant Ã  celui du masque
 
     dest[i]=((w0 & byte_mask)?0x01:0x00) |
            ((w1 & byte_mask)?0x02:0x00) |
@@ -1281,16 +1281,16 @@
 
 void PI1_16p_to_8b(byte * src,byte * dest)
 {
-  int  i;           // index du pixel à calculer
+  int  i;           // index du pixel Ã  calculer
   word byte_mask;      // Masque de codage
-  word w0,w1,w2,w3; // Les 4 words bien ordonnés de la destination
+  word w0,w1,w2,w3; // Les 4 words bien ordonnÃ©s de la destination
 
   byte_mask=0x8000;
   w0=w1=w2=w3=0;
   for (i=0;i<16;i++)
   {
-    // Pour coder le pixel n°i, il faut modifier les 4 words sur leur bit
-    // correspondant à celui du masque
+    // Pour coder le pixel nÂ°i, il faut modifier les 4 words sur leur bit
+    // correspondant Ã  celui du masque
 
     w0|=(src[i] & 0x01)?byte_mask:0x00;
     w1|=(src[i] & 0x02)?byte_mask:0x00;
@@ -1312,11 +1312,11 @@
 
 void PI1_decode_palette(byte * src,byte * palette)
 {
-  int i;  // Numéro de la couleur traitée
+  int i;  // NumÃ©ro de la couleur traitÃ©e
   int ip; // index dans la palette
   word w; // Word contenant le code
 
-  // Schéma d'un word =
+  // SchÃ©ma d'un word =
   //
   //    Low        High
   // VVVV RRRR | 0000 BBBB
@@ -1338,11 +1338,11 @@
 
 void PI1_code_palette(byte * palette,byte * dest)
 {
-  int i;  // Numéro de la couleur traitée
+  int i;  // NumÃ©ro de la couleur traitÃ©e
   int ip; // index dans la palette
   word w; // Word contenant le code
 
-  // Schéma d'un word =
+  // SchÃ©ma d'un word =
   //
   //    Low        High
   // VVVV RRRR | 0000 BBBB
@@ -1368,7 +1368,7 @@
   FILE * file;              // Fichier du fichier
   char filename[MAX_PATH_CHARACTERS]; // Nom complet du fichier
   int  size;              // Taille du fichier
-  word resolution;                 // Résolution de l'image
+  word resolution;                 // RÃ©solution de l'image
 
 
   Get_full_filename(filename, context->File_name, context->File_directory);
@@ -1378,11 +1378,11 @@
   // Ouverture du fichier
   if ((file=fopen(filename, "rb")))
   {
-    // Vérification de la taille
+    // VÃ©rification de la taille
     size=File_length_file(file);
     if ((size==32034) || (size==32066))
     {
-      // Lecture et vérification de la résolution
+      // Lecture et vÃ©rification de la rÃ©solution
       if (Read_word_le(file,&resolution))
       {
         if (resolution==0x0000)
@@ -1410,7 +1410,7 @@
   File_error=0;
   if ((file=fopen(filename, "rb")))
   {
-    // allocation d'un buffer mémoire
+    // allocation d'un buffer mÃ©moire
     buffer=(byte *)malloc(32034);
     if (buffer!=NULL)
     {
@@ -1430,7 +1430,7 @@
           context->Width=320;
           context->Height=200;
 
-          // Chargement/décompression de l'image
+          // Chargement/dÃ©compression de l'image
           ptr=buffer+34;
           for (y_pos=0;y_pos<200;y_pos++)
           {
@@ -1474,9 +1474,9 @@
   // Ouverture du fichier
   if ((file=fopen(filename,"wb")))
   {
-    // allocation d'un buffer mémoire
+    // allocation d'un buffer mÃ©moire
     buffer=(byte *)malloc(32066);
-    // Codage de la résolution
+    // Codage de la rÃ©solution
     buffer[0]=0x00;
     buffer[1]=0x00;
     // Codage de la palette
@@ -1506,13 +1506,13 @@
     {
       fclose(file);
     }
-    else // Error d'écriture (disque plein ou protégé)
+    else // Error d'Ã©criture (disque plein ou protÃ©gÃ©)
     {
       fclose(file);
       remove(filename);
       File_error=1;
     }
-    // Libération du buffer mémoire
+    // LibÃ©ration du buffer mÃ©moire
     free(buffer);
     buffer = NULL;
   }
@@ -1527,12 +1527,12 @@
 
 //////////////////////////////////// PC1 ////////////////////////////////////
 
-//// DECOMPRESSION d'un buffer selon la méthode PACKBITS ////
+//// DECOMPRESSION d'un buffer selon la mÃ©thode PACKBITS ////
 
 void PC1_uncompress_packbits(byte * src,byte * dest)
 {
   int is,id; // Les indices de parcour des buffers
-  int n;     // Octet de contrôle
+  int n;     // Octet de contrÃ´le
 
   for (is=id=0;id<32000;)
   {
@@ -1548,31 +1548,31 @@
     }
     else
     {
-      // Recopier n+1 octets littéralement
+      // Recopier n+1 octets littÃ©ralement
       n=n+1;
       for (;(n>0) && (id<32000);n--)
         dest[id++]=src[is++];
     }
 
-    // Contrôle des erreurs
+    // ContrÃ´le des erreurs
     if (n>0)
       File_error=1;
   }
 }
 
-//// COMPRESSION d'un buffer selon la méthode PACKBITS ////
+//// COMPRESSION d'un buffer selon la mÃ©thode PACKBITS ////
 
 void PC1_compress_packbits(byte * src,byte * dest,int source_size,int * dest_size)
 {
   int is; // index dans la source
   int id; // index dans la destination
-  int ir; // index de   la répétition
-  int n;  // Taille des séquences
-  int repet; // "Il y a répétition"
+  int ir; // index de   la rÃ©pÃ©tition
+  int n;  // Taille des sÃ©quences
+  int repet; // "Il y a rÃ©pÃ©tition"
 
   for (is=id=0;is<source_size;)
   {
-    // On recherche le 1er endroit où il y a répétition d'au moins 3 valeurs
+    // On recherche le 1er endroit oÃ¹ il y a rÃ©pÃ©tition d'au moins 3 valeurs
     // identiques
 
     repet=0;
@@ -1587,7 +1587,7 @@
         break;
     }
 
-    // On code la partie sans répétitions
+    // On code la partie sans rÃ©pÃ©titions
     if (ir!=is)
     {
       n=(ir-is)+1;
@@ -1596,10 +1596,10 @@
         dest[id++]=src[is++];
     }
 
-    // On code la partie sans répétitions
+    // On code la partie sans rÃ©pÃ©titions
     if (repet)
     {
-      // On compte la quantité de fois qu'il faut répéter la valeur
+      // On compte la quantitÃ© de fois qu'il faut rÃ©pÃ©ter la valeur
       for (ir+=3;ir<source_size;ir++)
       {
         if (src[ir]!=src[is])
@@ -1614,7 +1614,7 @@
     }
   }
 
-  // On renseigne la taille du buffer compressé
+  // On renseigne la taille du buffer compressÃ©
   *dest_size=id;
 }
 
@@ -1625,7 +1625,7 @@
 void PC1_4bp_to_1line(byte * src0,byte * src1,byte * src2,byte * src3,byte * dest)
 {
   int  i,j;         // Compteurs
-  int  ip;          // index du pixel à calculer
+  int  ip;          // index du pixel Ã  calculer
   byte byte_mask;      // Masque de decodage
   byte b0,b1,b2,b3; // Les 4 octets des plans bits sources
 
@@ -1657,7 +1657,7 @@
 void PC1_1line_to_4bp(byte * src,byte * dst0,byte * dst1,byte * dst2,byte * dst3)
 {
   int  i,j;         // Compteurs
-  int  ip;          // index du pixel à calculer
+  int  ip;          // index du pixel Ã  calculer
   byte byte_mask;      // Masque de decodage
   byte b0,b1,b2,b3; // Les 4 octets des plans bits sources
 
@@ -1691,7 +1691,7 @@
   FILE *file;              // Fichier du fichier
   char filename[MAX_PATH_CHARACTERS]; // Nom complet du fichier
   int  size;              // Taille du fichier
-  word resolution;                 // Résolution de l'image
+  word resolution;                 // RÃ©solution de l'image
 
 
   Get_full_filename(filename, context->File_name, context->File_directory);
@@ -1701,11 +1701,11 @@
   // Ouverture du fichier
   if ((file=fopen(filename, "rb")))
   {
-    // Vérification de la taille
+    // VÃ©rification de la taille
     size=File_length_file(file);
     if ((size<=32066))
     {
-      // Lecture et vérification de la résolution
+      // Lecture et vÃ©rification de la rÃ©solution
       if (Read_word_le(file,&resolution))
       {
         if (resolution==0x0080)
@@ -1736,7 +1736,7 @@
   if ((file=fopen(filename, "rb")))
   {
     size=File_length_file(file);
-    // allocation des buffers mémoire
+    // allocation des buffers mÃ©moire
     buffercomp=(byte *)malloc(size);
     bufferdecomp=(byte *)malloc(32000);
     if ( (buffercomp!=NULL) && (bufferdecomp!=NULL) )
@@ -1757,14 +1757,14 @@
           context->Width=320;
           context->Height=200;
 
-          // Décompression du buffer
+          // DÃ©compression du buffer
           PC1_uncompress_packbits(buffercomp+34,bufferdecomp);
 
-          // Décodage de l'image
+          // DÃ©codage de l'image
           ptr=bufferdecomp;
           for (y_pos=0;y_pos<200;y_pos++)
           {
-            // Décodage de la scanline
+            // DÃ©codage de la scanline
             PC1_4bp_to_1line(ptr,ptr+40,ptr+80,ptr+120,pixels);
             ptr+=160;
             // Chargement de la ligne
@@ -1811,10 +1811,10 @@
   // Ouverture du fichier
   if ((file=fopen(filename,"wb")))
   {
-    // Allocation des buffers mémoire
+    // Allocation des buffers mÃ©moire
     bufferdecomp=(byte *)malloc(32000);
     buffercomp  =(byte *)malloc(64066);
-    // Codage de la résolution
+    // Codage de la rÃ©solution
     buffercomp[0]=0x80;
     buffercomp[1]=0x00;
     // Codage de la palette
@@ -1846,13 +1846,13 @@
     {
       fclose(file);
     }
-    else // Error d'écriture (disque plein ou protégé)
+    else // Error d'Ã©criture (disque plein ou protÃ©gÃ©)
     {
       fclose(file);
       remove(filename);
       File_error=1;
     }
-    // Libération des buffers mémoire
+    // LibÃ©ration des buffers mÃ©moire
     free(bufferdecomp);
     free(buffercomp);
     buffercomp = bufferdecomp = NULL;
@@ -1873,7 +1873,7 @@
   FILE *file;              // Fichier du fichier
   char filename[MAX_PATH_CHARACTERS]; // Nom complet du fichier
   int  size;              // Taille du fichier
-  word resolution;                 // Résolution de l'image
+  word resolution;                 // RÃ©solution de l'image
 
 
   Get_full_filename(filename, context->File_name, context->File_directory);
@@ -1883,7 +1883,7 @@
   // Ouverture du fichier
   if ((file=fopen(filename, "rb")))
   {
-    // Vérification de la taille
+    // VÃ©rification de la taille
     size=File_length_file(file);
     if ((size==32128))
     {
@@ -1894,7 +1894,7 @@
           File_error = 0;
       }
 
-      // Lecture et vérification de la résolution
+      // Lecture et vÃ©rification de la rÃ©solution
       if (Read_word_le(file,&resolution))
       {
         if (resolution==0 || resolution==1 || resolution==2)
@@ -1921,7 +1921,7 @@
   File_error=0;
   if ((file=fopen(filename, "rb")))
   {
-    // allocation d'un buffer mémoire
+    // allocation d'un buffer mÃ©moire
     buffer=(byte *)malloc(32128);
     if (buffer!=NULL)
     {
@@ -1935,14 +1935,14 @@
           // Initialisation de la palette
           if (Config.Clear_palette)
             memset(context->Palette,0,sizeof(T_Palette));
-          // on saute la résolution et le flag, chacun 2 bits
+          // on saute la rÃ©solution et le flag, chacun 2 bits
           PI1_decode_palette(buffer+4,(byte *)context->Palette);
           Palette_loaded(context);
 
           context->Width=320;
           context->Height=200;
 
-          // Chargement/décompression de l'image
+          // Chargement/dÃ©compression de l'image
           ptr=buffer+128;
           for (y_pos=0;y_pos<200;y_pos++)
           {
@@ -1984,9 +1984,9 @@
   // Ouverture du fichier
   if ((file=fopen(filename,"wb")))
   {
-    // allocation d'un buffer mémoire
+    // allocation d'un buffer mÃ©moire
     buffer=(byte *)malloc(32128);
-    // Codage de la résolution
+    // Codage de la rÃ©solution
     buffer[0]=0x00;
     buffer[1]=0x00;
     buffer[2]=0x00;
@@ -2016,13 +2016,13 @@
     {
       fclose(file);
     }
-    else // Error d'écriture (disque plein ou protégé)
+    else // Error d'Ã©criture (disque plein ou protÃ©gÃ©)
     {
       fclose(file);
       remove(filename);
       File_error=1;
     }
-    // Libération du buffer mémoire
+    // LibÃ©ration du buffer mÃ©moire
     free(buffer);
     buffer = NULL;
   }
diff -ruN gfx2orig/src/misc.h grafx2/src/misc.h
--- gfx2orig/src/misc.h	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/misc.h	2022-03-20 20:19:34.112495316 -0500
@@ -22,6 +22,8 @@
 ///@file misc.h
 /// Miscellanous unsorted functions.
 //////////////////////////////////////////////////////////////////////////////
+#ifndef MISC_H
+#define MISC_H
 
 #include "struct.h"
 
@@ -54,7 +56,7 @@
 byte Read_pixel_from_brush         (word x,word y);
 
 void Ellipse_compute_limites(short horizontal_radius,short vertical_radius);
-// Calcule les valeurs suivantes en fonction des deux paramètres:
+// Calcule les valeurs suivantes en fonction des deux paramÃ¨tres:
 //
 // Ellipse_vertical_radius_squared
 // Ellipse_horizontal_radius_squared
@@ -63,15 +65,15 @@
 
 
 byte Pixel_in_ellipse(void);
-//   Indique si le pixel se trouvant à Ellipse_cursor_X pixels
-// (Ellipse_cursor_X>0 = à droite, Ellipse_cursor_X<0 = à gauche) et à
+//   Indique si le pixel se trouvant Ã  Ellipse_cursor_X pixels
+// (Ellipse_cursor_X>0 = Ã  droite, Ellipse_cursor_X<0 = Ã  gauche) et Ã 
 // Ellipse_cursor_Y pixels (Ellipse_cursor_Y>0 = en bas,
 // Ellipse_cursor_Y<0 = en haut) du centre se trouve dans l'ellipse en
 // cours.
 
 byte Pixel_in_circle(void);
-//   Indique si le pixel se trouvant à Circle_cursor_X pixels
-// (Circle_cursor_X>0 = à droite, Circle_cursor_X<0 = à gauche) et à
+//   Indique si le pixel se trouvant Ã  Circle_cursor_X pixels
+// (Circle_cursor_X>0 = Ã  droite, Circle_cursor_X<0 = Ã  gauche) et Ã 
 // Circle_cursor_Y pixels (Circle_cursor_Y>0 = en bas,
 // Circle_cursor_Y<0 = en haut) du centre se trouve dans le cercle en
 // cours.
@@ -138,12 +140,12 @@
 void Copy_part_of_image_to_another(byte * source,word source_x,word source_y,word width,word height,word source_width,byte * dest,word dest_x,word dest_y,word destination_width);
 
 // -- Gestion du chrono --
-byte Timer_state; // State du chrono: 0=Attente d'un Xème de seconde
+byte Timer_state; // State du chrono: 0=Attente d'un XÃ¨me de seconde
                   //                 1=Il faut afficher la preview
-                  //                 2=Plus de chrono à gerer pour l'instant
-dword Timer_delay;     // Nombre de 18.2ème de secondes demandés
-dword Timer_start;       // Heure de départ du chrono
-byte New_preview_is_needed; // Booléen "Il faut relancer le chrono de preview"
+                  //                 2=Plus de chrono Ã  gerer pour l'instant
+dword Timer_delay;     // Nombre de 18.2Ã¨me de secondes demandÃ©s
+dword Timer_start;       // Heure de dÃ©part du chrono
+byte New_preview_is_needed; // BoolÃ©en "Il faut relancer le chrono de preview"
 
 
 unsigned long Memory_free(void);
@@ -165,3 +167,5 @@
 
 char* Mode_label(int mode);
 int Convert_videomode_arg(const char *argument);
+
+#endif /* MISC_H */
diff -ruN gfx2orig/src/mountlist.c grafx2/src/mountlist.c
--- gfx2orig/src/mountlist.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/mountlist.c	2022-03-20 20:19:34.108495316 -0500
@@ -348,6 +348,10 @@
      here.  */
 # ifndef __linux__
 
+# if defined(FDOS)
+   // Silence 'unused parameter' compiler warning.
+   (void)mount_options;
+#else
   static char const dev_pattern[] = ",dev=";
   char const *devopt = strstr (mount_options, dev_pattern);
 
@@ -366,6 +370,7 @@
     }
 
 # endif
+# endif
 
   return -1;
 }
@@ -384,6 +389,10 @@
   struct mount_entry *me;
   struct mount_entry **mtail = &mount_list;
 
+#if defined(FDOS)
+  // Silence compiler warning.
+  (void) need_fs_type;
+#endif
 #ifdef MOUNTED_LISTMNTENT
   {
     struct tabmntent *mntlist, *p;
diff -ruN gfx2orig/src/op_c.c grafx2/src/op_c.c
--- gfx2orig/src/op_c.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/op_c.c	2022-03-20 20:19:34.112495316 -0500
@@ -1002,7 +1002,7 @@
 }
 
 /////////////////////////////////////////////////////////////////////////////
-///////////////////////////////////////// Méthodes de gestion des dégradés //
+///////////////////////////////////////// MÃ©thodes de gestion des dÃ©gradÃ©s //
 /////////////////////////////////////////////////////////////////////////////
 
 void GS_Init(T_Gradient_set * ds,T_Cluster_set * cs)
@@ -1011,7 +1011,7 @@
     ds->gradients[0].min=cs->clusters->h;
     ds->gradients[0].max=cs->clusters->h;
     ds->gradients[0].hue=cs->clusters->h;
-    // Et hop : le 1er ensemble de dgrads est initialis
+    // Et hop : le 1er ensemble de dÂgradÂs est initialisÂ
     ds->nb=1;
 }
 
@@ -1022,7 +1022,7 @@
     n=(T_Gradient_set *)malloc(sizeof(T_Gradient_set));
     if (n!=NULL)
     {
-        // On recopie les paramètres demandés
+        // On recopie les paramÃ¨tres demandÃ©s
         n->nb_max=cs->nb_max;
 
         // On tente d'allouer la table
@@ -1032,7 +1032,7 @@
             GS_Init(n,cs);
         else
         {
-            // Table impossible à allouer
+            // Table impossible Ã  allouer
             free(n);
             n=NULL;
         }
@@ -1050,15 +1050,15 @@
 void GS_Generate(T_Gradient_set * ds,T_Cluster_set * cs)
 {
     int id; // Les indexs de parcours des ensembles
-    int best_gradient; // Meilleur dgrad
-    int best_diff; // Meilleure diffrence de chrominance
+    int best_gradient; // Meilleur dÂgradÂ
+    int best_diff; // Meilleure diffÂrence de chrominance
     int diff;  // difference de chrominance courante
     T_Cluster * current = cs->clusters;
 
-    // Pour chacun des clusters  traiter
+    // Pour chacun des clusters Â traiter
     do
     {
-        // On recherche le dgrad le plus proche de la chrominance du cluster
+        // On recherche le dÂgradÂ le plus proche de la chrominance du cluster
         best_gradient=-1;
         best_diff=99999999;
         for (id=0;id<ds->nb;id++)
@@ -1071,10 +1071,10 @@
             }
         }
 
-        // Si on a trouv un dgrad dans lequel inclure le cluster
+        // Si on a trouvÂ un dÂgradÂ dans lequel inclure le cluster
         if (best_gradient!=-1)
         {
-            // On met  jour le dgrad
+            // On met Â jour le dÂgradÂ
             if (current->h < ds->gradients[best_gradient].min)
                 ds->gradients[best_gradient].min=current->h;
             if (current->h > ds->gradients[best_gradient].max)
@@ -1087,7 +1087,7 @@
         }
         else
         {
-            // On cre un nouveau dgrad
+            // On crÂe un nouveau dÂgradÂ
             best_gradient=ds->nb;
             ds->gradients[best_gradient].nb_colors=1;
             ds->gradients[best_gradient].min=current->h;
@@ -1206,9 +1206,9 @@
   // On initialise les variables de parcours:
   current =source;      // Le pixel dont on s'occupe
   next =current+width; // Le pixel en dessous
-  c_plus1 =current+1;   // Le pixel à droite
-  u_minus1=next-1;   // Le pixel en bas à gauche
-  u_plus1 =next+1;   // Le pixel en bas à droite
+  c_plus1 =current+1;   // Le pixel Ã  droite
+  u_minus1=next-1;   // Le pixel en bas Ã  gauche
+  u_plus1 =next+1;   // Le pixel en bas Ã  droite
   d       =dest;
 
   // On parcours chaque pixel:
@@ -1224,7 +1224,7 @@
       // Cherche la couleur correspondant dans la palette et la range dans l'image de destination
       *d=CT_get(tc,red,green,blue);
 
-      // Puis on calcule pour chaque composante l'erreur dûe à l'approximation
+      // Puis on calcule pour chaque composante l'erreur dÃ»e Ã  l'approximation
       red-=palette[*d].R;
       green -=palette[*d].G;
       blue -=palette[*d].B;
@@ -1241,7 +1241,7 @@
           c_plus1->G=Modified_value(c_plus1->G,e_green );
           c_plus1->B=Modified_value(c_plus1->B,e_blue );
         }
-      // En bas à gauche:
+      // En bas Ã  gauche:
       if (y_pos+1<height)
       {
         e_red=(red*3)/16.0;
@@ -1260,7 +1260,7 @@
         next->R=Modified_value(next->R,e_red);
         next->G=Modified_value(next->G,e_green );
         next->B=Modified_value(next->B,e_blue );
-      // En bas à droite:
+      // En bas Ã  droite:
         if (x_pos+1<width)
         {
         e_red=(red/16.0);
@@ -1343,10 +1343,10 @@
 int Convert_24b_bitmap_to_256(T_Bitmap256 dest,T_Bitmap24B source,int width,int height,T_Components * palette)
 {
   T_Conversion_table * table; // table de conversion
-  int                ip;    // index de précision pour la conversion
+  int                ip;    // index de prÃ©cision pour la conversion
 
-  // On essaye d'obtenir une table de conversion qui loge en mémoire, avec la
-  // meilleure précision possible
+  // On essaye d'obtenir une table de conversion qui loge en mÃ©moire, avec la
+  // meilleure prÃ©cision possible
   for (ip=0;ip<(10*3);ip+=3)
   {
     table=Optimize_palette(source,width*height,palette,precision_24b[ip+0],
diff -ruN gfx2orig/src/op_c.h grafx2/src/op_c.h
--- gfx2orig/src/op_c.h	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/op_c.h	2022-03-20 20:19:34.108495316 -0500
@@ -31,64 +31,64 @@
 
 #include "struct.h"
 
-//////////////////////////////////////////////// Définition des types de base
+//////////////////////////////////////////////// DÃ©finition des types de base
 
 typedef T_Components * T_Bitmap24B;
 typedef byte * T_Bitmap256;
 
 
 
-//////////////////////////////////////// Définition d'une table de conversion
+//////////////////////////////////////// DÃ©finition d'une table de conversion
 
 typedef struct
 {
-  int nbb_r; // Nb de bits de précision sur les rouges
-  int nbb_g; // Nb de bits de précision sur les verts
-  int nbb_b; // Nb de bits de précision sur les bleu
+  int nbb_r; // Nb de bits de prÃ©cision sur les rouges
+  int nbb_g; // Nb de bits de prÃ©cision sur les verts
+  int nbb_b; // Nb de bits de prÃ©cision sur les bleu
 
   int rng_r; // Nb de valeurs sur les rouges (= 1<<nbb_r)
   int rng_g; // Nb de valeurs sur les verts  (= 1<<nbb_g)
   int rng_b; // Nb de valeurs sur les bleus  (= 1<<nbb_b)
 
-  int dec_r; // Coefficient multiplicateur d'accès dans la table (= nbb_g+nbb_b)
-  int dec_g; // Coefficient multiplicateur d'accès dans la table (= nbb_b)
-  int dec_b; // Coefficient multiplicateur d'accès dans la table (= 0)
-
-  int red_r; // Coefficient réducteur de traduction d'une couleur rouge (= 8-nbb_r)
-  int red_g; // Coefficient réducteur de traduction d'une couleur verte (= 8-nbb_g)
-  int red_b; // Coefficient réducteur de traduction d'une couleur bleue (= 8-nbb_b)
+  int dec_r; // Coefficient multiplicateur d'accÃ¨s dans la table (= nbb_g+nbb_b)
+  int dec_g; // Coefficient multiplicateur d'accÃ¨s dans la table (= nbb_b)
+  int dec_b; // Coefficient multiplicateur d'accÃ¨s dans la table (= 0)
+
+  int red_r; // Coefficient rÃ©ducteur de traduction d'une couleur rouge (= 8-nbb_r)
+  int red_g; // Coefficient rÃ©ducteur de traduction d'une couleur verte (= 8-nbb_g)
+  int red_b; // Coefficient rÃ©ducteur de traduction d'une couleur bleue (= 8-nbb_b)
 
   byte * table;
 } T_Conversion_table;
 
 
 
-///////////////////////////////////////// Définition d'une table d'occurences
+///////////////////////////////////////// DÃ©finition d'une table d'occurences
 
 typedef struct
 {
-  int nbb_r; // Nb de bits de précision sur les rouges
-  int nbb_g; // Nb de bits de précision sur les verts
-  int nbb_b; // Nb de bits de précision sur les bleu
+  int nbb_r; // Nb de bits de prÃ©cision sur les rouges
+  int nbb_g; // Nb de bits de prÃ©cision sur les verts
+  int nbb_b; // Nb de bits de prÃ©cision sur les bleu
 
   int rng_r; // Nb de valeurs sur les rouges (= 1<<nbb_r)
   int rng_g; // Nb de valeurs sur les verts  (= 1<<nbb_g)
   int rng_b; // Nb de valeurs sur les bleus  (= 1<<nbb_b)
 
-  int dec_r; // Coefficient multiplicateur d'accès dans la table (= nbb_g+nbb_b)
-  int dec_g; // Coefficient multiplicateur d'accès dans la table (= nbb_b)
-  int dec_b; // Coefficient multiplicateur d'accès dans la table (= 0)
-
-  int red_r; // Coefficient réducteur de traduction d'une couleur rouge (= 8-nbb_r)
-  int red_g; // Coefficient réducteur de traduction d'une couleur verte (= 8-nbb_g)
-  int red_b; // Coefficient réducteur de traduction d'une couleur bleue (= 8-nbb_b)
+  int dec_r; // Coefficient multiplicateur d'accÃ¨s dans la table (= nbb_g+nbb_b)
+  int dec_g; // Coefficient multiplicateur d'accÃ¨s dans la table (= nbb_b)
+  int dec_b; // Coefficient multiplicateur d'accÃ¨s dans la table (= 0)
+
+  int red_r; // Coefficient rÃ©ducteur de traduction d'une couleur rouge (= 8-nbb_r)
+  int red_g; // Coefficient rÃ©ducteur de traduction d'une couleur verte (= 8-nbb_g)
+  int red_b; // Coefficient rÃ©ducteur de traduction d'une couleur bleue (= 8-nbb_b)
 
   int * table;
 } T_Occurrence_table;
 
 
 
-///////////////////////////////////////// Définition d'un ensemble de couleur
+///////////////////////////////////////// DÃ©finition d'un ensemble de couleur
 
 typedef struct S_Cluster
 {
@@ -105,16 +105,16 @@
   byte bmin,bmax;
 
   byte plus_large; // Composante ayant la plus grande variation (0=red,1=green,2=blue)
-  byte r,g,b;      // color synthétisant l'ensemble
+  byte r,g,b;      // color synthÃ©tisant l'ensemble
   byte h;          // Chrominance
-  byte l;          // Luminosité
+  byte l;          // LuminositÃ©
 
   struct S_Cluster* next;
 } T_Cluster;
 
 
 
-//////////////////////////////////////// Définition d'un ensemble de clusters
+//////////////////////////////////////// DÃ©finition d'un ensemble de clusters
 
 typedef struct
 {
@@ -125,31 +125,31 @@
 
 
 
-///////////////////////////////////////////////////// Définition d'un dégradé
+///////////////////////////////////////////////////// DÃ©finition d'un dÃ©gradÃ©
 
 typedef struct
 {
-  int   nb_colors; // Nombre de couleurs dans le dégradé
-  float min;        // Chrominance minimale du dégradé
-  float max;        // Chrominance maximale du dégradé
-  float hue;        // Chrominance moyenne du dégradé
+  int   nb_colors; // Nombre de couleurs dans le dÃ©gradÃ©
+  float min;        // Chrominance minimale du dÃ©gradÃ©
+  float max;        // Chrominance maximale du dÃ©gradÃ©
+  float hue;        // Chrominance moyenne du dÃ©gradÃ©
 } T_Gradient;
 
 
 
-///////////////////////////////////////// Définition d'un ensemble de dégradé
+///////////////////////////////////////// DÃ©finition d'un ensemble de dÃ©gradÃ©
 
 typedef struct
 {
-  int nb;             // Nombre de dégradés dans l'ensemble
-  int nb_max;          // Nombre maximum de dégradés
-  T_Gradient * gradients; // Les dégradés
+  int nb;             // Nombre de dÃ©gradÃ©s dans l'ensemble
+  int nb_max;          // Nombre maximum de dÃ©gradÃ©s
+  T_Gradient * gradients; // Les dÃ©gradÃ©s
 } T_Gradient_set;
 
 
 
 /////////////////////////////////////////////////////////////////////////////
-///////////////////////////// Méthodes de gestion des tables de conversion //
+///////////////////////////// MÃ©thodes de gestion des tables de conversion //
 /////////////////////////////////////////////////////////////////////////////
 
 T_Conversion_table * CT_new(int nbb_r,int nbb_g,int nbb_b);
@@ -162,7 +162,7 @@
 
 
 /////////////////////////////////////////////////////////////////////////////
-/////////////////////////////// Méthodes de gestion des tables d'occurence //
+/////////////////////////////// MÃ©thodes de gestion des tables d'occurence //
 /////////////////////////////////////////////////////////////////////////////
 
 void OT_init(T_Occurrence_table * t);
@@ -175,7 +175,7 @@
 
 
 /////////////////////////////////////////////////////////////////////////////
-///////////////////////////////////////// Méthodes de gestion des clusters //
+///////////////////////////////////////// MÃ©thodes de gestion des clusters //
 /////////////////////////////////////////////////////////////////////////////
 
 void Cluster_pack(T_Cluster * c,T_Occurrence_table * to);
@@ -185,7 +185,7 @@
 
 
 /////////////////////////////////////////////////////////////////////////////
-//////////////////////////// Méthodes de gestion des ensembles de clusters //
+//////////////////////////// MÃ©thodes de gestion des ensembles de clusters //
 /////////////////////////////////////////////////////////////////////////////
 
 void CS_Init(T_Cluster_set * cs,T_Occurrence_table * to);
@@ -198,7 +198,7 @@
 void CS_Generate_color_table_and_palette(T_Cluster_set * cs,T_Conversion_table * tc,T_Components * palette);
 
 /////////////////////////////////////////////////////////////////////////////
-//////////////////////////// Méthodes de gestion des ensembles de dégradés //
+//////////////////////////// MÃ©thodes de gestion des ensembles de dÃ©gradÃ©s //
 /////////////////////////////////////////////////////////////////////////////
 
 void GS_Init(T_Gradient_set * ds,T_Cluster_set * cs);
@@ -208,7 +208,7 @@
 
 
 
-// Convertie avec le plus de précision possible une image 24b en 256c
+// Convertie avec le plus de prÃ©cision possible une image 24b en 256c
 // Renvoie s'il y a eu une erreur ou pas..
 int Convert_24b_bitmap_to_256(T_Bitmap256 dest,T_Bitmap24B source,int width,int height,T_Components * palette);
 
diff -ruN gfx2orig/src/operatio.c grafx2/src/operatio.c
--- gfx2orig/src/operatio.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/operatio.c	2022-03-20 20:19:34.112495316 -0500
@@ -50,7 +50,7 @@
 {
   Brush_rotation_center_is_defined=0;
 
-  // On mémorise l'opération précédente si on démarre une interruption
+  // On mÃ©morise l'opÃ©ration prÃ©cÃ©dente si on dÃ©marre une interruption
   switch(new_operation)
   {
     case OPERATION_MAGNIFY         :
@@ -60,16 +60,16 @@
     case OPERATION_STRETCH_BRUSH :
     case OPERATION_ROTATE_BRUSH:
       Operation_before_interrupt=Current_operation;
-      // On passe à l'operation demandée
+      // On passe Ã  l'operation demandÃ©e
       Current_operation=new_operation;
       break;
     default :
-      // On passe à l'operation demandée
+      // On passe Ã  l'operation demandÃ©e
       Current_operation=new_operation;
       Operation_before_interrupt=Current_operation;
   }
 
-  // On spécifie si l'opération autorise le changement de couleur au clavier
+  // On spÃ©cifie si l'opÃ©ration autorise le changement de couleur au clavier
   switch(new_operation)
   {
     case OPERATION_CONTINUOUS_DRAW:
@@ -140,7 +140,7 @@
         str[0]='-';
       }
       else
-        strcpy(str,"±   0");
+        strcpy(str,"Â±   0");
       Print_in_menu(str,2);
 
       if (Paintbrush_Y>start_y)
@@ -154,7 +154,7 @@
         str[0]='-';
       }
       else
-        strcpy(str,"±   0");
+        strcpy(str,"Â±   0");
       Print_in_menu(str,12);
     }
   }
@@ -165,16 +165,16 @@
 //////////////////////////////////////////////////// OPERATION_CONTINUOUS_DRAW
 
 void Freehand_mode1_1_0(void)
-//  Opération   : OPERATION_CONTINUOUS_DRAW
+//  OpÃ©ration   : OPERATION_CONTINUOUS_DRAW
 //  Click Souris: 1
 //  Taille_Pile : 0
 //
-//  Souris effacée: Oui
+//  Souris effacÃ©e: Oui
 {
   Init_start_operation();
   Backup();
   Shade_table=Shade_table_left;
-  // On affiche définitivement le pinceau
+  // On affiche dÃ©finitivement le pinceau
   Display_paintbrush(Paintbrush_X,Paintbrush_Y,Fore_color,0);
   Operation_push(Paintbrush_X);
   Operation_push(Paintbrush_Y);
@@ -182,11 +182,11 @@
 
 
 void Freehand_mode1_1_2(void)
-//  Opération   : OPERATION_CONTINUOUS_DRAW
+//  OpÃ©ration   : OPERATION_CONTINUOUS_DRAW
 //  Click Souris: 1
 //  Taille_Pile : 2
 //
-//  Souris effacée: Non
+//  Souris effacÃ©e: Non
 {
   short start_x;
   short start_y;
@@ -208,11 +208,11 @@
 
 
 void Freehand_mode12_0_2(void)
-//  Opération   : OPERATION_DESSIN_[DIS]CONTINU
+//  OpÃ©ration   : OPERATION_DESSIN_[DIS]CONTINU
 //  Click Souris: 0
 //  Taille_Pile : 2
 //
-//  Souris effacée: Non
+//  Souris effacÃ©e: Non
 {
   Operation_stack_size=0;
   End_of_modification();
@@ -220,16 +220,16 @@
 
 
 void Freehand_mode1_2_0(void)
-//  Opération   : OPERATION_CONTINUOUS_DRAW
+//  OpÃ©ration   : OPERATION_CONTINUOUS_DRAW
 //  Click Souris: 2
 //  Taille_Pile : 0
 //
-//  Souris effacée: Oui
+//  Souris effacÃ©e: Oui
 {
   Init_start_operation();
   Backup();
   Shade_table=Shade_table_right;
-  // On affiche définitivement le pinceau
+  // On affiche dÃ©finitivement le pinceau
   Display_paintbrush(Paintbrush_X,Paintbrush_Y,Back_color,0);
   Operation_push(Paintbrush_X);
   Operation_push(Paintbrush_Y);
@@ -237,11 +237,11 @@
 
 
 void Freehand_mode1_2_2(void)
-//  Opération   : OPERATION_CONTINUOUS_DRAW
+//  OpÃ©ration   : OPERATION_CONTINUOUS_DRAW
 //  Click Souris: 2
 //  Taille_Pile : 2
 //
-//  Souris effacée: Non
+//  Souris effacÃ©e: Non
 {
   short start_x;
   short start_y;
@@ -265,16 +265,16 @@
 ///////////////////////////////////////////////// OPERATION_DISCONTINUOUS_DRAW
 
 void Freehand_mode2_1_0(void)
-//  Opération   : OPERATION_DISCONTINUOUS_DRAW
+//  OpÃ©ration   : OPERATION_DISCONTINUOUS_DRAW
 //  Click Souris: 1
 //  Taille_Pile : 0
 //
-//  Souris effacée: Oui
+//  Souris effacÃ©e: Oui
 {
   Init_start_operation();
   Backup();
   Shade_table=Shade_table_left;
-  // On affiche définitivement le pinceau
+  // On affiche dÃ©finitivement le pinceau
   Display_paintbrush(Paintbrush_X,Paintbrush_Y,Fore_color,0);
   Operation_push(Paintbrush_X);
   Operation_push(Paintbrush_Y);
@@ -284,11 +284,11 @@
 
 
 void Freehand_mode2_1_2(void)
-//  Opération   : OPERATION_DISCONTINUOUS_DRAW
+//  OpÃ©ration   : OPERATION_DISCONTINUOUS_DRAW
 //  Click Souris: 1
 //  Taille_Pile : 2
 //
-//  Souris effacée: Non
+//  Souris effacÃ©e: Non
 {
   short start_x;
   short start_y;
@@ -303,7 +303,7 @@
     {
       Airbrush_next_time+=Airbrush_delay*10;
       Hide_cursor();
-      // On affiche définitivement le pinceau
+      // On affiche dÃ©finitivement le pinceau
       Display_paintbrush(Paintbrush_X,Paintbrush_Y,Fore_color,0);
       Display_cursor();
     }
@@ -316,11 +316,11 @@
 // ----------
 
 void Freehand_mode2_2_0(void)
-//  Opération   : OPERATION_DISCONTINUOUS_DRAW
+//  OpÃ©ration   : OPERATION_DISCONTINUOUS_DRAW
 //  Click Souris: 2
 //  Taille_Pile : 0
 //
-//  Souris effacée: Oui
+//  Souris effacÃ©e: Oui
 {
   Init_start_operation();
   Backup();
@@ -329,17 +329,17 @@
   Operation_push(Paintbrush_Y);
   Print_coordinates();
   Airbrush_next_time = SDL_GetTicks() + Airbrush_delay*10;
-  // On affiche définitivement le pinceau
+  // On affiche dÃ©finitivement le pinceau
   Display_paintbrush(Paintbrush_X,Paintbrush_Y,Back_color,0);
 }
 
 
 void Freehand_mode2_2_2(void)
-//  Opération   : OPERATION_DISCONTINUOUS_DRAW
+//  OpÃ©ration   : OPERATION_DISCONTINUOUS_DRAW
 //  Click Souris: 2
 //  Taille_Pile : 2
 //
-//  Souris effacée: Non
+//  Souris effacÃ©e: Non
 {
   short start_x;
   short start_y;
@@ -354,7 +354,7 @@
     {
       Airbrush_next_time+=Airbrush_delay*10;
       Hide_cursor();
-      // On affiche définitivement le pinceau
+      // On affiche dÃ©finitivement le pinceau
       Display_paintbrush(Paintbrush_X,Paintbrush_Y,Back_color,0);
       Display_cursor();
     }
@@ -368,43 +368,43 @@
 ////////////////////////////////////////////////////// OPERATION_POINT_DRAW
 
 void Freehand_mode3_1_0(void)
-//  Opération   : OPERATION_POINT_DRAW
+//  OpÃ©ration   : OPERATION_POINT_DRAW
 //  Click Souris: 1
 //  Taille_Pile : 0
 //
-//  Souris effacée: Oui
+//  Souris effacÃ©e: Oui
 {
   Init_start_operation();
   Backup();
   Shade_table=Shade_table_left;
-  // On affiche définitivement le pinceau
+  // On affiche dÃ©finitivement le pinceau
   Display_paintbrush(Paintbrush_X,Paintbrush_Y,Fore_color,0);
-  Operation_push(0);  // On change simplement l'état de la pile...
+  Operation_push(0);  // On change simplement l'Ã©tat de la pile...
 }
 
 
 void Freehand_Mode3_2_0(void)
-//  Opération   : OPERATION_POINT_DRAW
+//  OpÃ©ration   : OPERATION_POINT_DRAW
 //  Click Souris: 2
 //  Taille_Pile : 0
 //
-//  Souris effacée: Oui
+//  Souris effacÃ©e: Oui
 {
   Init_start_operation();
   Backup();
   Shade_table=Shade_table_right;
-  // On affiche définitivement le pinceau
+  // On affiche dÃ©finitivement le pinceau
   Display_paintbrush(Paintbrush_X,Paintbrush_Y,Back_color,0);
-  Operation_push(0);  // On change simplement l'état de la pile...
+  Operation_push(0);  // On change simplement l'Ã©tat de la pile...
 }
 
 
 void Freehand_mode3_0_1(void)
-//  Opération   : OPERATION_POINT_DRAW
+//  OpÃ©ration   : OPERATION_POINT_DRAW
 //  Click Souris: 0
 //  Taille_Pile : 1
 //
-//  Souris effacée: Non
+//  Souris effacÃ©e: Non
 {
   End_of_modification();
   Operation_stack_size--;
@@ -414,13 +414,13 @@
 ///////////////////////////////////////////////////////////// OPERATION_LINE
 
 void Line_12_0(void)
-// Opération   : OPERATION_LINE
+// OpÃ©ration   : OPERATION_LINE
 // Click Souris: 1 ou 2
 // Taille_Pile : 0
 //
-//  Souris effacée: Oui
+//  Souris effacÃ©e: Oui
 
-//  Début du tracé d'une ligne (premier clic)
+//  DÃ©but du tracÃ© d'une ligne (premier clic)
 {
   Init_start_operation();
   Backup();
@@ -443,7 +443,7 @@
   }
 
   if ((Config.Coords_rel) && (Menu_is_visible))
-    Print_in_menu("X:±   0   Y:±   0",0);
+    Print_in_menu("X:Â±   0   Y:Â±   0",0);
 
   Operation_push(Paintbrush_X);
   Operation_push(Paintbrush_Y);
@@ -453,14 +453,14 @@
 
 
 void Line_12_5(void)
-// Opération   : OPERATION_LINE
+// OpÃ©ration   : OPERATION_LINE
 // Click Souris: 1
 // Taille_Pile : 5
 //
-// Souris effacée: Non
+// Souris effacÃ©e: Non
 
-// Poursuite du tracé d'une ligne (déplacement de la souris en gardant le 
-// curseur appuyé)
+// Poursuite du tracÃ© d'une ligne (dÃ©placement de la souris en gardant le 
+// curseur appuyÃ©)
 {
   short start_x;
   short start_y;
@@ -478,7 +478,7 @@
   cursor_x = Paintbrush_X;
   cursor_y = Paintbrush_Y;
 
-  // On corrige les coordonnées de la ligne si la touche shift est appuyée...
+  // On corrige les coordonnÃ©es de la ligne si la touche shift est appuyÃ©e...
   if(SDL_GetModState() & KMOD_SHIFT)
   {
     Clamp_coordinates_regular_angle(start_x,start_y,&cursor_x,&cursor_y);
@@ -521,13 +521,13 @@
 
 
 void Line_0_5(void)
-// Opération   : OPERATION_LINE
+// OpÃ©ration   : OPERATION_LINE
 // Click Souris: 0
 // Taille_Pile : 5
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 
-// End du tracé d'une ligne (relachage du bouton)
+// End du tracÃ© d'une ligne (relachage du bouton)
 {
   short start_x;
   short start_y;
@@ -561,11 +561,11 @@
 
 
 void K_line_12_0(void)
-// Opération   : OPERATION_K_LIGNE
+// OpÃ©ration   : OPERATION_K_LIGNE
 // Click Souris: 1 ou 2
 // Taille_Pile : 0
 //
-//  Souris effacée: Oui
+//  Souris effacÃ©e: Oui
 {
   byte color;
 
@@ -577,11 +577,11 @@
 
   color=(Mouse_K==LEFT_SIDE)?Fore_color:Back_color;
 
-  // On place temporairement le début de la ligne qui ne s'afficherait pas sinon
+  // On place temporairement le dÃ©but de la ligne qui ne s'afficherait pas sinon
   Pixel_figure_preview(Paintbrush_X,Paintbrush_Y,color);
 
   if ((Config.Coords_rel) && (Menu_is_visible))
-    Print_in_menu("X:±   0   Y:±   0",0);
+    Print_in_menu("X:Â±   0   Y:Â±   0",0);
 
   Operation_push(Mouse_K | 0x80);
   Operation_push(color);
@@ -594,11 +594,11 @@
 
 
 void K_line_12_6(void)
-// Opération   : OPERATION_K_LIGNE
+// OpÃ©ration   : OPERATION_K_LIGNE
 // Click Souris: 1 ou 2 | 0
 // Taille_Pile : 6      | 7
 //
-// Souris effacée: Non
+// Souris effacÃ©e: Non
 {
   short start_x;
   short start_y;
@@ -634,11 +634,11 @@
 
 
 void K_line_0_6(void)
-// Opération   : OPERATION_K_LIGNE
+// OpÃ©ration   : OPERATION_K_LIGNE
 // Click Souris: 0
 // Taille_Pile : 6
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 {
   short start_x;
   short start_y;
@@ -655,7 +655,7 @@
   Operation_pop(&direction);
 
   if ((Config.Coords_rel) && (Menu_is_visible))
-    Print_in_menu("X:±   0   Y:±   0",0);
+    Print_in_menu("X:Â±   0   Y:Â±   0",0);
 
   Pixel_figure_preview_auto  (start_x,start_y);
   Hide_line_preview (start_x,start_y,end_x,end_y);
@@ -673,7 +673,7 @@
   Paintbrush_shape=PAINTBRUSH_SHAPE_POINT;
 
   Operation_push(direction);
-  Operation_push(direction); // Valeur bidon servant de nouvel état de pile
+  Operation_push(direction); // Valeur bidon servant de nouvel Ã©tat de pile
   Operation_push(color);
   Operation_push(Paintbrush_X);
   Operation_push(Paintbrush_Y);
@@ -684,11 +684,11 @@
 
 
 void K_line_12_7(void)
-// Opération   : OPERATION_K_LIGNE
+// OpÃ©ration   : OPERATION_K_LIGNE
 // Click Souris: 1 ou 2
 // Taille_Pile : 7
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 {
   short start_x;
   short start_y;
@@ -717,7 +717,7 @@
   }
   else
   {
-    // La série de ligne est terminée, il faut donc effacer la dernière
+    // La sÃ©rie de ligne est terminÃ©e, il faut donc effacer la derniÃ¨re
     // preview de ligne
     Pixel_figure_preview_auto  (start_x,start_y);
     Hide_line_preview (start_x,start_y,end_x,end_y);
@@ -739,17 +739,17 @@
 /////////////////////////////////////////////////// OPERATION_RECTANGLE_?????
 
 void Rectangle_12_0(void)
-// Opération   : OPERATION_EMPTY_RECTANGLE / OPERATION_FILLED_RECTANGLE
+// OpÃ©ration   : OPERATION_EMPTY_RECTANGLE / OPERATION_FILLED_RECTANGLE
 // Click Souris: 1 ou 2
 // Taille_Pile : 0
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 {
   Init_start_operation();
 
   if ((Config.Coords_rel) && (Menu_is_visible))
     Print_in_menu("\035:   1   \022:   1",0);
-  // On laisse une trace du curseur à l'écran
+  // On laisse une trace du curseur Ã  l'Ã©cran
   Display_cursor();
 
   if (Mouse_K==LEFT_SIDE)
@@ -771,11 +771,11 @@
 
 
 void Rectangle_12_5(void)
-// Opération   : OPERATION_EMPTY_RECTANGLE / OPERATION_FILLED_RECTANGLE
+// OpÃ©ration   : OPERATION_EMPTY_RECTANGLE / OPERATION_FILLED_RECTANGLE
 // Click Souris: 1 ou 2
 // Taille_Pile : 5
 //
-// Souris effacée: Non
+// Souris effacÃ©e: Non
 {
   short start_x;
   short start_y;
@@ -811,17 +811,17 @@
 
 
 void Empty_rectangle_0_5(void)
-// Opération   : OPERATION_EMPTY_RECTANGLE
+// OpÃ©ration   : OPERATION_EMPTY_RECTANGLE
 // Click Souris: 0
 // Taille_Pile : 5
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 {
   short old_paintbrush_x;
   short old_paintbrush_y;
   short color;
 
-  // On mémorise la position courante du pinceau:
+  // On mÃ©morise la position courante du pinceau:
 
   old_paintbrush_x=Paintbrush_X;
   old_paintbrush_y=Paintbrush_Y;
@@ -833,7 +833,7 @@
   Operation_pop(&Paintbrush_Y);
   Operation_pop(&Paintbrush_X);
 
-  // On va devoir effacer l'ancien curseur qu'on a laissé trainer:
+  // On va devoir effacer l'ancien curseur qu'on a laissÃ© trainer:
   Hide_cursor();
 
   // On lit la couleur du rectangle:
@@ -845,7 +845,7 @@
   // Et on trace le rectangle:
   Draw_empty_rectangle(Paintbrush_X,Paintbrush_Y,old_paintbrush_x,old_paintbrush_y,color);
 
-  // Enfin, on rétablit la position du pinceau:
+  // Enfin, on rÃ©tablit la position du pinceau:
   Paintbrush_X=old_paintbrush_x;
   Paintbrush_Y=old_paintbrush_y;
 
@@ -858,17 +858,17 @@
 
 
 void Filled_rectangle_0_5(void)
-// Opération   : OPERATION_FILLED_RECTANGLE
+// OpÃ©ration   : OPERATION_FILLED_RECTANGLE
 // Click Souris: 0
 // Taille_Pile : 5
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 {
   short old_paintbrush_x;
   short old_paintbrush_y;
   short color;
 
-  // On mémorise la position courante du pinceau:
+  // On mÃ©morise la position courante du pinceau:
 
   old_paintbrush_x=Paintbrush_X;
   old_paintbrush_y=Paintbrush_Y;
@@ -880,7 +880,7 @@
   Operation_pop(&Paintbrush_Y);
   Operation_pop(&Paintbrush_X);
 
-  // On va devoir effacer l'ancien curseur qu'on a laissé trainer:
+  // On va devoir effacer l'ancien curseur qu'on a laissÃ© trainer:
   Hide_cursor();
 
   // On lit la couleur du rectangle:
@@ -892,7 +892,7 @@
   // Et on trace le rectangle:
   Draw_filled_rectangle(Paintbrush_X,Paintbrush_Y,old_paintbrush_x,old_paintbrush_y,color);
 
-  // Enfin, on rétablit la position du pinceau:
+  // Enfin, on rÃ©tablit la position du pinceau:
   Paintbrush_X=old_paintbrush_x;
   Paintbrush_Y=old_paintbrush_y;
 
@@ -910,11 +910,11 @@
 
 void Circle_12_0(void)
 //
-// Opération   : OPERATION_EMPTY_CIRCLE / OPERATION_FILLED_CIRCLE
+// OpÃ©ration   : OPERATION_EMPTY_CIRCLE / OPERATION_FILLED_CIRCLE
 // Click Souris: 1 ou 2
 // Taille_Pile : 0
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 {
   Init_start_operation();
   Backup();
@@ -945,11 +945,11 @@
 
 void Circle_12_5(void)
 //
-// Opération   : OPERATION_EMPTY_CIRCLE / OPERATION_FILLED_CIRCLE
+// OpÃ©ration   : OPERATION_EMPTY_CIRCLE / OPERATION_FILLED_CIRCLE
 // Click Souris: 1 ou 2
 // Taille_Pile : 5 (color, X_Centre, Y_Centre, X_Tangente, Y_Tangente)
 //
-// Souris effacée: Non
+// Souris effacÃ©e: Non
 //
 {
   short tangent_x;
@@ -1000,11 +1000,11 @@
 
 void Empty_circle_0_5(void)
 //
-// Opération   : OPERATION_EMPTY_CIRCLE
+// OpÃ©ration   : OPERATION_EMPTY_CIRCLE
 // Click Souris: 0
 // Taille_Pile : 5 (color, X_Centre, Y_Centre, X_Tangente, Y_Tangente)
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 //
 {
   short tangent_x;
@@ -1041,11 +1041,11 @@
 
 void Filled_circle_0_5(void)
 //
-// Opération   : OPERATION_FILLED_CIRCLE
+// OpÃ©ration   : OPERATION_FILLED_CIRCLE
 // Click Souris: 0
 // Taille_Pile : 5 (color, X_Centre, Y_Centre, X_Tangente, Y_Tangente)
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 //
 {
   short tangent_x;
@@ -1084,11 +1084,11 @@
 
 void Ellipse_12_0(void)
 //
-// Opération   : OPERATION_EMPTY_ELLIPSE / OPERATION_FILLED_ELLIPSE
+// OpÃ©ration   : OPERATION_EMPTY_ELLIPSE / OPERATION_FILLED_ELLIPSE
 // Click Souris: 1 ou 2
 // Taille_Pile : 0
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 {
   Init_start_operation();
   Backup();
@@ -1108,7 +1108,7 @@
   }
 
   if ((Config.Coords_rel) && (Menu_is_visible))
-    Print_in_menu("X:±   0   Y:±   0",0);
+    Print_in_menu("X:Â±   0   Y:Â±   0",0);
 
   Operation_push(Paintbrush_X);
   Operation_push(Paintbrush_Y);
@@ -1119,11 +1119,11 @@
 
 void Ellipse_12_5(void)
 //
-// Opération   : OPERATION_EMPTY_ELLIPSE / OPERATION_FILLED_ELLIPSE
+// OpÃ©ration   : OPERATION_EMPTY_ELLIPSE / OPERATION_FILLED_ELLIPSE
 // Click Souris: 1 ou 2
 // Taille_Pile : 5 (color, X_Centre, Y_Centre, X_Tangente, Y_Tangente)
 //
-// Souris effacée: Non
+// Souris effacÃ©e: Non
 //
 {
   short tangent_x;
@@ -1170,11 +1170,11 @@
 
 void Empty_ellipse_0_5(void)
 //
-// Opération   : OPERATION_EMPTY_ELLIPSE
+// OpÃ©ration   : OPERATION_EMPTY_ELLIPSE
 // Click Souris: 0
 // Taille_Pile : 5 (color, X_Centre, Y_Centre, X_Tangente, Y_Tangente)
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 //
 {
   short tangent_x;
@@ -1213,11 +1213,11 @@
 
 void Filled_ellipse_0_5(void)
 //
-// Opération   : OPERATION_FILLED_ELLIPSE
+// OpÃ©ration   : OPERATION_FILLED_ELLIPSE
 // Click Souris: 0
 // Taille_Pile : 5 (color, X_Centre, Y_Centre, X_Tangente, Y_Tangente)
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 //
 {
   short tangent_x;
@@ -1258,15 +1258,15 @@
 
 void Fill_1_0(void)
 //
-// Opération   : OPERATION_FILL
+// OpÃ©ration   : OPERATION_FILL
 // Click Souris: 1
 // Taille_Pile : 0
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 //
 {
   Hide_cursor();
-  // Pas besoin d'initialiser le début d'opération car le Smear n'affecte pas
+  // Pas besoin d'initialiser le dÃ©but d'opÃ©ration car le Smear n'affecte pas
   // le Fill, et on se fout de savoir si on est dans la partie gauche ou
   // droite de la loupe.
   // On ne s'occupe pas de faire un Backup: c'est "Fill_general" qui s'en charge.
@@ -1280,15 +1280,15 @@
 
 void Fill_2_0(void)
 //
-// Opération   : OPERATION_FILL
+// OpÃ©ration   : OPERATION_FILL
 // Click Souris: 2
 // Taille_Pile : 0
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 //
 {
   Hide_cursor();
-  // Pas besoin d'initialiser le début d'opération car le Smear n'affecte pas
+  // Pas besoin d'initialiser le dÃ©but d'opÃ©ration car le Smear n'affecte pas
   // le Fill, et on se fout de savoir si on est dans la partie gauche ou
   // droite de la loupe.
   // On ne s'occupe pas de faire un Backup: c'est "Fill_general" qui s'en charge.
@@ -1305,15 +1305,15 @@
 
 void Replace_1_0(void)
 //
-// Opération   : OPERATION_REPLACE
+// OpÃ©ration   : OPERATION_REPLACE
 // Click Souris: 1
 // Taille_Pile : 0
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 //
 {
   Hide_cursor();
-  // Pas besoin d'initialiser le début d'opération car le Smear n'affecte pas
+  // Pas besoin d'initialiser le dÃ©but d'opÃ©ration car le Smear n'affecte pas
   // le Replace, et on se fout de savoir si on est dans la partie gauche ou
   // droite de la loupe.
   Backup();
@@ -1327,15 +1327,15 @@
 
 void Replace_2_0(void)
 //
-// Opération   : OPERATION_REPLACE
+// OpÃ©ration   : OPERATION_REPLACE
 // Click Souris: 2
 // Taille_Pile : 0
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 //
 {
   Hide_cursor();
-  // Pas besoin d'initialiser le début d'opération car le Smear n'affecte pas
+  // Pas besoin d'initialiser le dÃ©but d'opÃ©ration car le Smear n'affecte pas
   // le Replace, et on se fout de savoir si on est dans la partie gauche ou
   // droite de la loupe.
   Backup();
@@ -1398,11 +1398,11 @@
 
 void Curve_34_points_1_0(void)
 //
-//  Opération   : OPERATION_COURBE_?_POINTS
+//  OpÃ©ration   : OPERATION_COURBE_?_POINTS
 //  Click Souris: 1
 //  Taille_Pile : 0
 //
-//  Souris effacée: Oui
+//  Souris effacÃ©e: Oui
 //
 {
   Init_start_operation();
@@ -1415,7 +1415,7 @@
   Update_part_of_screen(Paintbrush_X,Paintbrush_Y,1,1);
 
   if ((Config.Coords_rel) && (Menu_is_visible))
-    Print_in_menu("X:±   0   Y:±   0",0);
+    Print_in_menu("X:Â±   0   Y:Â±   0",0);
 
   Operation_push(Fore_color);
   Operation_push(Paintbrush_X);
@@ -1426,11 +1426,11 @@
 
 void Curve_34_points_2_0(void)
 //
-//  Opération   : OPERATION_COURBE_?_POINTS
+//  OpÃ©ration   : OPERATION_COURBE_?_POINTS
 //  Click Souris: 2
 //  Taille_Pile : 0
 //
-//  Souris effacée: Oui
+//  Souris effacÃ©e: Oui
 //
 {
   Init_start_operation();
@@ -1443,7 +1443,7 @@
   Update_part_of_screen(Paintbrush_X,Paintbrush_Y,1,1);
 
   if ((Config.Coords_rel) && (Menu_is_visible))
-    Print_in_menu("X:±   0   Y:±   0",0);
+    Print_in_menu("X:Â±   0   Y:Â±   0",0);
 
   Operation_push(Back_color);
   Operation_push(Paintbrush_X);
@@ -1455,11 +1455,11 @@
 
 void Curve_34_points_1_5(void)
 //
-//  Opération   : OPERATION_COURBE_?_POINTS
+//  OpÃ©ration   : OPERATION_COURBE_?_POINTS
 //  Click Souris: 1
 //  Taille_Pile : 5
 //
-//  Souris effacée: Non
+//  Souris effacÃ©e: Non
 //
 {
   short x1,x2,y1,y2;
@@ -1489,11 +1489,11 @@
 
 void Curve_34_points_2_5(void)
 //
-//  Opération   : OPERATION_COURBE_?_POINTS
+//  OpÃ©ration   : OPERATION_COURBE_?_POINTS
 //  Click Souris: 2
 //  Taille_Pile : 5
 //
-//  Souris effacée: Non
+//  Souris effacÃ©e: Non
 //
 {
   short x1,x2,y1,y2;
@@ -1526,11 +1526,11 @@
 
 void Curve_4_points_0_5(void)
 //
-//  Opération   : OPERATION_4_POINTS_CURVE
+//  OpÃ©ration   : OPERATION_4_POINTS_CURVE
 //  Click Souris: 0
 //  Taille_Pile : 5
 //
-//  Souris effacée: Oui
+//  Souris effacÃ©e: Oui
 //
 {
   short x1,y1,x2,y2,x3,y3,x4,y4;
@@ -1571,7 +1571,7 @@
   Hide_line_preview(x1,y1,x4,y4);
   Draw_curve_preview(x1,y1,x2,y2,x3,y3,x4,y4,color);
 
-  // On trace les petites croix montrant les 2 points intermédiares
+  // On trace les petites croix montrant les 2 points intermÃ©diares
   Draw_curve_cross(x2,y2);
   Draw_curve_cross(x3,y3);
 
@@ -1598,11 +1598,11 @@
 
 void Curve_4_points_1_9(void)
 //
-//  Opération   : OPERATION_4_POINTS_CURVE
+//  OpÃ©ration   : OPERATION_4_POINTS_CURVE
 //  Click Souris: 1
 //  Taille_Pile : 9
 //
-//  Souris effacée: Non
+//  Souris effacÃ©e: Non
 //
 {
   short x1,y1,x2,y2,x3,y3,x4,y4;
@@ -1665,11 +1665,11 @@
 
 void Curve_4_points_2_9(void)
 //
-//  Opération   : OPERATION_4_POINTS_CURVE
+//  OpÃ©ration   : OPERATION_4_POINTS_CURVE
 //  Click Souris: 2
 //  Taille_Pile : 9
 //
-//  Souris effacée: Oui
+//  Souris effacÃ©e: Oui
 //
 {
   short x1,y1,x2,y2,x3,y3,x4,y4;
@@ -1711,27 +1711,27 @@
   float cx,cy; // Centre de (x1,y1) et (x4,y4)
   float bx,by; // Intersect. des dtes ((x1,y1),(x2,y2)) et ((x3,y3),(x4,y4))
 
-  cx=(float)(x1+x4)/2.0;           // P1*--_               Légende:
-  cy=(float)(y1+y4)/2.0;           //   ·   \·· P2         -_\|/ : courbe
-                                   //   ·    \ ·*·         * : point important
-  bx=cx+((8.0/3.0)*(Paintbrush_X-cx));//   ·     |   ··       · : pointillÚ
-  by=cy+((8.0/3.0)*(Paintbrush_Y-cy));//   ·     |P    ··  B
-                                   // C *·····*·········*  P=Pos. du pinceau
-  *x2=Round((bx+x1)/2.0);          //   ·     |     ··     C=milieu de [P1,P4]
-  *y2=Round((by+y1)/2.0);          //   ·     |   ··       B=point tel que
-                                   //   ·    / ·*·         C->B=(8/3) * C->P
-  *x3=Round((bx+x4)/2.0);          //   ·  _/·· P3         P2=milieu de [P1,B]
+  cx=(float)(x1+x4)/2.0;           // P1*--_               LÃ©gende:
+  cy=(float)(y1+y4)/2.0;           //   Â·   \Â·Â· P2         -_\|/ : courbe
+                                   //   Â·    \ Â·*Â·         * : point important
+  bx=cx+((8.0/3.0)*(Paintbrush_X-cx));//   Â·     |   Â·Â·       Â· : pointillÃ
+  by=cy+((8.0/3.0)*(Paintbrush_Y-cy));//   Â·     |P    Â·Â·  B
+                                   // C *Â·Â·Â·Â·Â·*Â·Â·Â·Â·Â·Â·Â·Â·Â·*  P=Pos. du pinceau
+  *x2=Round((bx+x1)/2.0);          //   Â·     |     Â·Â·     C=milieu de [P1,P4]
+  *y2=Round((by+y1)/2.0);          //   Â·     |   Â·Â·       B=point tel que
+                                   //   Â·    / Â·*Â·         C->B=(8/3) * C->P
+  *x3=Round((bx+x4)/2.0);          //   Â·  _/Â·Â· P3         P2=milieu de [P1,B]
   *y3=Round((by+y4)/2.0);          // P4*--                P3=milieu de [P4,B]
 }
 
 
 void Curve_3_points_0_5(void)
 //
-//  Opération   : OPERATION_3_POINTS_CURVE
+//  OpÃ©ration   : OPERATION_3_POINTS_CURVE
 //  Click Souris: 0
 //  Taille_Pile : 5
 //
-//  Souris effacée: Oui
+//  Souris effacÃ©e: Oui
 //
 {
   short x1,y1,x2,y2,x3,y3,x4,y4;
@@ -1770,11 +1770,11 @@
 
 void Curve_3_points_0_11(void)
 //
-//  Opération   : OPERATION_3_POINTS_CURVE
+//  OpÃ©ration   : OPERATION_3_POINTS_CURVE
 //  Click Souris: 0
 //  Taille_Pile : 11
 //
-//  Souris effacée: Non
+//  Souris effacÃ©e: Non
 //
 {
   short x1,y1,x2,y2,x3,y3,x4,y4;
@@ -1821,11 +1821,11 @@
 
 void Curve_3_points_12_11(void)
 //
-//  Opération   : OPERATION_3_POINTS_CURVE
+//  OpÃ©ration   : OPERATION_3_POINTS_CURVE
 //  Click Souris: 1 ou 2
 //  Taille_Pile : 11
 //
-//  Souris effacée: Oui
+//  Souris effacÃ©e: Oui
 //
 {
   short x1,y1,x2,y2,x3,y3,x4,y4;
@@ -1862,11 +1862,11 @@
 
 void Airbrush_1_0(void)
 //
-//  Opération   : OPERATION_AIRBRUSH
+//  OpÃ©ration   : OPERATION_AIRBRUSH
 //  Click Souris: 1
 //  Taille_Pile : 0
 //
-//  Souris effacée: Non
+//  Souris effacÃ©e: Non
 //
 {
   Init_start_operation();
@@ -1882,11 +1882,11 @@
 
 void Airbrush_2_0(void)
 //
-//  Opération   : OPERATION_AIRBRUSH
+//  OpÃ©ration   : OPERATION_AIRBRUSH
 //  Click Souris: 2
 //  Taille_Pile : 0
 //
-//  Souris effacée: Non
+//  Souris effacÃ©e: Non
 //
 {
   Init_start_operation();
@@ -1901,11 +1901,11 @@
 
 void Airbrush_12_2(void)
 //
-//  Opération   : OPERATION_AIRBRUSH
+//  OpÃ©ration   : OPERATION_AIRBRUSH
 //  Click Souris: 1 ou 2
 //  Taille_Pile : 2
 //
-//  Souris effacée: Non
+//  Souris effacÃ©e: Non
 //
 {
   short old_x,old_y;
@@ -1932,11 +1932,11 @@
 
 void Airbrush_0_2(void)
 //
-//  Opération   : OPERATION_AIRBRUSH
+//  OpÃ©ration   : OPERATION_AIRBRUSH
 //  Click Souris: 0
 //  Taille_Pile : 2
 //
-//  Souris effacée: Non
+//  Souris effacÃ©e: Non
 //
 {
   Operation_stack_size-=2;
@@ -1948,11 +1948,11 @@
 
 
 void Polygon_12_0(void)
-// Opération   : OPERATION_POLYGON
+// OpÃ©ration   : OPERATION_POLYGON
 // Click Souris: 1 ou 2
 // Taille_Pile : 0
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 {
   byte color;
 
@@ -1964,12 +1964,12 @@
 
   color=(Mouse_K==LEFT_SIDE)?Fore_color:Back_color;
 
-  // On place temporairement le début de la ligne qui ne s'afficherait pas sinon
+  // On place temporairement le dÃ©but de la ligne qui ne s'afficherait pas sinon
   Pixel_figure_preview(Paintbrush_X,Paintbrush_Y,color);
   Update_part_of_screen(Paintbrush_X,Paintbrush_Y,1,1);
 
   if ((Config.Coords_rel) && (Menu_is_visible))
-    Print_in_menu("X:±   0   Y:±   0",0);
+    Print_in_menu("X:Â±   0   Y:Â±   0",0);
 
   Operation_push(Paintbrush_X);
   Operation_push(Paintbrush_Y);
@@ -1985,11 +1985,11 @@
 
 
 void Polygon_12_9(void)
-// Opération   : OPERATION_POLYGON
+// OpÃ©ration   : OPERATION_POLYGON
 // Click Souris: 1 ou 2
 // Taille_Pile : 9
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 {
   short start_x;
   short start_y;
@@ -2018,14 +2018,14 @@
   }
   else
   {
-    //   La série de ligne est terminée, il faut donc effacer la dernière
+    //   La sÃ©rie de ligne est terminÃ©e, il faut donc effacer la derniÃ¨re
     // preview de ligne et relier le dernier point avec le premier
     Pixel_figure_preview_auto  (start_x,start_y);
     Hide_line_preview (start_x,start_y,end_x,end_y);
     Operation_pop(&end_y);
     Operation_pop(&end_x);
     Paintbrush_shape=Paintbrush_shape_before_operation;
-    // Le pied aurait été de ne pas repasser sur le 1er point de la 1ère ligne
+    // Le pied aurait Ã©tÃ© de ne pas repasser sur le 1er point de la 1Ã¨re ligne
     // mais c'est pas possible :(
     Draw_line_permanent(start_x,start_y,end_x,end_y,color);
     Paintbrush_shape=PAINTBRUSH_SHAPE_POINT;
@@ -2049,11 +2049,11 @@
 ////////////////////////////////////////////////////////// OPERATION_POLYFILL
 
 void Polyfill_12_0(void)
-// Opération   : OPERATION_POLYFILL
+// OpÃ©ration   : OPERATION_POLYFILL
 // Click Souris: 1 ou 2
 // Taille_Pile : 0
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 {
   byte color;
 
@@ -2069,12 +2069,12 @@
   Polyfill_table_of_points[1]=Paintbrush_Y;
   Polyfill_number_of_points=1;
 
-  // On place temporairement le début de la ligne qui ne s'afficherait pas sinon
+  // On place temporairement le dÃ©but de la ligne qui ne s'afficherait pas sinon
   Pixel_figure_preview_xor(Paintbrush_X,Paintbrush_Y,0);
   Update_part_of_screen(Paintbrush_X,Paintbrush_Y,1,1);
   
   if ((Config.Coords_rel) && (Menu_is_visible))
-    Print_in_menu("X:±   0   Y:±   0",0);
+    Print_in_menu("X:Â±   0   Y:Â±   0",0);
 
   Operation_push(Paintbrush_X);
   Operation_push(Paintbrush_Y);
@@ -2089,11 +2089,11 @@
 
 
 void Polyfill_0_8(void)
-// Opération   : OPERATION_POLYFILL
+// OpÃ©ration   : OPERATION_POLYFILL
 // Click Souris: 0
 // Taille_Pile : 8
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 {
   short start_x;
   short start_y;
@@ -2110,14 +2110,14 @@
   Operation_pop(&direction);
 
   if ((Config.Coords_rel) && (Menu_is_visible))
-    Print_in_menu("X:±   0   Y:±   0",0);
+    Print_in_menu("X:Â±   0   Y:Â±   0",0);
 
   Draw_line_preview_xor(start_x,start_y,end_x,end_y,0);
 
   if (direction & 0x80)
     direction=(direction & 0x7F);
 
-  Operation_push(direction); // Valeur bidon servant de nouvel état de pile
+  Operation_push(direction); // Valeur bidon servant de nouvel Ã©tat de pile
   Operation_push(direction);
   Operation_push(color);
 
@@ -2146,11 +2146,11 @@
 
 
 void Polyfill_12_8(void)
-// Opération   : OPERATION_POLYFILL
+// OpÃ©ration   : OPERATION_POLYFILL
 // Click Souris: 1 ou 2 | 0
 // Taille_Pile : 8      | 9
 //
-// Souris effacée: Non
+// Souris effacÃ©e: Non
 {
   short start_x;
   short start_y;
@@ -2182,11 +2182,11 @@
 
 
 void Polyfill_12_9(void)
-// Opération   : OPERATION_POLYFILL
+// OpÃ©ration   : OPERATION_POLYFILL
 // Click Souris: 1 ou 2
 // Taille_Pile : 9
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 {
   short start_x;
   short start_y;
@@ -2215,7 +2215,7 @@
   }
   else
   {
-    //   La série de lignes est terminée, il faut donc effacer la dernière
+    //   La sÃ©rie de lignes est terminÃ©e, il faut donc effacer la derniÃ¨re
     // preview de ligne et relier le dernier point avec le premier
     Hide_cursor();
     Draw_line_preview_xor(start_x,start_y,end_x,end_y,0);
@@ -2247,11 +2247,11 @@
 
 
 void Polyform_12_0(void)
-//  Opération   : OPERATION_POLYFORM
+//  OpÃ©ration   : OPERATION_POLYFORM
 //  Click Souris: 1 ou 2
 //  Taille_Pile : 0
 //
-//  Souris effacée: Oui
+//  Souris effacÃ©e: Oui
 {
   short color;
 
@@ -2278,11 +2278,11 @@
 
 
 void Polyform_12_8(void)
-//  Opération   : OPERATION_POLYFORM
+//  OpÃ©ration   : OPERATION_POLYFORM
 //  Click Souris: 1 ou 2
 //  Taille_Pile : 8
 //
-//  Souris effacée: Non
+//  Souris effacÃ©e: Non
 {
   short click;
   short end_y;
@@ -2305,18 +2305,18 @@
 
     if ((start_x!=Paintbrush_X) || (start_y!=Paintbrush_Y))
     {
-      // Il existe un segment définit par (start_x,start_y)-(Paintbrush_X,Paintbrush_Y)
+      // Il existe un segment dÃ©finit par (start_x,start_y)-(Paintbrush_X,Paintbrush_Y)
 
       Hide_cursor();
       Print_coordinates();
 
       Operation_pop(&color);
 
-      // On efface la preview du segment validé:
+      // On efface la preview du segment validÃ©:
       Pixel_figure_preview_auto  (start_x,start_y);
       Hide_line_preview(start_x,start_y,end_x,end_y);
 
-      // On l'affiche de façon définitive:
+      // On l'affiche de faÃ§on dÃ©finitive:
       Draw_line_permanent(start_x,start_y,Paintbrush_X,Paintbrush_Y,color);
 
       // Et on affiche un pixel de preview en (Paintbrush_X,Paintbrush_Y):
@@ -2335,7 +2335,7 @@
   }
   else
   {
-    // L'utilisateur souhaite arrêter l'opération et refermer le polygone
+    // L'utilisateur souhaite arrÃªter l'opÃ©ration et refermer le polygone
 
     Operation_pop(&color);
     Operation_pop(&initial_y);
@@ -2344,10 +2344,10 @@
     Hide_cursor();
     Print_coordinates();
 
-    // On efface la preview du segment annulé:
+    // On efface la preview du segment annulÃ©:
     Hide_line_preview(start_x,start_y,end_x,end_y);
 
-    // On affiche de façon définitive le bouclage du polygone:
+    // On affiche de faÃ§on dÃ©finitive le bouclage du polygone:
     Draw_line_permanent(start_x,start_y,initial_x,initial_y,color);
 
     Display_cursor();
@@ -2358,11 +2358,11 @@
 
 
 void Polyform_0_8(void)
-//  Opération   : OPERATION_POLYFORM
+//  OpÃ©ration   : OPERATION_POLYFORM
 //  Click Souris: 0
 //  Taille_Pile : 8
 //
-//  Souris effacée: Non
+//  Souris effacÃ©e: Non
 {
   short click;
   short end_y;
@@ -2384,7 +2384,7 @@
     Operation_pop(&start_x);
     Operation_pop(&color);
 
-    // On met à jour l'affichage de la preview du prochain segment:
+    // On met Ã  jour l'affichage de la preview du prochain segment:
     Hide_line_preview(start_x,start_y,end_x,end_y);
     Draw_line_preview (start_x,start_y,Paintbrush_X,Paintbrush_Y,color);
 
@@ -2405,17 +2405,17 @@
 
 
 void Filled_polyform_12_0(void)
-//  Opération   : OPERATION_FILLED_POLYFORM
+//  OpÃ©ration   : OPERATION_FILLED_POLYFORM
 //  Click Souris: 1 ou 2
 //  Taille_Pile : 0
 //
-//  Souris effacée: Oui
+//  Souris effacÃ©e: Oui
 {
   short color;
 
   Init_start_operation();
 
-  // Cette opération étant également utilisée pour le lasso, on ne fait pas de
+  // Cette opÃ©ration Ã©tant Ã©galement utilisÃ©e pour le lasso, on ne fait pas de
   // backup si on prend une brosse au lasso avec le bouton gauche.
   if ((Current_operation==OPERATION_FILLED_POLYFORM) || (Current_operation==OPERATION_FILLED_CONTOUR) || (Mouse_K==RIGHT_SIDE))
     Backup();
@@ -2430,7 +2430,7 @@
   Polyfill_table_of_points[1]=Paintbrush_Y;
   Polyfill_number_of_points=1;
 
-  // On place temporairement le début de la ligne qui ne s'afficherait pas sinon
+  // On place temporairement le dÃ©but de la ligne qui ne s'afficherait pas sinon
   Pixel_figure_preview_xor(Paintbrush_X,Paintbrush_Y,0);
   Update_part_of_screen(Paintbrush_X,Paintbrush_Y,1,1);
   
@@ -2446,11 +2446,11 @@
 
 
 void Filled_polyform_12_8(void)
-//  Opération   : OPERATION_FILLED_POLYFORM
+//  OpÃ©ration   : OPERATION_FILLED_POLYFORM
 //  Click Souris: 1 ou 2
 //  Taille_Pile : 8
 //
-//  Souris effacée: Non
+//  Souris effacÃ©e: Non
 {
   short click;
   short end_y;
@@ -2474,13 +2474,13 @@
     if (((start_x!=Paintbrush_X) || (start_y!=Paintbrush_Y)) &&
         (Polyfill_number_of_points<Config.Nb_max_vertices_per_polygon))
     {
-      // Il existe un nouveau segment défini par
+      // Il existe un nouveau segment dÃ©fini par
       // (start_x,start_y)-(Paintbrush_X,Paintbrush_Y)
 
       Hide_cursor();
       Print_coordinates();
 
-      // On le place à l'écran
+      // On le place Ã  l'Ã©cran
       if (Current_operation==OPERATION_FILLED_CONTOUR)
       {
         Draw_line_preview_xorback(start_x,start_y,end_x,end_y,0);
@@ -2517,13 +2517,13 @@
           Hide_cursor();
           Print_coordinates();
 
-          // On le place à l'écran
+          // On le place Ã  l'Ã©cran
           Draw_line_preview_xor(start_x,start_y,end_x,end_y,0);
           Draw_line_preview_xor(start_x,start_y,Paintbrush_X,Paintbrush_Y,0);
           Display_cursor();
         }
 
-        // On remet les mêmes valeurs (comme si on n'avait pas cliqué):
+        // On remet les mÃªmes valeurs (comme si on n'avait pas cliquÃ©):
         Operation_push(start_x);
         Operation_push(start_y);
         Operation_push(Paintbrush_X);
@@ -2542,7 +2542,7 @@
   }
   else
   {
-    // L'utilisateur souhaite arrêter l'opération et refermer le polygone
+    // L'utilisateur souhaite arrÃªter l'opÃ©ration et refermer le polygone
 
     Operation_pop(&color);
     Operation_pop(&initial_y);
@@ -2569,11 +2569,11 @@
 
 
 void Filled_polyform_0_8(void)
-//  Opération   : OPERATION_FILLED_POLYFORM
+//  OpÃ©ration   : OPERATION_FILLED_POLYFORM
 //  Click Souris: 0
 //  Taille_Pile : 8
 //
-//  Souris effacée: Non
+//  Souris effacÃ©e: Non
 {
   short click;
   short end_y;
@@ -2593,7 +2593,7 @@
     Operation_pop(&start_y);
     Operation_pop(&start_x);
 
-    // On met à jour l'affichage de la preview du prochain segment:
+    // On met Ã  jour l'affichage de la preview du prochain segment:
     Draw_line_preview_xor(start_x,start_y,end_x,end_y,0);
     Draw_line_preview_xor(start_x,start_y,Paintbrush_X,Paintbrush_Y,0);
 
@@ -2609,11 +2609,11 @@
 }
 
 void Filled_contour_0_8(void)
-//  Opération   : OPERATION_FILLED_CONTOUR
+//  OpÃ©ration   : OPERATION_FILLED_CONTOUR
 //  Click Souris: 0
 //  Taille_Pile : 8
 //
-//  Souris effacée: Non
+//  Souris effacÃ©e: Non
 {
   short click;
   short end_y;
@@ -2658,11 +2658,11 @@
 
 void Scroll_12_0(void)
 //
-//  Opération   : OPERATION_SCROLL
+//  OpÃ©ration   : OPERATION_SCROLL
 //  Click Souris: 1 ou 2
 //  Taille_Pile : 0
 //
-//  Souris effacée: Oui
+//  Souris effacÃ©e: Oui
 //
 {
   Init_start_operation();
@@ -2679,17 +2679,17 @@
   Cursor_hidden_before_scroll=Cursor_hidden;
   Cursor_hidden=1;
   if ((Config.Coords_rel) && (Menu_is_visible))
-    Print_in_menu("X:±   0   Y:±   0",0);
+    Print_in_menu("X:Â±   0   Y:Â±   0",0);
 }
 
 
 void Scroll_12_5(void)
 //
-//  Opération   : OPERATION_SCROLL
+//  OpÃ©ration   : OPERATION_SCROLL
 //  Click Souris: 1 ou 2
 //  Taille_Pile : 5
 //
-//  Souris effacée: Non
+//  Souris effacÃ©e: Non
 //
 {
   short center_x;
@@ -2709,7 +2709,7 @@
 
   if ( (Paintbrush_X!=x_pos) || (Paintbrush_Y!=y_pos) )
   {
-    // L'utilisateur a bougé, il faut scroller l'image
+    // L'utilisateur a bougÃ©, il faut scroller l'image
 
     if (Paintbrush_X>=center_x)
       x_offset=(Paintbrush_X-center_x)%Main_image_width;
@@ -2748,11 +2748,11 @@
 
 void Scroll_0_5(void)
 //
-//  Opération   : OPERATION_SCROLL
+//  OpÃ©ration   : OPERATION_SCROLL
 //  Click Souris: 0
 //  Taille_Pile : 5
 //
-//  Souris effacée: Oui
+//  Souris effacÃ©e: Oui
 //
 {
   // All layers at once
@@ -2815,11 +2815,11 @@
 
 void Grad_circle_12_0(void)
 //
-// Opération   : OPERATION_GRAD_CIRCLE
+// OpÃ©ration   : OPERATION_GRAD_CIRCLE
 // Click Souris: 1 ou 2
 // Taille_Pile : 0
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 {
   byte color;
 
@@ -2849,11 +2849,11 @@
 
 void Grad_circle_12_6(void)
 //
-// Opération   : OPERATION_GRAD_CIRCLE
+// OpÃ©ration   : OPERATION_GRAD_CIRCLE
 // Click Souris: 1 ou 2
 // Taille_Pile : 6 (Mouse_K, color, X_Centre, Y_Centre, X_Tangente, Y_Tangente)
 //
-// Souris effacée: Non
+// Souris effacÃ©e: Non
 //
 {
   short tangent_x;
@@ -2904,11 +2904,11 @@
 
 void Grad_circle_0_6(void)
 //
-// Opération   : OPERATION_GRAD_CIRCLE
+// OpÃ©ration   : OPERATION_GRAD_CIRCLE
 // Click Souris: 0
 // Taille_Pile : 6 (Mouse_K, color, X_Centre, Y_Centre, X_Tangente, Y_Tangente)
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 //
 {
   short tangent_x;
@@ -2979,11 +2979,11 @@
 
 void Grad_circle_12_8(void)
 //
-// Opération   : OPERATION_GRAD_CIRCLE
+// OpÃ©ration   : OPERATION_GRAD_CIRCLE
 // Click Souris: 0
 // Taille_Pile : 8 (Mouse_K, color, X_Centre, Y_Centre, X_Tangente, Y_Tangente, old_x, old_y)
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 //
 {
   short tangent_x;
@@ -2995,7 +2995,7 @@
 
   short radius;
 
-  Operation_stack_size-=2;   // On fait sauter les 2 derniers élts de la pile
+  Operation_stack_size-=2;   // On fait sauter les 2 derniers Ã©lts de la pile
   Operation_pop(&tangent_y);
   Operation_pop(&tangent_x);
   Operation_pop(&center_y);
@@ -3032,11 +3032,11 @@
 
 void Grad_circle_or_ellipse_0_8(void)
 //
-// Opération   : OPERATION_{CERCLE|ELLIPSE}_DEGRADE
+// OpÃ©ration   : OPERATION_{CERCLE|ELLIPSE}_DEGRADE
 // Click Souris: 0
 // Taille_Pile : 8
 //
-// Souris effacée: Non
+// Souris effacÃ©e: Non
 //
 {
   short start_x;
@@ -3072,11 +3072,11 @@
 
 void Grad_ellipse_12_0(void)
 //
-// Opération   : OPERATION_GRAD_ELLIPSE
+// OpÃ©ration   : OPERATION_GRAD_ELLIPSE
 // Click Souris: 1 ou 2
 // Taille_Pile : 0
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 {
   byte color;
 
@@ -3093,7 +3093,7 @@
   Update_part_of_screen(Paintbrush_X,Paintbrush_Y,1,1);
   
   if ((Config.Coords_rel) && (Menu_is_visible))
-    Print_in_menu("X:±   0   Y:±   0",0);
+    Print_in_menu("X:Â±   0   Y:Â±   0",0);
 
   Operation_push(Mouse_K);
   Operation_push(color);
@@ -3106,11 +3106,11 @@
 
 void Grad_ellipse_12_6(void)
 //
-// Opération   : OPERATION_GRAD_ELLIPSE
+// OpÃ©ration   : OPERATION_GRAD_ELLIPSE
 // Click Souris: 1 ou 2
 // Taille_Pile : 6 (Mouse_K, color, X_Centre, Y_Centre, X_Tangente, Y_Tangente)
 //
-// Souris effacée: Non
+// Souris effacÃ©e: Non
 //
 {
   short tangent_x;
@@ -3157,11 +3157,11 @@
 
 void Grad_ellipse_0_6(void)
 //
-// Opération   : OPERATION_GRAD_ELLIPSE
+// OpÃ©ration   : OPERATION_GRAD_ELLIPSE
 // Click Souris: 0
 // Taille_Pile : 6 (Mouse_K, color, X_Centre, Y_Centre, X_Tangente, Y_Tangente)
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 //
 {
   short tangent_x;
@@ -3235,11 +3235,11 @@
 
 void Grad_ellipse_12_8(void)
 //
-// Opération   : OPERATION_GRAD_ELLIPSE
+// OpÃ©ration   : OPERATION_GRAD_ELLIPSE
 // Click Souris: 0
 // Taille_Pile : 8 (Mouse_K, color, X_Centre, Y_Centre, X_Tangente, Y_Tangente, old_x, old_y)
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 //
 {
   short tangent_x;
@@ -3251,7 +3251,7 @@
   short vertical_radius;
   short old_mouse_k;
 
-  Operation_stack_size-=2;   // On fait sauter les 2 derniers élts de la pile
+  Operation_stack_size-=2;   // On fait sauter les 2 derniers Ã©lts de la pile
   Operation_pop(&tangent_y);
   Operation_pop(&tangent_x);
   Operation_pop(&center_y);
@@ -3290,26 +3290,26 @@
 * Operation_Rectangle_Degrade *
 ******************************/
 
-// 1) tracé d'un rectangle classique avec les lignes XOR
-// 2) tracé d'une ligne vecteur de dégradé, comme une ligne normale
-// 3) dessin du dégradé
+// 1) tracÃ© d'un rectangle classique avec les lignes XOR
+// 2) tracÃ© d'une ligne vecteur de dÃ©gradÃ©, comme une ligne normale
+// 3) dessin du dÃ©gradÃ©
 
 
 void Grad_rectangle_12_0(void)
-// Opération   : OPERATION_GRAD_RECTANGLE
+// OpÃ©ration   : OPERATION_GRAD_RECTANGLE
 // Click Souris: 1 ou 2
 // Taille_Pile : 0
 //
-// Souris effacée: Oui
+// Souris effacÃ©e: Oui
 
-// Initialisation de l'étape 1, on commence à dessiner le rectangle
+// Initialisation de l'Ã©tape 1, on commence Ã  dessiner le rectangle
 {
   Init_start_operation();
   Backup();
 
   if ((Config.Coords_rel) && (Menu_is_visible))
     Print_in_menu("\035:   1   \022:   1",0);
-  // On laisse une trace du curseur à l'écran
+  // On laisse une trace du curseur Ã  l'Ã©cran
   Display_cursor();
 
   if (Mouse_K==LEFT_SIDE)
@@ -3331,11 +3331,11 @@
 
 
 void Grad_rectangle_12_5(void)
-// Opération   : OPERATION_GRAD_RECTANGLE
+// OpÃ©ration   : OPERATION_GRAD_RECTANGLE
 // Click Souris: 1 ou 2
 // Taille_Pile : 5
 //
-// Souris effacée: Non
+// Souris effacÃ©e: Non
 
 // Modification de la taille du rectangle
 {
@@ -3376,13 +3376,13 @@
 // click souris 0
 // Taile pile : 5
 //
-// Souris effacée : non
+// Souris effacÃ©e : non
 
-// Le rectangle est en place, maintenant il faut tracer le vecteur de dégradé,
+// Le rectangle est en place, maintenant il faut tracer le vecteur de dÃ©gradÃ©,
 // on doit donc attendre que l'utilisateur clique quelque part
-// On stocke tout de suite les coordonnées du pinceau comme ça on change d'état et on passe à la suite
+// On stocke tout de suite les coordonnÃ©es du pinceau comme Ã§a on change d'Ã©tat et on passe Ã  la suite
 {
-  // !!! Cette fonction remet rax ray rbx rby dans la pile à la fin donc il ne faut pas les modifier ! (sauf éventuellement un tri)
+  // !!! Cette fonction remet rax ray rbx rby dans la pile Ã  la fin donc il ne faut pas les modifier ! (sauf Ã©ventuellement un tri)
   short rax;
   short ray;
   short rbx;
@@ -3393,7 +3393,7 @@
   short offset_top = 0;
 
 
-  // Tracé propre du rectangle
+  // TracÃ© propre du rectangle
   Operation_pop(&rby);
   Operation_pop(&rbx);
   Operation_pop(&ray);
@@ -3451,7 +3451,7 @@
   Update_rect(Min(rax, rbx) - Main_offset_X, Min(ray, rby) - Main_offset_Y,
     width + 1 - offset_width, height + 1 - offset_height);
 
-  // Dessin dans la zone zoomée
+  // Dessin dans la zone zoomÃ©e
   if (Main_magnifier_mode && Min(rax, rbx) <= Limit_right_zoom
     && Max(rax, rbx) > Limit_left_zoom
     && Min(ray, rby) <= Limit_bottom_zoom
@@ -3460,22 +3460,22 @@
     offset_width = 0;
     offset_height = 0;
 
-  if (Min(rax, rbx)<=Limit_left_zoom) // On dépasse du zoom à gauche
+  if (Min(rax, rbx)<=Limit_left_zoom) // On dÃ©passe du zoom Ã  gauche
   {
     offset_width += Limit_left_zoom - Min(rax, rbx);
     offset_left = Limit_left_zoom;
   }
 
-    if(Max(rax,rbx)>Limit_right_zoom) // On dépasse du zoom à droite
+    if(Max(rax,rbx)>Limit_right_zoom) // On dÃ©passe du zoom Ã  droite
         offset_width += Max(rax,rbx) - Limit_right_zoom - 1;
 
-    if(Min(ray,rby)<Limit_top_zoom) // On dépasse du zoom en haut
+    if(Min(ray,rby)<Limit_top_zoom) // On dÃ©passe du zoom en haut
     {
         offset_height += Limit_top_zoom - Min(ray,rby);
         offset_top = Limit_top_zoom;
     }
 
-    if(Max(ray,rby)>Limit_bottom_zoom) // On dépasse du zoom en bas
+    if(Max(ray,rby)>Limit_bottom_zoom) // On dÃ©passe du zoom en bas
         offset_height += Max(ray,rby) - Limit_bottom_zoom - 1;
 
     if(width > offset_width)
@@ -3502,7 +3502,7 @@
   Operation_push(rbx);
   Operation_push(rby);
 
-  // On ajoute des trucs dans la pile pour forcer le passage à l'étape suivante
+  // On ajoute des trucs dans la pile pour forcer le passage Ã  l'Ã©tape suivante
   Operation_push(rbx);
   Operation_push(rby);
 }
@@ -3512,9 +3512,9 @@
 // click souris 0
 // Taile pile : 5
 //
-// Souris effacée : non
+// Souris effacÃ©e : non
 
-// On continue à attendre que l'utilisateur clique en gardant les coords à jour
+// On continue Ã  attendre que l'utilisateur clique en gardant les coords Ã  jour
 {
     Operation_stack_size -= 2;
     Print_coordinates();
@@ -3523,16 +3523,16 @@
 }
 
 void Grad_rectangle_12_7(void)
-// Opération   : OPERATION_GRAD_RECTANGLE
+// OpÃ©ration   : OPERATION_GRAD_RECTANGLE
 // Click Souris: 1 ou 2
 // Taille_Pile : 7
 //
-//  Souris effacée: Oui
+//  Souris effacÃ©e: Oui
 
-//  Début du tracé du vecteur (premier clic)
-// On garde les anciennes coordonnées dans la pile, et on ajoute les nouvelles par dessus
+//  DÃ©but du tracÃ© du vecteur (premier clic)
+// On garde les anciennes coordonnÃ©es dans la pile, et on ajoute les nouvelles par dessus
 
-// Si l'utilisateur utilise le mauvais bouton, on annule le tracé. Mais ça nous oblige à vider toute la pile pour vérifier :(
+// Si l'utilisateur utilise le mauvais bouton, on annule le tracÃ©. Mais Ã§a nous oblige Ã  vider toute la pile pour vÃ©rifier :(
 {
   short rax,rbx,ray,rby,vax,vay,click;
 
@@ -3560,8 +3560,8 @@
   }
   else
   {
-      // Mauvais bouton > anulation de l'opération.
-      // On a déjà vidé la pile, il reste à effacer le rectangle XOR
+      // Mauvais bouton > anulation de l'opÃ©ration.
+      // On a dÃ©jÃ  vidÃ© la pile, il reste Ã  effacer le rectangle XOR
       short width, height;
       short offset_width = 0;
       short offset_height = 0;
@@ -3571,7 +3571,7 @@
       width = abs(rbx-rax);
       height = abs(rby-ray);
 
-      if (Max(rax,rbx)-Main_offset_X > Min(Main_image_width,Main_magnifier_mode?Main_separator_position:Screen_width)) // Tous les clippings à gérer sont là
+      if (Max(rax,rbx)-Main_offset_X > Min(Main_image_width,Main_magnifier_mode?Main_separator_position:Screen_width)) // Tous les clippings Ã  gÃ©rer sont lÃ 
           offset_width = Max(rax,rbx) - Min(Main_image_width,Main_magnifier_mode?Main_separator_position:Screen_width);
 
       if (Max(ray,rby)-Main_offset_Y > Min(Main_image_height,Menu_Y))
@@ -3588,7 +3588,7 @@
 
       Update_rect(Min(rax,rbx)-Main_offset_X,Min(ray,rby)-Main_offset_Y,width+1-offset_width,height+1-offset_height);
 
-      // Dessin dans la zone zoomée
+      // Dessin dans la zone zoomÃ©e
       if (Main_magnifier_mode && Min(rax, rbx) <= Limit_right_zoom
         && Max(rax, rbx)>Limit_left_zoom && Min(ray, rby) <= Limit_bottom_zoom
         && Max(ray,rby)>Limit_top_zoom )
@@ -3596,22 +3596,22 @@
           offset_width = 0;
           offset_height=0;
 
-          if(Min(rax,rbx)<Limit_left_zoom) // On dépasse du zoom à gauche
+          if(Min(rax,rbx)<Limit_left_zoom) // On dÃ©passe du zoom Ã  gauche
           {
               offset_width += Limit_left_zoom - Min(rax,rbx);
               offset_left = Limit_left_zoom;
           }
 
-          if(Max(rax,rbx)>Limit_right_zoom) // On dépasse du zoom à droite
+          if(Max(rax,rbx)>Limit_right_zoom) // On dÃ©passe du zoom Ã  droite
               offset_width += Max(rax,rbx) - Limit_right_zoom - 1;
 
-          if(Min(ray,rby)<Limit_top_zoom) // On dépasse du zoom en haut
+          if(Min(ray,rby)<Limit_top_zoom) // On dÃ©passe du zoom en haut
           {
               offset_height += Limit_top_zoom - Min(ray,rby);
               offset_top = Limit_top_zoom;
           }
 
-          if(Max(ray,rby)>Limit_bottom_zoom) // On dépasse du zoom en bas
+          if(Max(ray,rby)>Limit_bottom_zoom) // On dÃ©passe du zoom en bas
               offset_height += Max(ray,rby) - Limit_bottom_zoom - 1;
 
           if(width > offset_width)
@@ -3636,13 +3636,13 @@
 }
 
 void Grad_rectangle_12_9(void)
-    // Opération   : OPERATION_GRAD_RECTANGLE
+    // OpÃ©ration   : OPERATION_GRAD_RECTANGLE
     // Click Souris: 1
     // Taille_Pile : 5
     //
-    // Souris effacée: Oui
+    // Souris effacÃ©e: Oui
 
-    // Poursuite du tracé du vecteur (déplacement de la souris en gardant le curseur appuyé)
+    // Poursuite du tracÃ© du vecteur (dÃ©placement de la souris en gardant le curseur appuyÃ©)
 {
     short start_x;
     short start_y;
@@ -3658,7 +3658,7 @@
 
     cursor_x = Paintbrush_X;
     cursor_y = Paintbrush_Y;
-    // On corrige les coordonnées de la ligne si la touche shift est appuyée...
+    // On corrige les coordonnÃ©es de la ligne si la touche shift est appuyÃ©e...
     if(SDL_GetModState() & KMOD_SHIFT)
         Clamp_coordinates_regular_angle(start_x,start_y,&cursor_x,&cursor_y);
         
@@ -3679,13 +3679,13 @@
 }
 
 void Grad_rectangle_0_9(void)
-    // Opération   : OPERATION_GRAD_RECTANGLE
+    // OpÃ©ration   : OPERATION_GRAD_RECTANGLE
     // Click Souris: 0
     // Taille_Pile : 9
     //
-    //  Souris effacée: Oui
+    //  Souris effacÃ©e: Oui
 
-    // Ouf, fini ! on dessine enfin le rectangle avec son dégradé
+    // Ouf, fini ! on dessine enfin le rectangle avec son dÃ©gradÃ©
 {
     short rect_start_x;
     short rect_start_y;
@@ -3711,10 +3711,10 @@
     // Maintenant on efface tout le bazar temporaire : rectangle et ligne XOR
     Hide_line_preview(vector_start_x,vector_start_y,vector_end_x,vector_end_y);
 
-    // Et enfin on trace le rectangle avec le dégradé dedans !
+    // Et enfin on trace le rectangle avec le dÃ©gradÃ© dedans !
     if (vector_end_x==vector_start_x && vector_end_y==vector_start_y)
     {
-        // Vecteur nul > pas de rectangle tracé
+        // Vecteur nul > pas de rectangle tracÃ©
         // Du coup on doit effacer la preview xor ...
         short width, height;
         short offset_width = 0;
@@ -3725,7 +3725,7 @@
         width = abs(rect_end_x-rect_start_x);
         height = abs(rect_end_y-rect_start_y);
 
-        if (Max(rect_start_x,rect_end_x)-Main_offset_X > Min(Main_image_width,Main_magnifier_mode?Main_separator_position:Screen_width)) // Tous les clippings à gérer sont là
+        if (Max(rect_start_x,rect_end_x)-Main_offset_X > Min(Main_image_width,Main_magnifier_mode?Main_separator_position:Screen_width)) // Tous les clippings Ã  gÃ©rer sont lÃ 
             offset_width = Max(rect_start_x,rect_end_x) - Min(Main_image_width,Main_magnifier_mode?Main_separator_position:Screen_width);
 
         if (Max(rect_start_y,rect_end_y)-Main_offset_Y > Min(Main_image_height,Menu_Y))
@@ -3742,7 +3742,7 @@
 
         Update_rect(Min(rect_start_x,rect_end_x)-Main_offset_X,Min(rect_start_y,rect_end_y)-Main_offset_Y,width+1-offset_width,height+1-offset_height);
 
-        // Dessin dans la zone zoomée
+        // Dessin dans la zone zoomÃ©e
         if (Main_magnifier_mode
             && Min(rect_start_x, rect_end_x) <= Limit_right_zoom
             && Max(rect_start_x, rect_end_x) > Limit_left_zoom
@@ -3752,22 +3752,22 @@
             offset_width = 0;
             offset_height=0;
 
-            if(Min(rect_start_x,rect_end_x)<Limit_left_zoom) // On dépasse du zoom à gauche
+            if(Min(rect_start_x,rect_end_x)<Limit_left_zoom) // On dÃ©passe du zoom Ã  gauche
             {
                 offset_width += Limit_left_zoom - Min(rect_start_x,rect_end_x);
                 offset_left = Limit_left_zoom;
             }
 
-            if(Max(rect_start_x,rect_end_x)>Limit_right_zoom) // On dépasse du zoom à droite
+            if(Max(rect_start_x,rect_end_x)>Limit_right_zoom) // On dÃ©passe du zoom Ã  droite
                 offset_width += Max(rect_start_x,rect_end_x) - Limit_right_zoom;
 
-            if(Min(rect_start_y,rect_end_y)<Limit_top_zoom) // On dépasse du zoom en haut
+            if(Min(rect_start_y,rect_end_y)<Limit_top_zoom) // On dÃ©passe du zoom en haut
             {
                 offset_height += Limit_top_zoom - Min(rect_start_y,rect_end_y);
                 offset_top = Limit_top_zoom;
             }
 
-            if(Max(rect_start_y,rect_end_y)>Limit_bottom_zoom) // On dépasse du zoom en bas
+            if(Max(rect_start_y,rect_end_y)>Limit_bottom_zoom) // On dÃ©passe du zoom en bas
                 offset_height += Max(rect_start_y,rect_end_y) - Limit_bottom_zoom;
 
             if(width > offset_width)
@@ -3806,18 +3806,18 @@
 
 
 void Centered_lines_12_0(void)
-    // Opération   : OPERATION_CENTERED_LINES
+    // OpÃ©ration   : OPERATION_CENTERED_LINES
     // Click Souris: 1 ou 2
     // Taille_Pile : 0
     //
-    //  Souris effacée: Oui
+    //  Souris effacÃ©e: Oui
 {
     Init_start_operation();
     Backup();
     Shade_table=(Mouse_K==LEFT_SIDE)?Shade_table_left:Shade_table_right;
 
     if ((Config.Coords_rel) && (Menu_is_visible))
-        Print_in_menu("X:±   0   Y:±   0",0);
+        Print_in_menu("X:Â±   0   Y:Â±   0",0);
 
     Operation_push(Mouse_K);
     Operation_push(Paintbrush_X);
@@ -3826,11 +3826,11 @@
 
 
 void Centered_lines_12_3(void)
-    // Opération   : OPERATION_CENTERED_LINES
+    // OpÃ©ration   : OPERATION_CENTERED_LINES
     // Click Souris: 1 ou 2
     // Taille_Pile : 3
     //
-    // Souris effacée: Non
+    // Souris effacÃ©e: Non
 {
     short start_x;
     short start_y;
@@ -3843,11 +3843,11 @@
 
 
 void Centered_lines_0_3(void)
-    // Opération   : OPERATION_CENTERED_LINES
+    // OpÃ©ration   : OPERATION_CENTERED_LINES
     // Click Souris: 0
     // Taille_Pile : 3
     //
-    // Souris effacée: Oui
+    // Souris effacÃ©e: Oui
 {
     short start_x;
     short start_y;
@@ -3865,21 +3865,21 @@
     Paintbrush_shape=PAINTBRUSH_SHAPE_POINT;
 
     Operation_push(Button);
-    Operation_push(Paintbrush_X); // Nouveau début X
-    Operation_push(Paintbrush_Y); // Nouveau début Y
-    Operation_push(Paintbrush_X); // Nouvelle dernière fin X
-    Operation_push(Paintbrush_Y); // Nouvelle dernière fin Y
-    Operation_push(Paintbrush_X); // Nouvelle dernière position X
-    Operation_push(Paintbrush_Y); // Nouvelle dernière position Y
+    Operation_push(Paintbrush_X); // Nouveau dÃ©but X
+    Operation_push(Paintbrush_Y); // Nouveau dÃ©but Y
+    Operation_push(Paintbrush_X); // Nouvelle derniÃ¨re fin X
+    Operation_push(Paintbrush_Y); // Nouvelle derniÃ¨re fin Y
+    Operation_push(Paintbrush_X); // Nouvelle derniÃ¨re position X
+    Operation_push(Paintbrush_Y); // Nouvelle derniÃ¨re position Y
 }
 
 
 void Centered_lines_12_7(void)
-    // Opération   : OPERATION_CENTERED_LINES
+    // OpÃ©ration   : OPERATION_CENTERED_LINES
     // Click Souris: 1 ou 2
     // Taille_Pile : 7
     //
-    // Souris effacée: Non
+    // Souris effacÃ©e: Non
 {
     short Button;
     short start_x;
@@ -3954,11 +3954,11 @@
 
 
 void Centered_lines_0_7(void)
-    // Opération   : OPERATION_CENTERED_LINES
+    // OpÃ©ration   : OPERATION_CENTERED_LINES
     // Click Souris: 0
     // Taille_Pile : 7
     //
-    // Souris effacée: Non
+    // Souris effacÃ©e: Non
 {
     short Button;
     short start_x;
diff -ruN gfx2orig/src/pages.c grafx2/src/pages.c
--- gfx2orig/src/pages.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/pages.c	2022-03-20 20:19:34.108495316 -0500
@@ -142,7 +142,7 @@
 // ==============================================================
 
 void Download_infos_page_main(T_Page * page)
-// Affiche la page à l'écran
+// Affiche la page Ã  l'Ã©cran
 {
   //int factor_index;
   int size_is_modified;
@@ -340,7 +340,7 @@
 }
 
 void Upload_infos_page_main(T_Page * page)
-// Sauve l'écran courant dans la page
+// Sauve l'Ã©cran courant dans la page
 {
   if (page!=NULL)
   {
@@ -389,7 +389,7 @@
 
 void Clear_page(T_Page * page)
 {
-  // On peut appeler cette fonction sur une page non allouée.
+  // On peut appeler cette fonction sur une page non allouÃ©e.
   int i;
   for (i=0; i<page->Nb_layers; i++)
   {
@@ -398,7 +398,7 @@
   }
   page->Width=0;
   page->Height=0;
-  // On ne se préoccupe pas de ce que deviens le reste des infos de l'image.
+  // On ne se prÃ©occupe pas de ce que deviens le reste des infos de l'image.
 }
 
 void Copy_S_page(T_Page * dest,T_Page * source)
@@ -422,8 +422,8 @@
 
 int Allocate_list_of_pages(T_List_of_pages * list)
 {
-  // Important: la T_List_of_pages ne doit pas déjà désigner une liste de
-  //            pages allouée auquel cas celle-ci serait perdue.
+  // Important: la T_List_of_pages ne doit pas dÃ©jÃ  dÃ©signer une liste de
+  //            pages allouÃ©e auquel cas celle-ci serait perdue.
   T_Page * page;
 
   // On initialise chacune des nouvelles pages
@@ -438,26 +438,26 @@
 
   list->List_size=1;
 
-  return 1; // Succès
+  return 1; // SuccÃ¨s
 }
 
 
 void Backward_in_list_of_pages(T_List_of_pages * list)
 {
-  // Cette fonction fait l'équivalent d'un "Undo" dans la liste de pages.
+  // Cette fonction fait l'Ã©quivalent d'un "Undo" dans la liste de pages.
   // Elle effectue une sorte de ROL (Rotation Left) sur la liste:
   // +---+-+-+-+-+-+-+-+-+-+  |
-  // ¦0¦1¦2¦3¦4¦5¦6¦7¦8¦9¦A¦  |
+  // Â¦0Â¦1Â¦2Â¦3Â¦4Â¦5Â¦6Â¦7Â¦8Â¦9Â¦AÂ¦  |
   // +---+-+-+-+-+-+-+-+-+-+  |  0=page courante
-  //  ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦ ¦   |_ A=page la plus ancienne
-  //  v v v v v v v v v v v   |  1=DerniÞre page (1er backup)
+  //  Â¦ Â¦ Â¦ Â¦ Â¦ Â¦ Â¦ Â¦ Â¦ Â¦ Â¦   |_ A=page la plus ancienne
+  //  v v v v v v v v v v v   |  1=DerniÃre page (1er backup)
   // +---+-+-+-+-+-+-+-+-+-+  |
-  // ¦1¦2¦3¦4¦5¦6¦7¦8¦9¦A¦0¦  |
+  // Â¦1Â¦2Â¦3Â¦4Â¦5Â¦6Â¦7Â¦8Â¦9Â¦AÂ¦0Â¦  |
   // +---+-+-+-+-+-+-+-+-+-+  |
 
-  // Pour simuler un véritable Undo, l'appelant doit mettre la structure
-  // de page courante à jour avant l'appel, puis en réextraire les infos en
-  // sortie, ainsi que celles relatives à la plus récente page d'undo (1ère
+  // Pour simuler un vÃ©ritable Undo, l'appelant doit mettre la structure
+  // de page courante Ã  jour avant l'appel, puis en rÃ©extraire les infos en
+  // sortie, ainsi que celles relatives Ã  la plus rÃ©cente page d'undo (1Ã¨re
   // page de la liste).
 
   if (Last_backed_up_layers)
@@ -484,20 +484,20 @@
 
 void Advance_in_list_of_pages(T_List_of_pages * list)
 {
-  // Cette fonction fait l'équivalent d'un "Redo" dans la liste de pages.
+  // Cette fonction fait l'Ã©quivalent d'un "Redo" dans la liste de pages.
   // Elle effectue une sorte de ROR (Rotation Right) sur la liste:
   // +-+-+-+-+-+-+-+-+-+-+-+  |
   // |0|1|2|3|4|5|6|7|8|9|A|  |
   // +-+-+-+-+-+-+-+-+-+-+-+  |  0=page courante
   //  | | | | | | | | | | |   |_ A=page la plus ancienne
-  //  v v v v v v v v v v v   |  1=Dernière page (1er backup)
+  //  v v v v v v v v v v v   |  1=DerniÃ¨re page (1er backup)
   // +-+-+-+-+-+-+-+-+-+-+-+  |
   // |A|0|1|2|3|4|5|6|7|8|9|  |
   // +-+-+-+-+-+-+-+-+-+-+-+  |
 
-  // Pour simuler un véritable Redo, l'appelant doit mettre la structure
-  // de page courante à jour avant l'appel, puis en réextraire les infos en
-  // sortie, ainsi que celles relatives à la plus récente page d'undo (1ère
+  // Pour simuler un vÃ©ritable Redo, l'appelant doit mettre la structure
+  // de page courante Ã  jour avant l'appel, puis en rÃ©extraire les infos en
+  // sortie, ainsi que celles relatives Ã  la plus rÃ©cente page d'undo (1Ã¨re
   // page de la liste).
   if (Last_backed_up_layers)
   {
@@ -594,15 +594,15 @@
 
 void Free_page_of_a_list(T_List_of_pages * list)
 {
-  // On ne peut pas détruire la page courante de la liste si après
+  // On ne peut pas dÃ©truire la page courante de la liste si aprÃ¨s
   // destruction il ne reste pas encore au moins une page.
   if (list->List_size>1)
   {
-    // On fait faire un undo à la liste, comme ça, la nouvelle page courante
-    // est la page précédente
+    // On fait faire un undo Ã  la liste, comme Ã§a, la nouvelle page courante
+    // est la page prÃ©cÃ©dente
     Backward_in_list_of_pages(Main_backups);
 
-    // Puis on détruit la dernière page, qui est l'ancienne page courante
+    // Puis on dÃ©truit la derniÃ¨re page, qui est l'ancienne page courante
     Free_last_page_of_list(list);
   }
 }
@@ -686,18 +686,18 @@
 
 int Init_all_backup_lists(int width,int height)
 {
-  // width et height correspondent à la dimension des images de départ.
+  // width et height correspondent Ã  la dimension des images de dÃ©part.
   int i;
 
   if (! Allocate_list_of_pages(Main_backups) ||
       ! Allocate_list_of_pages(Spare_backups))
     return 0;
-  // On a réussi à allouer deux listes de pages dont la taille correspond à
-  // celle demandée par l'utilisateur.
+  // On a rÃ©ussi Ã  allouer deux listes de pages dont la taille correspond Ã 
+  // celle demandÃ©e par l'utilisateur.
 
-  // On crée un descripteur de page correspondant à la page principale
+  // On crÃ©e un descripteur de page correspondant Ã  la page principale
   Upload_infos_page_main(Main_backups->Pages);
-  // On y met les infos sur la dimension de démarrage
+  // On y met les infos sur la dimension de dÃ©marrage
   Main_backups->Pages->Width=width;
   Main_backups->Pages->Height=height;
   strcpy(Main_backups->Pages->File_directory,Main_current_directory);
@@ -772,7 +772,7 @@
   Change_page_number_of_list(Main_backups,nb_backups+1);
   Change_page_number_of_list(Spare_backups,nb_backups+1);
 
-  // Le +1 vient du fait que dans chaque liste, en 1ère position on retrouve
+  // Le +1 vient du fait que dans chaque liste, en 1Ã¨re position on retrouve
   // les infos de la page courante sur le brouillon et la page principale.
   // (nb_backups = Nombre de backups, sans compter les pages courantes)
 }
@@ -787,11 +787,11 @@
   int i;
 
   if (upload)
-    // On remet à jour l'état des infos de la page courante (pour pouvoir les
+    // On remet Ã  jour l'Ã©tat des infos de la page courante (pour pouvoir les
     // retrouver plus tard)
     Upload_infos_page_main(Main_backups->Pages);
 
-  // On crée un descripteur pour la nouvelle page courante
+  // On crÃ©e un descripteur pour la nouvelle page courante
   new_page=New_page(layers);
   if (!new_page)
   {
@@ -840,7 +840,7 @@
   byte nb_layers;
 
   nb_layers=Spare_backups->Pages->Nb_layers;
-  // On crée un descripteur pour la nouvelle page de brouillon
+  // On crÃ©e un descripteur pour la nouvelle page de brouillon
   new_page=New_page(nb_layers);
   if (!new_page)
   {
@@ -875,8 +875,8 @@
 }
 
 void Backup(void)
-// Sauve la page courante comme première page de backup et crée une nouvelle page
-// pur continuer à dessiner. Utilisé par exemple pour le fill
+// Sauve la page courante comme premiÃ¨re page de backup et crÃ©e une nouvelle page
+// pur continuer Ã  dessiner. UtilisÃ© par exemple pour le fill
 {
   Backup_layers(1<<Main_current_layer);
 }
@@ -891,7 +891,7 @@
     return; // Already done.
   */
 
-  // On remet à jour l'état des infos de la page courante (pour pouvoir les
+  // On remet Ã  jour l'Ã©tat des infos de la page courante (pour pouvoir les
   // retrouver plus tard)
   Upload_infos_page_main(Main_backups->Pages);
 
@@ -973,20 +973,20 @@
     Last_backed_up_layers=0;
   }
 
-  // On remet à jour l'état des infos de la page courante (pour pouvoir les
+  // On remet Ã  jour l'Ã©tat des infos de la page courante (pour pouvoir les
   // retrouver plus tard)
   Upload_infos_page_main(Main_backups->Pages);
-  // On fait faire un undo à la liste des backups de la page principale
+  // On fait faire un undo Ã  la liste des backups de la page principale
   Backward_in_list_of_pages(Main_backups);
 
   Update_buffers(Main_backups->Pages->Width, Main_backups->Pages->Height);
 
   // On extrait ensuite les infos sur la nouvelle page courante
   Download_infos_page_main(Main_backups->Pages);
-  // Note: le backup n'a pas obligatoirement les mêmes dimensions ni la même
+  // Note: le backup n'a pas obligatoirement les mÃªmes dimensions ni la mÃªme
   //       palette que la page courante. Mais en temps normal, le backup
-  //       n'est pas utilisé à la suite d'un Undo. Donc ça ne devrait pas
-  //       poser de problèmes.
+  //       n'est pas utilisÃ© Ã  la suite d'un Undo. Donc Ã§a ne devrait pas
+  //       poser de problÃ¨mes.
   
   Check_layers_limits();
   Redraw_layered_image();
@@ -1001,20 +1001,20 @@
     Free_page_of_a_list(Main_backups);
     Last_backed_up_layers=0;
   }
-  // On remet à jour l'état des infos de la page courante (pour pouvoir les
+  // On remet Ã  jour l'Ã©tat des infos de la page courante (pour pouvoir les
   // retrouver plus tard)
   Upload_infos_page_main(Main_backups->Pages);
-  // On fait faire un redo à la liste des backups de la page principale
+  // On fait faire un redo Ã  la liste des backups de la page principale
   Advance_in_list_of_pages(Main_backups);
 
   Update_buffers(Main_backups->Pages->Width, Main_backups->Pages->Height);
 
   // On extrait ensuite les infos sur la nouvelle page courante
   Download_infos_page_main(Main_backups->Pages);
-  // Note: le backup n'a pas obligatoirement les mêmes dimensions ni la même
+  // Note: le backup n'a pas obligatoirement les mÃªmes dimensions ni la mÃªme
   //       palette que la page courante. Mais en temps normal, le backup
-  //       n'est pas utilisé à la suite d'un Redo. Donc ça ne devrait pas
-  //       poser de problèmes.
+  //       n'est pas utilisÃ© Ã  la suite d'un Redo. Donc Ã§a ne devrait pas
+  //       poser de problÃ¨mes.
   
   Check_layers_limits();
   Redraw_layered_image();
@@ -1024,15 +1024,15 @@
 
 void Free_current_page(void)
 {
-  // On détruit la page courante de la liste principale
+  // On dÃ©truit la page courante de la liste principale
   Free_page_of_a_list(Main_backups);
   
   // On extrait ensuite les infos sur la nouvelle page courante
   Download_infos_page_main(Main_backups->Pages);
-  // Note: le backup n'a pas obligatoirement les mêmes dimensions ni la même
+  // Note: le backup n'a pas obligatoirement les mÃªmes dimensions ni la mÃªme
   //       palette que la page courante. Mais en temps normal, le backup
-  //       n'est pas utilisé à la suite d'une destruction de page. Donc ça ne
-  //       devrait pas poser de problèmes.
+  //       n'est pas utilisÃ© Ã  la suite d'une destruction de page. Donc Ã§a ne
+  //       devrait pas poser de problÃ¨mes.
    
   Update_buffers(Main_backups->Pages->Width, Main_backups->Pages->Height);
   Check_layers_limits();
@@ -1044,8 +1044,8 @@
 {
   T_List_of_pages * temp_list;
 
-  // On commence par mettre à jour dans les descripteurs les infos sur les
-  // pages qu'on s'apprête à échanger, pour qu'on se retrouve pas avec de
+  // On commence par mettre Ã  jour dans les descripteurs les infos sur les
+  // pages qu'on s'apprÃªte Ã  Ã©changer, pour qu'on se retrouve pas avec de
   // vieilles valeurs qui datent de mathuzalem.
   Upload_infos_page_main(Main_backups->Pages);
   Upload_infos_page_spare(Spare_backups->Pages);
@@ -1059,10 +1059,10 @@
   // et backup.
 
   /* SECTION GROS CACA PROUT PROUT */
-  // Auparavant on ruse en mettant déjà à jour les dimensions de la
-  // nouvelle page courante. Si on ne le fait pas, le "Download" va détecter
-  // un changement de dimensions et va bêtement sortir du mode loupe, alors
-  // que lors d'un changement de page, on veut bien conserver l'état du mode
+  // Auparavant on ruse en mettant dÃ©jÃ  Ã  jour les dimensions de la
+  // nouvelle page courante. Si on ne le fait pas, le "Download" va dÃ©tecter
+  // un changement de dimensions et va bÃªtement sortir du mode loupe, alors
+  // que lors d'un changement de page, on veut bien conserver l'Ã©tat du mode
   // loupe du brouillon.
   Main_image_width=Main_backups->Pages->Width;
   Main_image_height=Main_backups->Pages->Height;
@@ -1181,10 +1181,15 @@
 /// Delete a layer from the latest page of a list. Returns 0 on success.
 byte Delete_layer(T_List_of_pages *list, byte layer)
 {
+#if defined(FDOS)
+  int i;
+#else
   T_Page * page;
   int i;
   
   page = list->Pages;
+#endif
+
    
   // Keep the position reasonable
   if (layer >= list->Pages->Nb_layers)
diff -ruN gfx2orig/src/palette.c grafx2/src/palette.c
--- gfx2orig/src/palette.c	2010-03-17 13:11:14.000000000 -0500
+++ grafx2/src/palette.c	2022-03-20 20:19:34.108495316 -0500
@@ -55,9 +55,9 @@
 
 // Nombre de graduations pour une composante dans le mode actuel
 int Color_count=256;
-// Les composantes vont de 0 à (Color_count-1)
+// Les composantes vont de 0 Ã  (Color_count-1)
 int Color_max=255;
-// Le demi-pas est une quantité que l'on ajoute à une composante
+// Le demi-pas est une quantitÃ© que l'on ajoute Ã  une composante
 // avant de faire un arrondi par division.
 int Color_halfstep=0;
 
@@ -73,7 +73,7 @@
   return ((comp+128/RGB_scale)*(RGB_scale-1)/255*255+(RGB_scale&1?1:0))/(RGB_scale-1);
 }
 
-// Définir les unités pour les graduations R G B ou H S V
+// DÃ©finir les unitÃ©s pour les graduations R G B ou H S V
 void Componant_unit(int count)
 {
   Color_count = count;
@@ -139,7 +139,7 @@
 }
 
 void Format_componant(byte value, char *str)
-// Formate une chaine de 4 caractères+\0 : "nnn "
+// Formate une chaine de 4 caractÃ¨res+\0 : "nnn "
 {
   Num2str(value,str,3);
   str[3]=' ';
@@ -147,8 +147,8 @@
 }
 
 void Spread_colors(short start,short end,T_Palette palette)
-// Modifie la palette pour obtenir un dégradé de couleur entre les deux bornes
-// passées en paramètre
+// Modifie la palette pour obtenir un dÃ©gradÃ© de couleur entre les deux bornes
+// passÃ©es en paramÃ¨tre
 {
   short start_red;
   short start_green;
@@ -158,8 +158,8 @@
   short end_blue;
   short index;
 
-  // On vérifie qu'il y ait assez de couleurs entre le début et la fin pour
-  // pouvoir faire un dégradé:
+  // On vÃ©rifie qu'il y ait assez de couleurs entre le dÃ©but et la fin pour
+  // pouvoir faire un dÃ©gradÃ©:
   if ( (start!=end) && (start+1!=end) )
   {
     start_red=palette[start].R;
@@ -236,7 +236,7 @@
   Main_backups->Pages->Transparent_color = 
     conversion_table[Main_backups->Pages->Transparent_color];
 
-  // On calcule les limites à l'écran de l'image
+  // On calcule les limites Ã  l'Ã©cran de l'image
   if (Main_image_height>=Menu_Y_before_window)
     end_y=Menu_Y_before_window;
   else
@@ -268,19 +268,19 @@
       end_y_mag=Main_image_height*Main_magnifier_factor;
   }
 
-  // On doit maintenant faire la traduction à l'écran
+  // On doit maintenant faire la traduction Ã  l'Ã©cran
   Remap_zone_highlevel(0,0,end_x,end_y,conversion_table);
 
   if (Main_magnifier_mode)
   {
     Remap_zone_highlevel(Main_separator_position,0,end_x_mag,end_y_mag,conversion_table);
-    // Il peut encore rester le bas de la barre de split à remapper si la
-    // partie zoomée ne descend pas jusqu'en bas...
+    // Il peut encore rester le bas de la barre de split Ã  remapper si la
+    // partie zoomÃ©e ne descend pas jusqu'en bas...
     Remap_zone_highlevel(Main_separator_position,end_y_mag,
                     (Main_separator_position+(SEPARATOR_WIDTH*Menu_factor_X)),
                     Menu_Y_before_window,conversion_table);
   }
-  // Remappe tous les fonds de fenetre (qui doivent contenir un bout d'écran)
+  // Remappe tous les fonds de fenetre (qui doivent contenir un bout d'Ã©cran)
   Remap_window_backgrounds(conversion_table, 0, Menu_Y_before_window);
 }
 
@@ -303,12 +303,12 @@
   // On fait une copie de la table d'utilisation des couleurs
   memcpy(Utilisation_temporaire, color_usage, sizeof(dword) * 256);
 
-  // On commence à initialiser la table de conversion à un état où elle ne
+  // On commence Ã  initialiser la table de conversion Ã  un Ã©tat oÃ¹ elle ne
   // fera aucune conversion.
   for (pos_1=0;pos_1<=255;pos_1++)
     conversion_table[pos_1]=pos_1;
 
-  // On calcul les dernières couleurs de chaque bloc.
+  // On calcul les derniÃ¨res couleurs de chaque bloc.
   end_1=block_1_start+block_size-1;
   end_2=block_2_start+block_size-1;
 
@@ -326,7 +326,7 @@
       palette[pos_1].G=temp_palette[pos_2].G;
       palette[pos_1].B=temp_palette[pos_2].B;
 
-      // On gère la mise à jour de pos_2
+      // On gÃ¨re la mise Ã  jour de pos_2
       if (pos_2==end_2)
         pos_2=block_1_start;
       else
@@ -336,7 +336,7 @@
   else
   if ((block_2_start<block_1_start) && (end_2>=block_1_start))
   {
-    // Le bloc destination déborde dans le bloc source.
+    // Le bloc destination dÃ©borde dans le bloc source.
 
     for (pos_1=block_2_start,pos_2=block_1_start;pos_1<=end_1;pos_1++)
     {
@@ -348,7 +348,7 @@
       palette[pos_1].G=temp_palette[pos_2].G;
       palette[pos_1].B=temp_palette[pos_2].B;
 
-      // On gère la mise à jour de pos_2
+      // On gÃ¨re la mise Ã  jour de pos_2
       if (pos_2==end_1)
         pos_2=block_2_start;
       else
@@ -366,7 +366,7 @@
       conversion_table[pos_2]=pos_1;
 
       //   On intervertit le nombre d'utilisation des couleurs pour garder une
-      // cohérence lors d'un éventuel "Zap unused".
+      // cohÃ©rence lors d'un Ã©ventuel "Zap unused".
       temp                     =color_usage[pos_1];
       color_usage[pos_1]=color_usage[pos_2];
       color_usage[pos_2]=temp;
@@ -406,7 +406,7 @@
   for (index=0; index<256; index++)
     replace_table[index]=index;
 
-  // On recherche les 4 couleurs les moins utilisées dans l'image pour pouvoir
+  // On recherche les 4 couleurs les moins utilisÃ©es dans l'image pour pouvoir
   // les remplacer par les nouvelles couleurs.
   for (index2=0; index2<4; index2++)
     for (index=255; index>=0; index--)
@@ -417,11 +417,11 @@
         new_colors[index2]=index;
     }
 
-  // On trie maintenant la table dans le sens décroissant.
-  // (Ce n'est pas indispensable, mais ça fera plus joli dans la palette).
+  // On trie maintenant la table dans le sens dÃ©croissant.
+  // (Ce n'est pas indispensable, mais Ã§a fera plus joli dans la palette).
   do
   {
-    color=0; // Booléen qui dit si le tri n'est pas terminé.
+    color=0; // BoolÃ©en qui dit si le tri n'est pas terminÃ©.
     for (index=0; index<3; index++)
     {
       if (new_colors[index]>new_colors[index+1])
@@ -435,7 +435,7 @@
   } while (color);
 
   //   On sauvegarde dans rgb les teintes qu'on va remplacer et on met les
-  // couleurs du menu par défaut
+  // couleurs du menu par dÃ©faut
   for (index=0; index<4; index++)
   {
     color=new_colors[index];
@@ -447,7 +447,7 @@
     Main_palette[color].B=Config.Fav_menu_colors[index].B;
   }
 
-  //   Maintenant qu'on a placé notre nouvelle palette, on va chercher quelles
+  //   Maintenant qu'on a placÃ© notre nouvelle palette, on va chercher quelles
   // sont les couleurs qui peuvent remplacer les anciennes
   Hide_cursor();
   for (index=0; index<4; index++)
@@ -461,7 +461,7 @@
   }
   else
   {
-    // On fait un changement des couleurs visibles à l'écran et dans l'image
+    // On fait un changement des couleurs visibles Ã  l'Ã©cran et dans l'image
     Remap_image_highlevel(replace_table);
   }
   Display_cursor();
@@ -482,20 +482,20 @@
   dword Utilisation;
   dword Meilleure_utilisation;
 
-  //   On commence par initialiser la table de conversion dans un état où
-  // aucune conversion ne sera effectuée.
+  //   On commence par initialiser la table de conversion dans un Ã©tat oÃ¹
+  // aucune conversion ne sera effectuÃ©e.
   for (color_1=0; color_1<=255; color_1++)
     conversion_table[color_1]=color_1;
 
-  //   Si on ne connait pas encore le nombre de couleurs utilisées, on le
-  // calcule! (!!! La fonction appelée Efface puis Affiche le curseur !!!)
+  //   Si on ne connait pas encore le nombre de couleurs utilisÃ©es, on le
+  // calcule! (!!! La fonction appelÃ©e Efface puis Affiche le curseur !!!)
   if ((*used_colors)<0)
     Update_color_count(used_colors,color_usage);
 
   Hide_cursor();
 
-  //   On tasse la palette vers le début parce qu'elle doit ressembler à
-  // du Gruyère (et comme Papouille il aime pas le fromage...)
+  //   On tasse la palette vers le dÃ©but parce qu'elle doit ressembler Ã 
+  // du GruyÃ¨re (et comme Papouille il aime pas le fromage...)
 
   // Pour cela, on va scruter la couleur color_1 et se servir de l'indice
   // color_2 comme position de destination.
@@ -508,19 +508,19 @@
       palette[color_2].G=palette[color_1].G;
       palette[color_2].B=palette[color_1].B;
 
-      // Ensuite, on met à jour le tableau d'occupation des couleurs.
+      // Ensuite, on met Ã  jour le tableau d'occupation des couleurs.
       color_usage[color_2]=color_usage[color_1];
 
       // On va maintenant s'occuper de la table de conversion:
       conversion_table[color_1]=color_2;
 
-      // Maintenant, la place désignée par color_2 est occupée, alors on
-      // doit passer à un indice de destination suivant.
+      // Maintenant, la place dÃ©signÃ©e par color_2 est occupÃ©e, alors on
+      // doit passer Ã  un indice de destination suivant.
       color_2++;
     }
   }
 
-  // On met toutes les couleurs inutilisées en noir
+  // On met toutes les couleurs inutilisÃ©es en noir
   for (;color_2<256;color_2++)
   {
     palette[color_2].R=0;
@@ -529,13 +529,13 @@
     color_usage[color_2]=0;
   }
 
-  //   Maintenant qu'on a une palette clean, on va boucler en réduisant
-  // le nombre de couleurs jusqu'à ce qu'on atteigne le nombre désiré.
+  //   Maintenant qu'on a une palette clean, on va boucler en rÃ©duisant
+  // le nombre de couleurs jusqu'Ã  ce qu'on atteigne le nombre dÃ©sirÃ©.
   while ((*used_colors)>nb_colors_asked)
   {
     //   Il s'agit de trouver les 2 couleurs qui se ressemblent le plus
-    // parmis celles qui sont utilisées (bien sûr) et de les remplacer par
-    // une seule couleur qui est la moyenne pondérée de ces 2 couleurs
+    // parmis celles qui sont utilisÃ©es (bien sÃ»r) et de les remplacer par
+    // une seule couleur qui est la moyenne pondÃ©rÃ©e de ces 2 couleurs
     // en fonction de leur utilisation dans l'image.
 
     best_difference =0x7FFF;
@@ -562,14 +562,14 @@
           }
         }
 
-    //   Maintenant qu'on les a trouvées, on va pouvoir mettre à jour nos
-    // données pour que le remplacement se fasse sans encombres.
+    //   Maintenant qu'on les a trouvÃ©es, on va pouvoir mettre Ã  jour nos
+    // donnÃ©es pour que le remplacement se fasse sans encombres.
 
     // En somme, on va remplacer best_color_2 par best_color_1,
     // mais attention, on ne remplace pas best_color_1 par
     // best_color_2 !
 
-    // On met à jour la palette.
+    // On met Ã  jour la palette.
     palette[best_color_1].R=Round_div((color_usage[best_color_1]*palette[best_color_1].R)+
                                              (color_usage[best_color_2]*palette[best_color_2].R),
                                              Meilleure_utilisation);
@@ -580,78 +580,78 @@
                                              (color_usage[best_color_2]*palette[best_color_2].B),
                                              Meilleure_utilisation);
 
-    // On met à jour la table d'utilisation.
+    // On met Ã  jour la table d'utilisation.
     color_usage[best_color_1]+=color_usage[best_color_2];
     color_usage[best_color_2]=0;
 
-    // On met à jour la table de conversion.
+    // On met Ã  jour la table de conversion.
     for (color_1=0;color_1<=255;color_1++)
     {
       if (conversion_table[color_1]==best_color_2)
       {
-        //   La color_1 avait déjà prévue de se faire remplacer par la
-        // couleur que l'on veut maintenant éliminer. On va maintenant
-        // demander à ce que la color_1 se fasse remplacer par la
+        //   La color_1 avait dÃ©jÃ  prÃ©vue de se faire remplacer par la
+        // couleur que l'on veut maintenant Ã©liminer. On va maintenant
+        // demander Ã  ce que la color_1 se fasse remplacer par la
         // best_color_1.
         conversion_table[color_1]=best_color_1;
       }
     }
 
     //   Bon, maintenant que l'on a fait bouger nos petites choses concernants
-    // la couleur à éliminer, on va s'occuper de faire bouger les couleurs
-    // situées après la couleur à éliminer pour qu'elles se déplaçent d'une
-    // couleur en arrière.
+    // la couleur Ã  Ã©liminer, on va s'occuper de faire bouger les couleurs
+    // situÃ©es aprÃ¨s la couleur Ã  Ã©liminer pour qu'elles se dÃ©plaÃ§ent d'une
+    // couleur en arriÃ¨re.
     for (color_1=0;color_1<=255;color_1++)
     {
-      //   Commençons par nous occuper des tables d'utilisation et de la
+      //   CommenÃ§ons par nous occuper des tables d'utilisation et de la
       // palette.
 
       if (color_1>best_color_2)
       {
-        // La color_1 va scroller en arrière.
+        // La color_1 va scroller en arriÃ¨re.
 
-        //   Donc on transfère son utilisation dans l'utilisation de la
-        // couleur qui la précède.
+        //   Donc on transfÃ¨re son utilisation dans l'utilisation de la
+        // couleur qui la prÃ©cÃ¨de.
         color_usage[color_1-1]=color_usage[color_1];
 
-        //   Et on transfère ses teintes dans les teintes de la couleur qui
-        // la précède.
+        //   Et on transfÃ¨re ses teintes dans les teintes de la couleur qui
+        // la prÃ©cÃ¨de.
         palette[color_1-1].R=palette[color_1].R;
         palette[color_1-1].G=palette[color_1].G;
         palette[color_1-1].B=palette[color_1].B;
       }
 
-      //   Une fois la palette et la table d'utilisation gérées, on peut
+      //   Une fois la palette et la table d'utilisation gÃ©rÃ©es, on peut
       // s'occuper de notre table de conversion.
       if (conversion_table[color_1]>best_color_2)
         //   La color_1 avait l'intention de se faire remplacer par une
-        // couleur que l'on va (ou que l'on a déjà) bouger en arrière.
+        // couleur que l'on va (ou que l'on a dÃ©jÃ ) bouger en arriÃ¨re.
         conversion_table[color_1]--;
     }
 
-    //   On vient d'éjecter une couleur, donc on peut mettre à jour le nombre
-    // de couleurs utilisées.
+    //   On vient d'Ã©jecter une couleur, donc on peut mettre Ã  jour le nombre
+    // de couleurs utilisÃ©es.
     (*used_colors)--;
 
     // A la fin, on doit passer (dans la palette) les teintes du dernier
-    // élément de notre ensemble en noir.
+    // Ã©lÃ©ment de notre ensemble en noir.
     palette[*used_colors].R=0;
     palette[*used_colors].G=0;
     palette[*used_colors].B=0;
 
-    // Au passage, on va s'assurer que l'on a pas oublié de la mettre à une
+    // Au passage, on va s'assurer que l'on a pas oubliÃ© de la mettre Ã  une
     // utilisation nulle.
     color_usage[*used_colors]=0;
 
-    // Après avoir éjecté une couleur, on le fait savoir à l'utilisateur par
-    // l'intermédiaire du compteur de nombre utilisées.
+    // AprÃ¨s avoir Ã©jectÃ© une couleur, on le fait savoir Ã  l'utilisateur par
+    // l'intermÃ©diaire du compteur de nombre utilisÃ©es.
     Num2str(*used_colors,str,3);
     Print_in_window(186,23,str,MC_Black,MC_Light);
   }
 
-  //   Maintenant, tous ces calculs doivent êtres pris en compte dans la
-  // palette, l'image et à l'écran.
-  Remap_image_highlevel(conversion_table); // Et voila pour l'image et l'écran
+  //   Maintenant, tous ces calculs doivent Ãªtres pris en compte dans la
+  // palette, l'image et Ã  l'Ã©cran.
+  Remap_image_highlevel(conversion_table); // Et voila pour l'image et l'Ã©cran
   Display_cursor();
 }
 
@@ -679,9 +679,9 @@
 
   if (block_is_selected)
   {
-    Set_palette_slider(red_slider,Color_max*2+1,Color_max,"±  0",176);
-    Set_palette_slider(green_slider,Color_max*2+1,Color_max,"±  0",203);
-    Set_palette_slider(blue_slider,Color_max*2+1,Color_max,"±  0",230);
+    Set_palette_slider(red_slider,Color_max*2+1,Color_max,"Â±  0",176);
+    Set_palette_slider(green_slider,Color_max*2+1,Color_max,"Â±  0",203);
+    Set_palette_slider(blue_slider,Color_max*2+1,Color_max,"Â±  0",230);
   }
   else
   {
@@ -713,21 +713,21 @@
   char str[5];
 
   Hide_cursor();
-  // Réaffichage des jauges:
+  // RÃ©affichage des jauges:
   if (start!=end)
   {
-    // Dans le cas d'un bloc, tout à 0.
+    // Dans le cas d'un bloc, tout Ã  0.
     red_slider->Position   =Color_max;
     Window_draw_slider(red_slider);
-    Print_counter(176,172,"±  0",MC_Black,MC_Light);
+    Print_counter(176,172,"Â±  0",MC_Black,MC_Light);
 
     green_slider->Position   =Color_max;
     Window_draw_slider(green_slider);
-    Print_counter(203,172,"±  0",MC_Black,MC_Light);
+    Print_counter(203,172,"Â±  0",MC_Black,MC_Light);
 
     blue_slider->Position   =Color_max;
     Window_draw_slider(blue_slider);
-    Print_counter(230,172,"±  0",MC_Black,MC_Light);
+    Print_counter(230,172,"Â±  0",MC_Black,MC_Light);
   }
   else
   {
@@ -762,9 +762,9 @@
 void Button_Palette(void)
 {
   static short reduce_colors_number = 256;
-  short temp_color; // Variable pouvant reservir pour différents calculs intermédiaires
+  short temp_color; // Variable pouvant reservir pour diffÃ©rents calculs intermÃ©diaires
   dword temp;
-  byte  color,click; // Variables pouvant reservir pour différents calculs intermédiaires
+  byte  color,click; // Variables pouvant reservir pour diffÃ©rents calculs intermÃ©diaires
   short clicked_button;
   word  old_mouse_x;
   word  old_mouse_y;
@@ -775,7 +775,7 @@
   byte  last_color;
   char  str[10];
   word  i;
-  T_Normal_button   * button_used;
+
   T_Scroller_button * red_slider;
   T_Scroller_button * green_slider;
   T_Scroller_button * blue_slider;
@@ -889,7 +889,7 @@
   Window_set_normal_button( 62,168,51,14,"Cancel",0,1,KEY_ESC);  // 13
   Window_set_normal_button(117,168,51,14,"OK"    ,0,1,SDLK_RETURN);  // 14
 
-  button_used = Window_set_normal_button(132,20,83,14,"Used: ???",4,1,SDLK_d);// 15
+  Window_set_normal_button(132,20,83,14,"Used: ???",4,1,SDLK_d);// 15
   Window_set_normal_button(132,37,83,14,"Zap unused",0,1,SDLK_DELETE);//16
 
   Window_set_repeatable_button(266, 74,12,11,"+",0,1,SDLK_KP_PLUS);       // 17
@@ -902,7 +902,7 @@
   Window_set_normal_button(96,32,29,14,"HSL"    ,1,1,SDLK_h);   // 22
   Window_set_normal_button(96,47,29,14,"Srt"    ,1,1,SDLK_s);   // 23
 
-  // Dessin des petits effets spéciaux pour les boutons [+] et [-]
+  // Dessin des petits effets spÃ©ciaux pour les boutons [+] et [-]
   Draw_thingumajig(263, 74,MC_White,-1);
   Draw_thingumajig(280, 74,MC_White,+1);
   Draw_thingumajig(263,165,MC_Dark,-1);
@@ -934,7 +934,7 @@
     {
       case  0 : // Nulle part
         break;
-      case -1 : // Hors de la fenêtre
+      case -1 : // Hors de la fenÃªtre
       case  1 : // palette
         if ( (Mouse_X!=old_mouse_x) || (Mouse_Y!=old_mouse_y) || (Mouse_K!=old_mouse_k) )
         {
@@ -961,13 +961,13 @@
               if ( (Fore_color!=temp_color) || (block_start!=block_end) )
               {
                 // La couleur en question est nouvelle ou elle annule un
-                // ancien bloc. Il faut donc sélectionner cette couleur comme
+                // ancien bloc. Il faut donc sÃ©lectionner cette couleur comme
                 // unique couleur choisie.
 
                 Fore_color=first_color=last_color=block_start=block_end=temp_color;
                 Tag_color_range(block_start,block_end);
 
-                // Affichage du n° de la couleur sélectionnée
+                // Affichage du nÂ° de la couleur sÃ©lectionnÃ©e
                 Block(Window_pos_X+(Menu_factor_X*237),Window_pos_Y+(Menu_factor_Y*58),Menu_factor_X*56,Menu_factor_Y*7,MC_Light);
                 Num2str(Fore_color,str,3);
                 Print_in_window(237,58,str,MC_Black,MC_Light);
@@ -992,16 +992,16 @@
               // On maintient le click, on va donc tester si le curseur bouge
               if (temp_color!=last_color)
               {
-                // On commence par ordonner la 1ère et dernière couleur du bloc
+                // On commence par ordonner la 1Ã¨re et derniÃ¨re couleur du bloc
                 if (first_color<temp_color)
                 {
                   block_start=first_color;
                   block_end=temp_color;
 
-                  // Affichage du n° de la couleur sélectionnée
+                  // Affichage du nÂ° de la couleur sÃ©lectionnÃ©e
                   Num2str(block_start,str  ,3);
                   Num2str(block_end  ,str+4,3);
-                  str[3]=26; // Flèche vers la droite
+                  str[3]=26; // FlÃ¨che vers la droite
                   Print_in_window(237,58,str,MC_Black,MC_Light);
                   {
                     int pixel_count = 0;
@@ -1014,7 +1014,7 @@
                   // Affichage des jauges
                   Display_sliders(red_slider,green_slider,blue_slider,1,NULL);
 
-                  // Affichage dans le block de visu du bloc (dégradé) en cours
+                  // Affichage dans le block de visu du bloc (dÃ©gradÃ©) en cours
                   Display_grad_block_in_window(264,93,block_start,block_end);
                 }
                 else if (first_color>temp_color)
@@ -1022,10 +1022,10 @@
                   block_start=temp_color;
                   block_end=first_color;
 
-                  // Affichage du n° de la couleur sélectionnée
+                  // Affichage du nÂ° de la couleur sÃ©lectionnÃ©e
                   Num2str(block_start,str  ,3);
                   Num2str(block_end  ,str+4,3);
-                  str[3]=26; // Flèche vers la droite
+                  str[3]=26; // FlÃ¨che vers la droite
                   Print_in_window(237,58,str,MC_Black,MC_Light);
                   {
                     int pixel_count = 0;
@@ -1038,7 +1038,7 @@
                   // Affichage des jauges
                   Display_sliders(red_slider,green_slider,blue_slider,1,NULL);
 
-                  // Affichage dans le block de visu du bloc (dégradé) en cours
+                  // Affichage dans le block de visu du bloc (dÃ©gradÃ©) en cours
                   Display_grad_block_in_window(264,93,block_start,block_end);
                 }
                 else
@@ -1046,7 +1046,7 @@
                   block_start=block_end=first_color;
                   Block(Window_pos_X+(Menu_factor_X*176),Window_pos_Y+(Menu_factor_Y*172),Menu_factor_X*84,Menu_factor_Y*7,MC_Light);
 
-                  // Affichage du n° de la couleur sélectionnée
+                  // Affichage du nÂ° de la couleur sÃ©lectionnÃ©e
                   Block(Window_pos_X+(Menu_factor_X*261),Window_pos_Y+(Menu_factor_Y*58),Menu_factor_X*32,Menu_factor_Y*7,MC_Light);
                   Num2str(Fore_color,str,3);
                   Print_in_window(237,58,str,MC_Black,MC_Light);
@@ -1115,7 +1115,7 @@
 
           if (red_slider->Position>Color_max)
           {
-            // Jauge dans les négatifs:
+            // Jauge dans les nÃ©gatifs:
             Num2str(-(Color_max-red_slider->Position),str,4);
             str[0]='-';
           }
@@ -1128,7 +1128,7 @@
           else
           {
             // Jauge nulle:
-            strcpy(str,"±  0");
+            strcpy(str,"Â±  0");
           }
           Print_counter(176,172,str,MC_Black,MC_Light);
 
@@ -1183,7 +1183,7 @@
 
           if (green_slider->Position>Color_max)
           {
-            // Jauge dans les négatifs:
+            // Jauge dans les nÃ©gatifs:
             Num2str(-(Color_max-green_slider->Position),str,4);
             str[0]='-';
           }
@@ -1196,7 +1196,7 @@
           else
           {
             // Jauge nulle:
-            strcpy(str,"±  0");
+            strcpy(str,"Â±  0");
           }
           Print_counter(203,172,str,MC_Black,MC_Light);
         }
@@ -1251,7 +1251,7 @@
 
           if (blue_slider->Position>Color_max)
           {
-            // Jauge dans les négatifs:
+            // Jauge dans les nÃ©gatifs:
             Num2str(-(Color_max-blue_slider->Position),str,4);
             str[0]='-';
           }
@@ -1264,7 +1264,7 @@
           else
           {
             // Jauge nulle:
-            strcpy(str,"±  0");
+            strcpy(str,"Â±  0");
           }
           Print_counter(230,172,str,MC_Black,MC_Light);
         }
@@ -1281,7 +1281,7 @@
         memcpy(temp_palette,Gfx->Default_palette,sizeof(T_Palette));
         Set_palette(Gfx->Default_palette);
         Draw_all_palette_sliders(red_slider,green_slider,blue_slider,working_palette,block_start,block_end);
-        // On prépare la "modifiabilité" des nouvelles couleurs
+        // On prÃ©pare la "modifiabilitÃ©" des nouvelles couleurs
         memcpy(temp_palette,working_palette,sizeof(T_Palette));
 
         need_to_remap=1;
@@ -1299,7 +1299,7 @@
           Set_blue (i,temp_color,working_palette);
         }
         Draw_all_palette_sliders(red_slider,green_slider,blue_slider,working_palette,block_start,block_end);
-        // On prépare la "modifiabilité" des nouvelles couleurs
+        // On prÃ©pare la "modifiabilitÃ©" des nouvelles couleurs
         Set_palette(working_palette);
         memcpy(temp_palette,working_palette,sizeof(T_Palette));
 
@@ -1316,7 +1316,7 @@
           memcpy(backup_palette,working_palette,sizeof(T_Palette));
 
           // On calcule le nombre de couleurs a swapper sans risquer de sortir
-          // de la palette (La var. first_color est utilisée pour économiser 1 var; c'est tout)
+          // de la palette (La var. first_color est utilisÃ©e pour Ã©conomiser 1 var; c'est tout)
           first_color=(temp_color+block_end-block_start<=255)?block_end+1-block_start:256-temp_color;
 
           if (clicked_button==8) // On ne fait de backup de l'image que si on
@@ -1331,17 +1331,17 @@
 
           memcpy(temp_palette,working_palette,sizeof(T_Palette));
 
-          // On déplace le bloc vers les modifs:
+          // On dÃ©place le bloc vers les modifs:
           last_color=block_end=temp_color+first_color-1;
           Fore_color=first_color=block_start=temp_color;
-          // On raffiche le n° des bornes du bloc:
+          // On raffiche le nÂ° des bornes du bloc:
           if (block_start!=block_end)
           {
             // Cas d'un bloc multi-couleur
             Num2str(block_start,str  ,3);
             Num2str(block_end  ,str+4,3);
-            str[3]=26; // Flèche vers la droite
-            // Affichage dans le block de visu du bloc (dégradé) en cours
+            str[3]=26; // FlÃ¨che vers la droite
+            // Affichage dans le block de visu du bloc (dÃ©gradÃ©) en cours
             Display_grad_block_in_window(264,93,block_start,block_end);
           }
           else
@@ -1383,17 +1383,17 @@
                  ((temp_color+block_end-block_start<=255)?block_end+1-block_start:256-temp_color)*3);
           memcpy(temp_palette,working_palette,sizeof(T_Palette));
           Set_palette(working_palette);
-          // On déplace le bloc vers les modifs:
+          // On dÃ©place le bloc vers les modifs:
           last_color=block_end=((temp_color+block_end-block_start<=255)?(temp_color+block_end-block_start):255);
           Fore_color=first_color=block_start=temp_color;
-          // On raffiche le n° des bornes du bloc:
+          // On raffiche le nÂ° des bornes du bloc:
           if (block_start!=block_end)
           {
             // Cas d'un bloc multi-couleur
             Num2str(block_start,str  ,3);
             Num2str(block_end  ,str+4,3);
-            str[3]=26; // Flèche vers la droite
-            // Affichage dans le block de visu du bloc (dégradé) en cours
+            str[3]=26; // FlÃ¨che vers la droite
+            // Affichage dans le block de visu du bloc (dÃ©gradÃ©) en cours
             Display_grad_block_in_window(264,93,block_start,block_end);
           }
           else
@@ -1437,7 +1437,7 @@
         }
 
         Draw_all_palette_sliders(red_slider,green_slider,blue_slider,working_palette,block_start,block_end);
-        // On prépare la "modifiabilité" des nouvelles couleurs
+        // On prÃ©pare la "modifiabilitÃ©" des nouvelles couleurs
 
         Set_palette(working_palette);
 
@@ -1499,7 +1499,7 @@
                 memcpy(Main_palette, temp_palette, sizeof(T_Palette));
             }
 
-            Set_palette(working_palette); // On définit la nouvelle palette
+            Set_palette(working_palette); // On dÃ©finit la nouvelle palette
             Draw_all_palette_sliders(red_slider, green_slider, blue_slider,
                     working_palette, block_start, block_end);
             memcpy(temp_palette, working_palette, sizeof(T_Palette));
@@ -1613,7 +1613,7 @@
           // -- red --
           if (red_slider->Position>Color_max)
           {
-            // Jauge dans les négatifs:
+            // Jauge dans les nÃ©gatifs:
             Num2str(-(Color_max-red_slider->Position),str,4);
             str[0]='-';
           }
@@ -1626,7 +1626,7 @@
           else
           {
             // Jauge nulle:
-            strcpy(str,"±  0");
+            strcpy(str,"Â±  0");
           }
           Print_counter(176,172,str,MC_Black,MC_Light);
 
@@ -1634,7 +1634,7 @@
           // -- green --
           if (green_slider->Position>Color_max)
           {
-            // Jauge dans les négatifs:
+            // Jauge dans les nÃ©gatifs:
             Num2str(-(Color_max-green_slider->Position),str,4);
             str[0]='-';
           }
@@ -1647,7 +1647,7 @@
           else
           {
             // Jauge nulle:
-            strcpy(str,"±  0");
+            strcpy(str,"Â±  0");
           }
           Print_counter(203,172,str,MC_Black,MC_Light);
 
@@ -1655,7 +1655,7 @@
           // -- blue --
           if (blue_slider->Position>Color_max)
           {
-            // Jauge dans les négatifs:
+            // Jauge dans les nÃ©gatifs:
             Num2str(-(Color_max-blue_slider->Position),str,4);
             str[0]='-';
           }
@@ -1668,7 +1668,7 @@
           else
           {
             // Jauge nulle:
-            strcpy(str,"±  0");
+            strcpy(str,"Â±  0");
           }
           Print_counter(230,172,str,MC_Black,MC_Light);
         }
@@ -1738,7 +1738,7 @@
           // -- red --
           if (red_slider->Position>Color_max)
           {
-            // Jauge dans les négatifs:
+            // Jauge dans les nÃ©gatifs:
             Num2str(-(Color_max-red_slider->Position),str,4);
             str[0]='-';
           }
@@ -1751,7 +1751,7 @@
           else
           {
             // Jauge nulle:
-            strcpy(str,"±  0");
+            strcpy(str,"Â±  0");
           }
           Print_counter(176,172,str,MC_Black,MC_Light);
 
@@ -1759,7 +1759,7 @@
           // -- green --
           if (green_slider->Position>Color_max)
           {
-            // Jauge dans les négatifs:
+            // Jauge dans les nÃ©gatifs:
             Num2str(-(Color_max-green_slider->Position),str,4);
             str[0]='-';
           }
@@ -1772,7 +1772,7 @@
           else
           {
             // Jauge nulle:
-            strcpy(str,"±  0");
+            strcpy(str,"Â±  0");
           }
           Print_counter(203,172,str,MC_Black,MC_Light);
 
@@ -1780,7 +1780,7 @@
           // -- blue --
           if (blue_slider->Position>Color_max)
           {
-            // Jauge dans les négatifs:
+            // Jauge dans les nÃ©gatifs:
             Num2str(-(Color_max-blue_slider->Position),str,4);
             str[0]='-';
           }
@@ -1793,7 +1793,7 @@
           else
           {
             // Jauge nulle:
-            strcpy(str,"±  0");
+            strcpy(str,"Â±  0");
           }
           Print_counter(230,172,str,MC_Black,MC_Light);
         }
@@ -1816,7 +1816,7 @@
         }
         Draw_all_palette_sliders(red_slider,green_slider,blue_slider,working_palette,block_start,block_end);
         Set_palette(working_palette);
-        // On prépare la "modifiabilité" des nouvelles couleurs
+        // On prÃ©pare la "modifiabilitÃ©" des nouvelles couleurs
         memcpy(temp_palette,working_palette,sizeof(T_Palette));
 
         need_to_remap=1;
@@ -1865,7 +1865,7 @@
           Display_cursor();
           End_of_modification();
         }
-        // On prépare la "modifiabilité" des nouvelles couleurs
+        // On prÃ©pare la "modifiabilitÃ©" des nouvelles couleurs
         Set_palette(working_palette);
         memcpy(temp_palette,working_palette,sizeof(T_Palette));
 
@@ -1911,7 +1911,7 @@
       case 23 : // Sort palette
       {
         byte h = 0, l = 0, s=0;
-        byte oh=0,ol=0,os=0; // Valeur pour la couleur précédente
+        byte oh=0,ol=0,os=0; // Valeur pour la couleur prÃ©cÃ©dente
         int swap=1;
         byte remap_table[256];
         byte inverted_table[256];
@@ -1999,8 +1999,8 @@
         for (i=0;i<256;i++)
           inverted_table[remap_table[i]]=i;
         Remap_image_highlevel(inverted_table);
-        // Maintenant, tous ces calculs doivent êtres pris en compte dans la
-        // palette, l'image et à l'écran.
+        // Maintenant, tous ces calculs doivent Ãªtres pris en compte dans la
+        // palette, l'image et Ã  l'Ã©cran.
         Set_palette(working_palette);
         
         End_of_modification();
@@ -2014,7 +2014,7 @@
     {
       switch (Key)
       {
-        case SDLK_LEFTBRACKET : // Décaler Forecolor vers la gauche
+        case SDLK_LEFTBRACKET : // DÃ©caler Forecolor vers la gauche
           if (block_start==block_end)
           {
             Fore_color--;
@@ -2025,7 +2025,7 @@
             Draw_all_palette_sliders(red_slider,green_slider,blue_slider,working_palette,block_start,block_end);
             Hide_cursor();
             Tag_color_range(block_start,block_end);
-            // Affichage du n° de la couleur sélectionnée
+            // Affichage du nÂ° de la couleur sÃ©lectionnÃ©e
             Num2str(Fore_color,str,3);
             Print_in_window(237,58,str,MC_Black,MC_Light);
             // Affichage dans le block de visu de la couleur en cours
@@ -2036,7 +2036,7 @@
           Key=0;
           break;
 
-        case SDLK_RIGHTBRACKET : // Décaler Forecolor vers la droite
+        case SDLK_RIGHTBRACKET : // DÃ©caler Forecolor vers la droite
           if (block_start==block_end)
           {
             Fore_color++;
@@ -2047,7 +2047,7 @@
             Draw_all_palette_sliders(red_slider,green_slider,blue_slider,working_palette,block_start,block_end);
             Hide_cursor();
             Tag_color_range(block_start,block_end);
-            // Affichage du n° de la couleur sélectionnée
+            // Affichage du nÂ° de la couleur sÃ©lectionnÃ©e
             Num2str(Fore_color,str,3);
             Print_in_window(237,58,str,MC_Black,MC_Light);
             // Affichage dans le block de visu de la couleur en cours
@@ -2074,7 +2074,7 @@
           Key=0;
           break;
 
-        case SDLK_BACKSPACE : // Remise des couleurs du menu à l'état normal en essayant
+        case SDLK_BACKSPACE : // Remise des couleurs du menu Ã  l'Ã©tat normal en essayant
                       // de ne pas trop modifier l'image.
           if (!image_is_backed_up)
           {
@@ -2100,7 +2100,7 @@
           Key=0;
           break;
 
-        case SDLK_BACKQUOTE : // Récupération d'une couleur derrière le menu
+        case SDLK_BACKQUOTE : // RÃ©cupÃ©ration d'une couleur derriÃ¨re le menu
         case SDLK_COMMA :
           Get_color_behind_window(&color,&click);
           if (click)
@@ -2124,7 +2124,7 @@
               Fore_color=first_color=last_color=block_start=block_end=color;
               Tag_color_range(block_start,block_end);
 
-              // Affichage du n° de la couleur sélectionnée
+              // Affichage du nÂ° de la couleur sÃ©lectionnÃ©e
               Block(Window_pos_X+(Menu_factor_X*261),Window_pos_Y+(Menu_factor_Y*58),Menu_factor_X*32,Menu_factor_Y*7,MC_Light);
               Num2str(Fore_color,str,3);
               Print_in_window(237,58,str,MC_Black,MC_Light);
@@ -2190,7 +2190,7 @@
 
   Compute_optimal_menu_colors(Main_palette);
 
-  // La variable employée ici n'a pas vraiment de rapport avec son nom...
+  // La variable employÃ©e ici n'a pas vraiment de rapport avec son nom...
   need_to_remap=(Window_pos_Y+(Window_height*Menu_factor_Y)<Menu_Y_before_window);
 
   Close_window();
@@ -2198,9 +2198,9 @@
 
   Reposition_palette();
 
-  //   On affiche les "ForeBack" car le menu n'est raffiché que si la fenêtre
-  // empiétait sur le menu. Mais si les couleurs on été modifiées, il faut
-  // rafficher tout le menu remappé.
+  //   On affiche les "ForeBack" car le menu n'est raffichÃ© que si la fenÃªtre
+  // empiÃ©tait sur le menu. Mais si les couleurs on Ã©tÃ© modifiÃ©es, il faut
+  // rafficher tout le menu remappÃ©.
   if (need_to_remap)
     Display_menu();
 
@@ -2267,7 +2267,7 @@
   Print_in_window(51,108,"Vertical",MC_Dark,MC_Light);
 
   Window_set_normal_button(152,88,18,14,"x2"                  , 1,1,SDLK_x); // 9
-  Window_set_normal_button(172,88,18,14,"÷2"                  , 0,1,SDLK_w); // 10
+  Window_set_normal_button(172,88,18,14,"\xF7""2"                  , 0,1,SDLK_w); // 10  ( \xF7 is divide)
   
   Update_window_area(0,0,200,146);
 
diff -ruN gfx2orig/src/pxdouble.c grafx2/src/pxdouble.c
--- gfx2orig/src/pxdouble.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/pxdouble.c	2022-03-20 20:19:34.108495316 -0500
@@ -39,7 +39,7 @@
 #endif
 
 void Pixel_double (word x,word y,byte color)
-/* Affiche un pixel de la color aux coords x;y à l'écran */
+/* Affiche un pixel de la color aux coords x;y Ã  l'Ã©cran */
 {
   *(Screen_pixels + x * ZOOMX + y*ZOOMY * VIDEO_LINE_WIDTH)=color;
   *(Screen_pixels + x * ZOOMX + y*ZOOMY * VIDEO_LINE_WIDTH + 1)=color;
@@ -48,13 +48,13 @@
 }
 
 byte Read_pixel_double (word x,word y)
-/* On retourne la couleur du pixel aux coords données */
+/* On retourne la couleur du pixel aux coords donnÃ©es */
 {
   return *( Screen_pixels + y * ZOOMY * VIDEO_LINE_WIDTH + x * ZOOMX);
 }
 
 void Block_double (word start_x,word start_y,word width,word height,byte color)
-/* On affiche un rectangle de la couleur donnée */
+/* On affiche un rectangle de la couleur donnÃ©e */
 {
   SDL_Rect rectangle;
   rectangle.x=start_x*ZOOMX;
@@ -65,10 +65,10 @@
 }
 
 void Display_part_of_screen_double (word width,word height,word image_width)
-/* Afficher une partie de l'image telle quelle sur l'écran */
+/* Afficher une partie de l'image telle quelle sur l'Ã©cran */
 {
-  byte* dest=Screen_pixels; //On va se mettre en 0,0 dans l'écran (dest)
-  byte* src=Main_offset_Y*image_width+Main_offset_X+Main_screen; //Coords de départ ds la source (src)
+  byte* dest=Screen_pixels; //On va se mettre en 0,0 dans l'Ã©cran (dest)
+  byte* src=Main_offset_Y*image_width+Main_offset_X+Main_screen; //Coords de dÃ©part ds la source (src)
   int y;
   int dy;
 
@@ -85,7 +85,7 @@
     // On double la ligne qu'on vient de copier
     memcpy(dest-width*ZOOMX+VIDEO_LINE_WIDTH,dest-width*ZOOMX,width*ZOOMX);
     
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     src+=image_width-width;
     dest+=VIDEO_LINE_WIDTH*ZOOMY - width*ZOOMX;
   }
@@ -93,10 +93,10 @@
 }
 
 void Pixel_preview_normal_double (word x,word y,byte color)
-/* Affichage d'un pixel dans l'écran, par rapport au décalage de l'image 
- * dans l'écran, en mode normal (pas en mode loupe)
- * Note: si on modifie cette procédure, il faudra penser à faire également 
- * la modif dans la procédure Pixel_Preview_Loupe_SDL. */
+/* Affichage d'un pixel dans l'Ã©cran, par rapport au dÃ©calage de l'image 
+ * dans l'Ã©cran, en mode normal (pas en mode loupe)
+ * Note: si on modifie cette procÃ©dure, il faudra penser Ã  faire Ã©galement 
+ * la modif dans la procÃ©dure Pixel_Preview_Loupe_SDL. */
 {
 //  if(x-Main_offset_X >= 0 && y - Main_offset_Y >= 0)
   Pixel_double(x-Main_offset_X,y-Main_offset_Y,color);
@@ -104,10 +104,10 @@
 
 void Pixel_preview_magnifier_double  (word x,word y,byte color)
 {
-  // Affiche le pixel dans la partie non zoomée
+  // Affiche le pixel dans la partie non zoomÃ©e
   Pixel_double(x-Main_offset_X,y-Main_offset_Y,color);
   
-  // Regarde si on doit aussi l'afficher dans la partie zoomée
+  // Regarde si on doit aussi l'afficher dans la partie zoomÃ©e
   if (y >= Limit_top_zoom && y <= Limit_visible_bottom_zoom
           && x >= Limit_left_zoom && x <= Limit_visible_right_zoom)
   {
@@ -117,7 +117,7 @@
 
     if (Menu_Y - y_zoom < Main_magnifier_factor)
       // On ne doit dessiner qu'un morceau du pixel
-      // sinon on dépasse sur le menu
+      // sinon on dÃ©passe sur le menu
       height = Menu_Y - y_zoom;
     else
       height = Main_magnifier_factor;
@@ -153,7 +153,7 @@
 
 void Display_brush_color_double(word x_pos,word y_pos,word x_offset,word y_offset,word width,word height,byte transp_color,word brush_width)
 {
-  // dest = Position à l'écran
+  // dest = Position Ã  l'Ã©cran
   byte* dest = Screen_pixels + y_pos * ZOOMY * VIDEO_LINE_WIDTH + x_pos * ZOOMX;
   // src = Position dans la brosse
   byte* src = Brush + y_offset * brush_width + x_offset;
@@ -166,7 +166,7 @@
     // Pour chaque pixel
     for(x = width;x > 0; x--)
     {
-      // On vérifie que ce n'est pas la transparence
+      // On vÃ©rifie que ce n'est pas la transparence
       if(*src != transp_color)
       {
         *(dest+VIDEO_LINE_WIDTH+1) = *(dest+VIDEO_LINE_WIDTH) = *(dest+1) = *dest = *src;
@@ -177,7 +177,7 @@
       dest+=ZOOMX;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     dest = dest + VIDEO_LINE_WIDTH*ZOOMY - width*ZOOMX;
     src = src + brush_width - width;
   }
@@ -189,8 +189,8 @@
         byte transp_color, byte color, word brush_width)
 /* On affiche la brosse en monochrome */
 {
-  byte* dest=y_pos*ZOOMY*VIDEO_LINE_WIDTH+x_pos*ZOOMX+Screen_pixels; // dest = adr destination à 
-      // l'écran
+  byte* dest=y_pos*ZOOMY*VIDEO_LINE_WIDTH+x_pos*ZOOMX+Screen_pixels; // dest = adr destination Ã  
+      // l'Ã©cran
   byte* src=brush_width*y_offset+x_offset+Brush; // src = adr ds 
       // la brosse
   int x,y;
@@ -209,7 +209,7 @@
       dest+=ZOOMX;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     src+=brush_width-width;
     dest+=VIDEO_LINE_WIDTH*ZOOMY-width*ZOOMX;
   }
@@ -218,8 +218,8 @@
 
 void Clear_brush_double(word x_pos,word y_pos,__attribute__((unused)) word x_offset,__attribute__((unused)) word y_offset,word width,word height,__attribute__((unused))byte transp_color,word image_width)
 {
-  byte* dest=Screen_pixels+x_pos*ZOOMX+y_pos*ZOOMY*VIDEO_LINE_WIDTH; //On va se mettre en 0,0 dans l'écran (dest)
-  byte* src = ( y_pos + Main_offset_Y ) * image_width + x_pos + Main_offset_X + Main_screen; //Coords de départ ds la source (src)
+  byte* dest=Screen_pixels+x_pos*ZOOMX+y_pos*ZOOMY*VIDEO_LINE_WIDTH; //On va se mettre en 0,0 dans l'Ã©cran (dest)
+  byte* src = ( y_pos + Main_offset_Y ) * image_width + x_pos + Main_offset_X + Main_screen; //Coords de dÃ©part ds la source (src)
   int y;
   int x;
 
@@ -236,17 +236,17 @@
       dest+=ZOOMX;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     src+=image_width-width;
     dest+=VIDEO_LINE_WIDTH*ZOOMY-width*ZOOMX;
   }
   Update_rect(x_pos,y_pos,width,height);
 }
 
-// Affiche une brosse (arbitraire) à l'écran
+// Affiche une brosse (arbitraire) Ã  l'Ã©cran
 void Display_brush_double(byte * brush, word x_pos,word y_pos,word x_offset,word y_offset,word width,word height,byte transp_color,word brush_width)
 {
-  // dest = Position à l'écran
+  // dest = Position Ã  l'Ã©cran
   byte* dest = Screen_pixels + y_pos * ZOOMY * VIDEO_LINE_WIDTH + x_pos * ZOOMX;
   // src = Position dans la brosse
   byte* src = brush + y_offset * brush_width + x_offset;
@@ -259,7 +259,7 @@
     // Pour chaque pixel
     for(x = width;x > 0; x--)
     {
-      // On vérifie que ce n'est pas la transparence
+      // On vÃ©rifie que ce n'est pas la transparence
       if(*src != transp_color)
       {
         *(dest+VIDEO_LINE_WIDTH+1)=*(dest+VIDEO_LINE_WIDTH)=*(dest+1)=*dest=*src;
@@ -269,7 +269,7 @@
       src++; dest+=ZOOMX;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     dest = dest + VIDEO_LINE_WIDTH*ZOOMY - width*ZOOMX;
     src = src + brush_width - width;
   }
@@ -277,7 +277,7 @@
 
 void Remap_screen_double(word x_pos,word y_pos,word width,word height,byte * conversion_table)
 {
-  // dest = coords a l'écran
+  // dest = coords a l'Ã©cran
   byte* dest = Screen_pixels + y_pos * ZOOMY * VIDEO_LINE_WIDTH + x_pos * ZOOMX;
   int x,y;
 
@@ -300,7 +300,7 @@
 
 void Display_line_on_screen_fast_double(word x_pos,word y_pos,word width,byte * line)
 /* On affiche toute une ligne de pixels telle quelle. */
-/* Utilisée si le buffer contient déja des pixel doublés. */
+/* UtilisÃ©e si le buffer contient dÃ©ja des pixel doublÃ©s. */
 {
   memcpy(Screen_pixels+x_pos*ZOOMX+y_pos*ZOOMY*VIDEO_LINE_WIDTH,line,width*ZOOMX);
   memcpy(Screen_pixels+x_pos*ZOOMX+(y_pos*ZOOMY+1)*VIDEO_LINE_WIDTH,line,width*ZOOMX);
@@ -322,8 +322,8 @@
 void Display_transparent_mono_line_on_screen_double(
         word x_pos, word y_pos, word width, byte* line, 
         byte transp_color, byte color)
-// Affiche une ligne à l'écran avec une couleur + transparence.
-// Utilisé par les brosses en mode zoom
+// Affiche une ligne Ã  l'Ã©cran avec une couleur + transparence.
+// UtilisÃ© par les brosses en mode zoom
 {
   byte* dest = Screen_pixels+ y_pos*VIDEO_LINE_WIDTH + x_pos*ZOOMX;
   int x;
@@ -345,31 +345,31 @@
 }
 
 void Display_part_of_screen_scaled_double(
-        word width, // width non zoomée
-        word height, // height zoomée
+        word width, // width non zoomÃ©e
+        word height, // height zoomÃ©e
         word image_width,byte * buffer)
 {
   byte* src = Main_screen + Main_magnifier_offset_Y * image_width 
                       + Main_magnifier_offset_X;
   int y = 0; // Ligne en cours de traitement
 
-  // Pour chaque ligne à zoomer
+  // Pour chaque ligne Ã  zoomer
   while(1)
   {
     int x;
     
-    // On éclate la ligne
+    // On Ã©clate la ligne
     Zoom_a_line(src,buffer,Main_magnifier_factor*ZOOMX,width);
-    // On l'affiche Facteur fois, sur des lignes consécutives
+    // On l'affiche Facteur fois, sur des lignes consÃ©cutives
     x = Main_magnifier_factor;
     // Pour chaque ligne
     do{
-      // On affiche la ligne zoomée
+      // On affiche la ligne zoomÃ©e
       Display_line_on_screen_fast_double(
         Main_X_zoom, y, width*Main_magnifier_factor,
         buffer
       );
-      // On passe à la suivante
+      // On passe Ã  la suivante
       y++;
       if(y==height)
       {
@@ -386,12 +386,12 @@
 // ATTENTION on n'arrive jamais ici !
 }
 
-// Affiche une partie de la brosse couleur zoomée
+// Affiche une partie de la brosse couleur zoomÃ©e
 void Display_brush_color_zoom_double(word x_pos,word y_pos,
         word x_offset,word y_offset,
-        word width, // width non zoomée
+        word width, // width non zoomÃ©e
         word end_y_pos,byte transp_color,
-        word brush_width, // width réelle de la brosse
+        word brush_width, // width rÃ©elle de la brosse
         byte * buffer)
 {
   byte* src = Brush+y_offset*brush_width + x_offset;
@@ -402,7 +402,7 @@
   while(1)
   {
     Zoom_a_line(src,buffer,Main_magnifier_factor,width);
-    // On affiche facteur fois la ligne zoomée
+    // On affiche facteur fois la ligne zoomÃ©e
     for(bx=Main_magnifier_factor;bx>0;bx--)
     {
       Display_transparent_line_on_screen_wide(x_pos,y*ZOOMY,width*Main_magnifier_factor,buffer,transp_color);
@@ -420,10 +420,10 @@
 
 void Display_brush_mono_zoom_double(word x_pos, word y_pos,
         word x_offset, word y_offset, 
-        word width, // width non zoomée 
+        word width, // width non zoomÃ©e 
         word end_y_pos,
         byte transp_color, byte color, 
-        word brush_width, // width réelle de la brosse
+        word brush_width, // width rÃ©elle de la brosse
         byte * buffer
 )
 
@@ -431,29 +431,29 @@
   byte* src = Brush + y_offset * brush_width + x_offset;
   int y=y_pos*ZOOMY;
 
-  //Pour chaque ligne à zoomer :
+  //Pour chaque ligne Ã  zoomer :
   while(1)
   {
     int bx;
     // src = Ligne originale
-    // On éclate la ligne
+    // On Ã©clate la ligne
     Zoom_a_line(src,buffer,Main_magnifier_factor,width);
 
-    // On affiche la ligne Facteur fois à l'écran (sur des
-    // lignes consécutives)
+    // On affiche la ligne Facteur fois Ã  l'Ã©cran (sur des
+    // lignes consÃ©cutives)
     bx = Main_magnifier_factor*ZOOMY;
 
-    // Pour chaque ligne écran
+    // Pour chaque ligne Ã©cran
     do
     {
-      // On affiche la ligne zoomée
+      // On affiche la ligne zoomÃ©e
       Display_transparent_mono_line_on_screen_double(
         x_pos, y, width * Main_magnifier_factor, 
         buffer, transp_color, color
       );
-      // On passe à la ligne suivante
+      // On passe Ã  la ligne suivante
       y++;
-      // On vérifie qu'on est pas à la ligne finale
+      // On vÃ©rifie qu'on est pas Ã  la ligne finale
       if(y == end_y_pos*ZOOMY)
       {
         Redraw_grid( x_pos, y_pos,
@@ -466,7 +466,7 @@
     }
     while (bx > 0);
     
-    // Passage à la ligne suivante dans la brosse aussi
+    // Passage Ã  la ligne suivante dans la brosse aussi
     src+=brush_width;
   }
 }
@@ -474,12 +474,12 @@
 void Clear_brush_scaled_double(word x_pos,word y_pos,word x_offset,word y_offset,word width,word end_y_pos,__attribute__((unused)) byte transp_color,word image_width,byte * buffer)
 {
 
-  // En fait on va recopier l'image non zoomée dans la partie zoomée !
+  // En fait on va recopier l'image non zoomÃ©e dans la partie zoomÃ©e !
   byte* src = Main_screen + y_offset * image_width + x_offset;
   int y = y_pos;
   int bx;
 
-  // Pour chaque ligne à zoomer
+  // Pour chaque ligne Ã  zoomer
   while(1){
     Zoom_a_line(src,buffer,Main_magnifier_factor*ZOOMX,width);
 
diff -ruN gfx2orig/src/pxquad.c grafx2/src/pxquad.c
--- gfx2orig/src/pxquad.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/pxquad.c	2022-03-20 20:19:34.112495316 -0500
@@ -38,7 +38,7 @@
 #endif
 
 void Pixel_quad (word x,word y,byte color)
-/* Affiche un pixel de la color aux coords x;y à l'écran */
+/* Affiche un pixel de la color aux coords x;y Ã  l'Ã©cran */
 {
   *(Screen_pixels + x * ZOOMX + y*ZOOMY * VIDEO_LINE_WIDTH)=color;
   *(Screen_pixels + x * ZOOMX + y*ZOOMY * VIDEO_LINE_WIDTH + 1)=color;
@@ -59,13 +59,13 @@
 }
 
 byte Read_pixel_quad (word x,word y)
-/* On retourne la couleur du pixel aux coords données */
+/* On retourne la couleur du pixel aux coords donnÃ©es */
 {
   return *( Screen_pixels + y * ZOOMY * VIDEO_LINE_WIDTH + x * ZOOMX);
 }
 
 void Block_quad (word start_x,word start_y,word width,word height,byte color)
-/* On affiche un rectangle de la couleur donnée */
+/* On affiche un rectangle de la couleur donnÃ©e */
 {
   SDL_Rect rectangle;
   rectangle.x=start_x*ZOOMX;
@@ -76,10 +76,10 @@
 }
 
 void Display_part_of_screen_quad (word width,word height,word image_width)
-/* Afficher une partie de l'image telle quelle sur l'écran */
+/* Afficher une partie de l'image telle quelle sur l'Ã©cran */
 {
-  byte* dest=Screen_pixels; //On va se mettre en 0,0 dans l'écran (dest)
-  byte* src=Main_offset_Y*image_width+Main_offset_X+Main_screen; //Coords de départ ds la source (src)
+  byte* dest=Screen_pixels; //On va se mettre en 0,0 dans l'Ã©cran (dest)
+  byte* src=Main_offset_Y*image_width+Main_offset_X+Main_screen; //Coords de dÃ©part ds la source (src)
   int y;
   int dy;
 
@@ -100,7 +100,7 @@
     // On la quadruple
     memcpy(dest-width*ZOOMX+3*VIDEO_LINE_WIDTH,dest-width*ZOOMX,width*ZOOMX);
     
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     src+=image_width-width;
     dest+=VIDEO_LINE_WIDTH*ZOOMY - width*ZOOMX;
   }
@@ -108,10 +108,10 @@
 }
 
 void Pixel_preview_normal_quad (word x,word y,byte color)
-/* Affichage d'un pixel dans l'écran, par rapport au décalage de l'image 
- * dans l'écran, en mode normal (pas en mode loupe)
- * Note: si on modifie cette procédure, il faudra penser à faire également 
- * la modif dans la procédure Pixel_Preview_Loupe_SDL. */
+/* Affichage d'un pixel dans l'Ã©cran, par rapport au dÃ©calage de l'image 
+ * dans l'Ã©cran, en mode normal (pas en mode loupe)
+ * Note: si on modifie cette procÃ©dure, il faudra penser Ã  faire Ã©galement 
+ * la modif dans la procÃ©dure Pixel_Preview_Loupe_SDL. */
 {
 //  if(x-Main_offset_X >= 0 && y - Main_offset_Y >= 0)
   Pixel_quad(x-Main_offset_X,y-Main_offset_Y,color);
@@ -119,10 +119,10 @@
 
 void Pixel_preview_magnifier_quad  (word x,word y,byte color)
 {
-  // Affiche le pixel dans la partie non zoomée
+  // Affiche le pixel dans la partie non zoomÃ©e
   Pixel_quad(x-Main_offset_X,y-Main_offset_Y,color);
   
-  // Regarde si on doit aussi l'afficher dans la partie zoomée
+  // Regarde si on doit aussi l'afficher dans la partie zoomÃ©e
   if (y >= Limit_top_zoom && y <= Limit_visible_bottom_zoom
           && x >= Limit_left_zoom && x <= Limit_visible_right_zoom)
   {
@@ -132,7 +132,7 @@
 
     if (Menu_Y - y_zoom < Main_magnifier_factor)
       // On ne doit dessiner qu'un morceau du pixel
-      // sinon on dépasse sur le menu
+      // sinon on dÃ©passe sur le menu
       height = Menu_Y - y_zoom;
     else
       height = Main_magnifier_factor;
@@ -168,7 +168,7 @@
 
 void Display_brush_color_quad(word x_pos,word y_pos,word x_offset,word y_offset,word width,word height,byte transp_color,word brush_width)
 {
-  // dest = Position à l'écran
+  // dest = Position Ã  l'Ã©cran
   byte* dest = Screen_pixels + y_pos * ZOOMY * VIDEO_LINE_WIDTH + x_pos * ZOOMX;
   // src = Position dans la brosse
   byte* src = Brush + y_offset * brush_width + x_offset;
@@ -181,7 +181,7 @@
     // Pour chaque pixel
     for(x = width;x > 0; x--)
     {
-      // On vérifie que ce n'est pas la transparence
+      // On vÃ©rifie que ce n'est pas la transparence
       if(*src != transp_color)
       {
         *(dest+3*VIDEO_LINE_WIDTH+3) = *(dest+3*VIDEO_LINE_WIDTH+2) = *(dest+3*VIDEO_LINE_WIDTH+1) = *(dest+3*VIDEO_LINE_WIDTH) = *(dest+2*VIDEO_LINE_WIDTH+3) = *(dest+2*VIDEO_LINE_WIDTH+2) = *(dest+2*VIDEO_LINE_WIDTH+1) = *(dest+2*VIDEO_LINE_WIDTH) = *(dest+VIDEO_LINE_WIDTH+3) = *(dest+VIDEO_LINE_WIDTH+2) = *(dest+VIDEO_LINE_WIDTH+1) = *(dest+VIDEO_LINE_WIDTH) = *(dest+3) = *(dest+2) = *(dest+1) = *dest = *src;
@@ -192,7 +192,7 @@
       dest+=ZOOMX;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     dest = dest + VIDEO_LINE_WIDTH*ZOOMY - width*ZOOMX;
     src = src + brush_width - width;
   }
@@ -204,8 +204,8 @@
         byte transp_color, byte color, word brush_width)
 /* On affiche la brosse en monochrome */
 {
-  byte* dest=y_pos*ZOOMY*VIDEO_LINE_WIDTH+x_pos*ZOOMX+Screen_pixels; // dest = adr destination à 
-      // l'écran
+  byte* dest=y_pos*ZOOMY*VIDEO_LINE_WIDTH+x_pos*ZOOMX+Screen_pixels; // dest = adr destination Ã  
+      // l'Ã©cran
   byte* src=brush_width*y_offset+x_offset+Brush; // src = adr ds 
       // la brosse
   int x,y;
@@ -224,7 +224,7 @@
       dest+=ZOOMX;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     src+=brush_width-width;
     dest+=VIDEO_LINE_WIDTH*ZOOMY-width*ZOOMX;
   }
@@ -233,8 +233,8 @@
 
 void Clear_brush_quad(word x_pos,word y_pos,__attribute__((unused)) word x_offset,__attribute__((unused)) word y_offset,word width,word height,__attribute__((unused))byte transp_color,word image_width)
 {
-  byte* dest=Screen_pixels+x_pos*ZOOMX+y_pos*ZOOMY*VIDEO_LINE_WIDTH; //On va se mettre en 0,0 dans l'écran (dest)
-  byte* src = ( y_pos + Main_offset_Y ) * image_width + x_pos + Main_offset_X + Main_screen; //Coords de départ ds la source (src)
+  byte* dest=Screen_pixels+x_pos*ZOOMX+y_pos*ZOOMY*VIDEO_LINE_WIDTH; //On va se mettre en 0,0 dans l'Ã©cran (dest)
+  byte* src = ( y_pos + Main_offset_Y ) * image_width + x_pos + Main_offset_X + Main_screen; //Coords de dÃ©part ds la source (src)
   int y;
   int x;
 
@@ -251,17 +251,17 @@
       dest+=ZOOMX;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     src+=image_width-width;
     dest+=VIDEO_LINE_WIDTH*ZOOMY-width*ZOOMX;
   }
   Update_rect(x_pos,y_pos,width,height);
 }
 
-// Affiche une brosse (arbitraire) à l'écran
+// Affiche une brosse (arbitraire) Ã  l'Ã©cran
 void Display_brush_quad(byte * brush, word x_pos,word y_pos,word x_offset,word y_offset,word width,word height,byte transp_color,word brush_width)
 {
-  // dest = Position à l'écran
+  // dest = Position Ã  l'Ã©cran
   byte* dest = Screen_pixels + y_pos * ZOOMY * VIDEO_LINE_WIDTH + x_pos * ZOOMX;
   // src = Position dans la brosse
   byte* src = brush + y_offset * brush_width + x_offset;
@@ -274,7 +274,7 @@
     // Pour chaque pixel
     for(x = width;x > 0; x--)
     {
-      // On vérifie que ce n'est pas la transparence
+      // On vÃ©rifie que ce n'est pas la transparence
       if(*src != transp_color)
       {
         *(dest+3*VIDEO_LINE_WIDTH+3)=*(dest+3*VIDEO_LINE_WIDTH+2)=*(dest+3*VIDEO_LINE_WIDTH+1)=*(dest+3*VIDEO_LINE_WIDTH)=*(dest+2*VIDEO_LINE_WIDTH+3)=*(dest+2*VIDEO_LINE_WIDTH+2)=*(dest+2*VIDEO_LINE_WIDTH+1)=*(dest+2*VIDEO_LINE_WIDTH)=*(dest+VIDEO_LINE_WIDTH+3)=*(dest+VIDEO_LINE_WIDTH+2)=*(dest+VIDEO_LINE_WIDTH+1)=*(dest+VIDEO_LINE_WIDTH)=*(dest+3)=*(dest+2)=*(dest+1)=*dest=*src;
@@ -284,7 +284,7 @@
       src++; dest+=ZOOMX;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     dest = dest + VIDEO_LINE_WIDTH*ZOOMY - width*ZOOMX;
     src = src + brush_width - width;
   }
@@ -292,7 +292,7 @@
 
 void Remap_screen_quad(word x_pos,word y_pos,word width,word height,byte * conversion_table)
 {
-  // dest = coords a l'écran
+  // dest = coords a l'Ã©cran
   byte* dest = Screen_pixels + y_pos * ZOOMY * VIDEO_LINE_WIDTH + x_pos * ZOOMX;
   int x,y;
 
@@ -315,7 +315,7 @@
 
 void Display_line_on_screen_fast_quad(word x_pos,word y_pos,word width,byte * line)
 /* On affiche toute une ligne de pixels telle quelle. */
-/* Utilisée si le buffer contient déja des pixel doublés. */
+/* UtilisÃ©e si le buffer contient dÃ©ja des pixel doublÃ©s. */
 {
   memcpy(Screen_pixels+x_pos*ZOOMX+y_pos*ZOOMY*VIDEO_LINE_WIDTH,line,width*ZOOMX);
   memcpy(Screen_pixels+x_pos*ZOOMX+(y_pos*ZOOMY+1)*VIDEO_LINE_WIDTH,line,width*ZOOMX);
@@ -339,8 +339,8 @@
 void Display_transparent_mono_line_on_screen_quad(
         word x_pos, word y_pos, word width, byte* line, 
         byte transp_color, byte color)
-// Affiche une ligne à l'écran avec une couleur + transparence.
-// Utilisé par les brosses en mode zoom
+// Affiche une ligne Ã  l'Ã©cran avec une couleur + transparence.
+// UtilisÃ© par les brosses en mode zoom
 {
   byte* dest = Screen_pixels+ y_pos*VIDEO_LINE_WIDTH + x_pos*ZOOMX;
   int x;
@@ -362,31 +362,31 @@
 }
 
 void Display_part_of_screen_scaled_quad(
-        word width, // width non zoomée
-        word height, // height zoomée
+        word width, // width non zoomÃ©e
+        word height, // height zoomÃ©e
         word image_width,byte * buffer)
 {
   byte* src = Main_screen + Main_magnifier_offset_Y * image_width 
                       + Main_magnifier_offset_X;
   int y = 0; // Ligne en cours de traitement
 
-  // Pour chaque ligne à zoomer
+  // Pour chaque ligne Ã  zoomer
   while(1)
   {
     int x;
     
-    // On éclate la ligne
+    // On Ã©clate la ligne
     Zoom_a_line(src,buffer,Main_magnifier_factor*ZOOMX,width);
-    // On l'affiche Facteur fois, sur des lignes consécutives
+    // On l'affiche Facteur fois, sur des lignes consÃ©cutives
     x = Main_magnifier_factor/**ZOOMY*/;
     // Pour chaque ligne
     do{
-      // On affiche la ligne zoomée
+      // On affiche la ligne zoomÃ©e
       Display_line_on_screen_fast_quad(
         Main_X_zoom, y, width*Main_magnifier_factor,
         buffer
       );
-      // On passe à la suivante
+      // On passe Ã  la suivante
       y++;
       if(y==height/**ZOOMY*/)
       {
@@ -403,12 +403,12 @@
 // ATTENTION on n'arrive jamais ici !
 }
 
-// Affiche une partie de la brosse couleur zoomée
+// Affiche une partie de la brosse couleur zoomÃ©e
 void Display_brush_color_zoom_quad(word x_pos,word y_pos,
         word x_offset,word y_offset,
-        word width, // width non zoomée
+        word width, // width non zoomÃ©e
         word end_y_pos,byte transp_color,
-        word brush_width, // width réelle de la brosse
+        word brush_width, // width rÃ©elle de la brosse
         byte * buffer)
 {
   byte* src = Brush+y_offset*brush_width + x_offset;
@@ -419,7 +419,7 @@
   while(1)
   {
     Zoom_a_line(src,buffer,Main_magnifier_factor,width);
-    // On affiche facteur fois la ligne zoomée
+    // On affiche facteur fois la ligne zoomÃ©e
     for(bx=Main_magnifier_factor;bx>0;bx--)
     {
       byte* line_src = buffer;
@@ -454,10 +454,10 @@
 
 void Display_brush_mono_zoom_quad(word x_pos, word y_pos,
         word x_offset, word y_offset, 
-        word width, // width non zoomée 
+        word width, // width non zoomÃ©e 
         word end_y_pos,
         byte transp_color, byte color, 
-        word brush_width, // width réelle de la brosse
+        word brush_width, // width rÃ©elle de la brosse
         byte * buffer
 )
 
@@ -465,29 +465,29 @@
   byte* src = Brush + y_offset * brush_width + x_offset;
   int y=y_pos*ZOOMY;
 
-  //Pour chaque ligne à zoomer :
+  //Pour chaque ligne Ã  zoomer :
   while(1)
   {
     int bx;
     // src = Ligne originale
-    // On éclate la ligne
+    // On Ã©clate la ligne
     Zoom_a_line(src,buffer,Main_magnifier_factor,width);
 
-    // On affiche la ligne Facteur fois à l'écran (sur des
-    // lignes consécutives)
+    // On affiche la ligne Facteur fois Ã  l'Ã©cran (sur des
+    // lignes consÃ©cutives)
     bx = Main_magnifier_factor*ZOOMY;
 
-    // Pour chaque ligne écran
+    // Pour chaque ligne Ã©cran
     do
     {
-      // On affiche la ligne zoomée
+      // On affiche la ligne zoomÃ©e
       Display_transparent_mono_line_on_screen_quad(
         x_pos, y, width * Main_magnifier_factor, 
         buffer, transp_color, color
       );
-      // On passe à la ligne suivante
+      // On passe Ã  la ligne suivante
       y++;
-      // On vérifie qu'on est pas à la ligne finale
+      // On vÃ©rifie qu'on est pas Ã  la ligne finale
       if(y == end_y_pos*ZOOMY)
       {
         Redraw_grid( x_pos, y_pos,
@@ -500,7 +500,7 @@
     }
     while (bx > 0);
     
-    // Passage à la ligne suivante dans la brosse aussi
+    // Passage Ã  la ligne suivante dans la brosse aussi
     src+=brush_width;
   }
 }
@@ -508,12 +508,12 @@
 void Clear_brush_scaled_quad(word x_pos,word y_pos,word x_offset,word y_offset,word width,word end_y_pos,__attribute__((unused)) byte transp_color,word image_width,byte * buffer)
 {
 
-  // En fait on va recopier l'image non zoomée dans la partie zoomée !
+  // En fait on va recopier l'image non zoomÃ©e dans la partie zoomÃ©e !
   byte* src = Main_screen + y_offset * image_width + x_offset;
   int y = y_pos;
   int bx;
 
-  // Pour chaque ligne à zoomer
+  // Pour chaque ligne Ã  zoomer
   while(1){
     Zoom_a_line(src,buffer,Main_magnifier_factor*ZOOMX,width);
 
diff -ruN gfx2orig/src/pxsimple.c grafx2/src/pxsimple.c
--- gfx2orig/src/pxsimple.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/pxsimple.c	2022-03-20 20:19:34.108495316 -0500
@@ -35,19 +35,19 @@
 #endif
 
 void Pixel_simple (word x,word y,byte color)
-/* Affiche un pixel de la color aux coords x;y à l'écran */
+/* Affiche un pixel de la color aux coords x;y Ã  l'Ã©cran */
 {
   *(Screen_pixels + x + y * VIDEO_LINE_WIDTH)=color;
 }
 
 byte Read_pixel_simple (word x,word y)
-/* On retourne la couleur du pixel aux coords données */
+/* On retourne la couleur du pixel aux coords donnÃ©es */
 {
   return *( Screen_pixels + y * VIDEO_LINE_WIDTH + x );
 }
 
 void Block_simple (word start_x,word start_y,word width,word height,byte color)
-/* On affiche un rectangle de la couleur donnée */
+/* On affiche un rectangle de la couleur donnÃ©e */
 {
   SDL_Rect rectangle;
   rectangle.x=start_x;
@@ -58,10 +58,10 @@
 }
 
 void Display_part_of_screen_simple (word width,word height,word image_width)
-/* Afficher une partie de l'image telle quelle sur l'écran */
+/* Afficher une partie de l'image telle quelle sur l'Ã©cran */
 {
-  byte* dest=Screen_pixels; //On va se mettre en 0,0 dans l'écran (dest)
-  byte* src=Main_offset_Y*image_width+Main_offset_X+Main_screen; //Coords de départ ds la source (src)
+  byte* dest=Screen_pixels; //On va se mettre en 0,0 dans l'Ã©cran (dest)
+  byte* src=Main_offset_Y*image_width+Main_offset_X+Main_screen; //Coords de dÃ©part ds la source (src)
   int y;
 
   for(y=height;y!=0;y--)
@@ -70,7 +70,7 @@
     // On fait une copie de la ligne
     memcpy(dest,src,width);
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     src+=image_width;
     dest+=VIDEO_LINE_WIDTH;
   }
@@ -78,10 +78,10 @@
 }
 
 void Pixel_preview_normal_simple (word x,word y,byte color)
-/* Affichage d'un pixel dans l'écran, par rapport au décalage de l'image 
- * dans l'écran, en mode normal (pas en mode loupe)
- * Note: si on modifie cette procédure, il faudra penser à faire également 
- * la modif dans la procédure Pixel_Preview_Loupe_SDL. */
+/* Affichage d'un pixel dans l'Ã©cran, par rapport au dÃ©calage de l'image 
+ * dans l'Ã©cran, en mode normal (pas en mode loupe)
+ * Note: si on modifie cette procÃ©dure, il faudra penser Ã  faire Ã©galement 
+ * la modif dans la procÃ©dure Pixel_Preview_Loupe_SDL. */
 {
 //  if(x-Main_offset_X >= 0 && y - Main_offset_Y >= 0)
   Pixel_simple(x-Main_offset_X,y-Main_offset_Y,color);
@@ -89,10 +89,10 @@
 
 void Pixel_preview_magnifier_simple  (word x,word y,byte color)
 {
-  // Affiche le pixel dans la partie non zoomée
+  // Affiche le pixel dans la partie non zoomÃ©e
   Pixel_simple(x-Main_offset_X,y-Main_offset_Y,color);
   
-  // Regarde si on doit aussi l'afficher dans la partie zoomée
+  // Regarde si on doit aussi l'afficher dans la partie zoomÃ©e
   if (y >= Limit_top_zoom && y <= Limit_visible_bottom_zoom
           && x >= Limit_left_zoom && x <= Limit_visible_right_zoom)
   {
@@ -102,7 +102,7 @@
 
     if (Menu_Y - y_zoom < Main_magnifier_factor)
       // On ne doit dessiner qu'un morceau du pixel
-      // sinon on dépasse sur le menu
+      // sinon on dÃ©passe sur le menu
       height = Menu_Y - y_zoom;
     else
       height = Main_magnifier_factor;
@@ -138,7 +138,7 @@
 
 void Display_brush_color_simple(word x_pos,word y_pos,word x_offset,word y_offset,word width,word height,byte transp_color,word brush_width)
 {
-  // dest = Position à l'écran
+  // dest = Position Ã  l'Ã©cran
   byte* dest = Screen_pixels + y_pos * VIDEO_LINE_WIDTH + x_pos;
   // src = Position dans la brosse
   byte* src = Brush + y_offset * brush_width + x_offset;
@@ -151,7 +151,7 @@
     // Pour chaque pixel
     for(x = width;x > 0; x--)
     {
-      // On vérifie que ce n'est pas la transparence
+      // On vÃ©rifie que ce n'est pas la transparence
       if(*src != transp_color)
       {
         *dest = *src;
@@ -161,7 +161,7 @@
       src++; dest++;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     dest = dest + VIDEO_LINE_WIDTH - width;
     src = src + brush_width - width;
   }
@@ -173,8 +173,8 @@
         byte transp_color, byte color, word brush_width)
 /* On affiche la brosse en monochrome */
 {
-  byte* dest=y_pos*VIDEO_LINE_WIDTH+x_pos+Screen_pixels; // dest = adr Destination à 
-      // l'écran
+  byte* dest=y_pos*VIDEO_LINE_WIDTH+x_pos+Screen_pixels; // dest = adr Destination Ã  
+      // l'Ã©cran
   byte* src=brush_width*y_offset+x_offset+Brush; // src = adr ds 
       // la brosse
   int x,y;
@@ -193,7 +193,7 @@
       dest++;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     src+=brush_width-width;
     dest+=VIDEO_LINE_WIDTH-width;
   }
@@ -202,8 +202,8 @@
 
 void Clear_brush_simple(word x_pos,word y_pos,__attribute__((unused)) word x_offset,__attribute__((unused)) word y_offset,word width,word height,__attribute__((unused))byte transp_color,word image_width)
 {
-  byte* dest=Screen_pixels+x_pos+y_pos*VIDEO_LINE_WIDTH; //On va se mettre en 0,0 dans l'écran (dest)
-  byte* src = ( y_pos + Main_offset_Y ) * image_width + x_pos + Main_offset_X + Main_screen; //Coords de départ ds la source (src)
+  byte* dest=Screen_pixels+x_pos+y_pos*VIDEO_LINE_WIDTH; //On va se mettre en 0,0 dans l'Ã©cran (dest)
+  byte* src = ( y_pos + Main_offset_Y ) * image_width + x_pos + Main_offset_X + Main_screen; //Coords de dÃ©part ds la source (src)
   int y;
 
   for(y=height;y!=0;y--)
@@ -212,17 +212,17 @@
     // On fait une copie de la ligne
     memcpy(dest,src,width);
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     src+=image_width;
     dest+=VIDEO_LINE_WIDTH;
   }
   Update_rect(x_pos,y_pos,width,height);
 }
 
-// Affiche une brosse (arbitraire) à l'écran
+// Affiche une brosse (arbitraire) Ã  l'Ã©cran
 void Display_brush_simple(byte * brush, word x_pos,word y_pos,word x_offset,word y_offset,word width,word height,byte transp_color,word brush_width)
 {
-  // dest = Position à l'écran
+  // dest = Position Ã  l'Ã©cran
   byte* dest = Screen_pixels + y_pos * VIDEO_LINE_WIDTH + x_pos;
   // src = Position dans la brosse
   byte* src = brush + y_offset * brush_width + x_offset;
@@ -235,7 +235,7 @@
     // Pour chaque pixel
     for(x = width;x > 0; x--)
     {
-      // On vérifie que ce n'est pas la transparence
+      // On vÃ©rifie que ce n'est pas la transparence
       if(*src != transp_color)
       {
         *dest = *src;
@@ -245,7 +245,7 @@
       src++; dest++;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     dest = dest + VIDEO_LINE_WIDTH - width;
     src = src + brush_width - width;
   }
@@ -253,7 +253,7 @@
 
 void Remap_screen_simple(word x_pos,word y_pos,word width,word height,byte * conversion_table)
 {
-  // dest = coords a l'écran
+  // dest = coords a l'Ã©cran
   byte* dest = Screen_pixels + y_pos * VIDEO_LINE_WIDTH + x_pos;
   int x,y;
 
@@ -274,7 +274,7 @@
 }
 
 void Display_line_on_screen_simple(word x_pos,word y_pos,word width,byte * line)
-/* On affiche toute une ligne de pixels. Utilisé pour les textes. */
+/* On affiche toute une ligne de pixels. UtilisÃ© pour les textes. */
 {
   memcpy(Screen_pixels+x_pos+y_pos*VIDEO_LINE_WIDTH,line,width);
 }
@@ -282,8 +282,8 @@
 void Display_transparent_mono_line_on_screen_simple(
         word x_pos, word y_pos, word width, byte* line, 
         byte transp_color, byte color)
-// Affiche une ligne à l'écran avec une couleur + transparence.
-// Utilisé par les brosses en mode zoom
+// Affiche une ligne Ã  l'Ã©cran avec une couleur + transparence.
+// UtilisÃ© par les brosses en mode zoom
 {
   byte* dest = Screen_pixels+ y_pos * VIDEO_LINE_WIDTH + x_pos;
   int x;
@@ -303,31 +303,31 @@
 }
 
 void Display_part_of_screen_scaled_simple(
-        word width, // width non zoomée
-        word height, // height zoomée
+        word width, // width non zoomÃ©e
+        word height, // height zoomÃ©e
         word image_width,byte * buffer)
 {
   byte* src = Main_screen + Main_magnifier_offset_Y * image_width 
                       + Main_magnifier_offset_X;
   int y = 0; // Ligne en cours de traitement
 
-  // Pour chaque ligne à zoomer
+  // Pour chaque ligne Ã  zoomer
   while(1)
   {
     int x;
     
-    // On éclate la ligne
+    // On Ã©clate la ligne
     Zoom_a_line(src,buffer,Main_magnifier_factor,width);
-    // On l'affiche Facteur fois, sur des lignes consécutives
+    // On l'affiche Facteur fois, sur des lignes consÃ©cutives
     x = Main_magnifier_factor;
     // Pour chaque ligne
     do{
-      // On affiche la ligne zoomée
+      // On affiche la ligne zoomÃ©e
       Display_line_on_screen_simple(
         Main_X_zoom, y, width*Main_magnifier_factor,
         buffer
       );
-      // On passe à la suivante
+      // On passe Ã  la suivante
       y++;
       if(y==height)
       {
@@ -361,12 +361,12 @@
   }
 }
 
-// Affiche une partie de la brosse couleur zoomée
+// Affiche une partie de la brosse couleur zoomÃ©e
 void Display_brush_color_zoom_simple(word x_pos,word y_pos,
         word x_offset,word y_offset,
-        word width, // width non zoomée
+        word width, // width non zoomÃ©e
         word end_y_pos,byte transp_color,
-        word brush_width, // width réelle de la brosse
+        word brush_width, // width rÃ©elle de la brosse
         byte * buffer)
 {
   byte* src = Brush+y_offset*brush_width + x_offset;
@@ -377,7 +377,7 @@
   while(1)
   {
     Zoom_a_line(src,buffer,Main_magnifier_factor,width);
-    // On affiche facteur fois la ligne zoomée
+    // On affiche facteur fois la ligne zoomÃ©e
     for(bx=Main_magnifier_factor;bx>0;bx--)
     {
       Display_transparent_line_on_screen_simple(x_pos,y,width*Main_magnifier_factor,buffer,transp_color);
@@ -394,10 +394,10 @@
 
 void Display_brush_mono_zoom_simple(word x_pos, word y_pos,
         word x_offset, word y_offset, 
-        word width, // width non zoomée 
+        word width, // width non zoomÃ©e 
         word end_y_pos,
         byte transp_color, byte color, 
-        word brush_width, // width réelle de la brosse
+        word brush_width, // width rÃ©elle de la brosse
         byte * buffer
 )
 
@@ -405,29 +405,29 @@
   byte* src = Brush + y_offset * brush_width + x_offset;
   int y=y_pos;
 
-  //Pour chaque ligne à zoomer :
+  //Pour chaque ligne Ã  zoomer :
   while(1)
   {
     int bx;
     // src = Ligne originale
-    // On éclate la ligne
+    // On Ã©clate la ligne
     Zoom_a_line(src,buffer,Main_magnifier_factor,width);
 
-    // On affiche la ligne Facteur fois à l'écran (sur des
-    // lignes consécutives)
+    // On affiche la ligne Facteur fois Ã  l'Ã©cran (sur des
+    // lignes consÃ©cutives)
     bx = Main_magnifier_factor;
 
-    // Pour chaque ligne écran
+    // Pour chaque ligne Ã©cran
     do
     {
-      // On affiche la ligne zoomée
+      // On affiche la ligne zoomÃ©e
       Display_transparent_mono_line_on_screen_simple(
         x_pos, y, width * Main_magnifier_factor, 
         buffer, transp_color, color
       );
-      // On passe à la ligne suivante
+      // On passe Ã  la ligne suivante
       y++;
-      // On vérifie qu'on est pas à la ligne finale
+      // On vÃ©rifie qu'on est pas Ã  la ligne finale
       if(y == end_y_pos)
       {
         Redraw_grid( x_pos, y_pos,
@@ -440,19 +440,19 @@
     }
     while (bx > 0);
     
-    // Passage à la ligne suivante dans la brosse aussi
+    // Passage Ã  la ligne suivante dans la brosse aussi
     src+=brush_width;
   }
 }
 
 void Clear_brush_scaled_simple(word x_pos,word y_pos,word x_offset,word y_offset,word width,word end_y_pos,__attribute__((unused)) byte transp_color,word image_width,byte * buffer)
 {
-  // En fait on va recopier l'image non zoomée dans la partie zoomée !
+  // En fait on va recopier l'image non zoomÃ©e dans la partie zoomÃ©e !
   byte* src = Main_screen + y_offset * image_width + x_offset;
   int y = y_pos;
   int bx;
 
-  // Pour chaque ligne à zoomer
+  // Pour chaque ligne Ã  zoomer
   while(1){
     Zoom_a_line(src,buffer,Main_magnifier_factor,width);
 
diff -ruN gfx2orig/src/pxtall2.c grafx2/src/pxtall2.c
--- gfx2orig/src/pxtall2.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/pxtall2.c	2022-03-20 20:19:34.108495316 -0500
@@ -38,7 +38,7 @@
 #endif
 
 void Pixel_tall2 (word x,word y,byte color)
-/* Affiche un pixel de la color aux coords x;y à l'écran */
+/* Affiche un pixel de la color aux coords x;y Ã  l'Ã©cran */
 {
   *(Screen_pixels + x * ZOOMX + y*ZOOMY * VIDEO_LINE_WIDTH)=color;
   *(Screen_pixels + x * ZOOMX + y*ZOOMY * VIDEO_LINE_WIDTH + 1)=color;
@@ -51,13 +51,13 @@
 }
 
 byte Read_pixel_tall2 (word x,word y)
-/* On retourne la couleur du pixel aux coords données */
+/* On retourne la couleur du pixel aux coords donnÃ©es */
 {
   return *( Screen_pixels + y * ZOOMY * VIDEO_LINE_WIDTH + x * ZOOMX);
 }
 
 void Block_tall2 (word start_x,word start_y,word width,word height,byte color)
-/* On affiche un rectangle de la couleur donnée */
+/* On affiche un rectangle de la couleur donnÃ©e */
 {
   SDL_Rect rectangle;
   rectangle.x=start_x*ZOOMX;
@@ -68,10 +68,10 @@
 }
 
 void Display_part_of_screen_tall2 (word width,word height,word image_width)
-/* Afficher une partie de l'image telle quelle sur l'écran */
+/* Afficher une partie de l'image telle quelle sur l'Ã©cran */
 {
-  byte* dest=Screen_pixels; //On va se mettre en 0,0 dans l'écran (dest)
-  byte* src=Main_offset_Y*image_width+Main_offset_X+Main_screen; //Coords de départ ds la source (src)
+  byte* dest=Screen_pixels; //On va se mettre en 0,0 dans l'Ã©cran (dest)
+  byte* src=Main_offset_Y*image_width+Main_offset_X+Main_screen; //Coords de dÃ©part ds la source (src)
   int y;
   int dy;
 
@@ -92,7 +92,7 @@
     // On la quadruple
     memcpy(dest-width*ZOOMX+3*VIDEO_LINE_WIDTH,dest-width*ZOOMX,width*ZOOMX);
     
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     src+=image_width-width;
     dest+=VIDEO_LINE_WIDTH*ZOOMY - width*ZOOMX;
   }
@@ -100,10 +100,10 @@
 }
 
 void Pixel_preview_normal_tall2 (word x,word y,byte color)
-/* Affichage d'un pixel dans l'écran, par rapport au décalage de l'image 
- * dans l'écran, en mode normal (pas en mode loupe)
- * Note: si on modifie cette procédure, il faudra penser à faire également 
- * la modif dans la procédure Pixel_Preview_Loupe_SDL. */
+/* Affichage d'un pixel dans l'Ã©cran, par rapport au dÃ©calage de l'image 
+ * dans l'Ã©cran, en mode normal (pas en mode loupe)
+ * Note: si on modifie cette procÃ©dure, il faudra penser Ã  faire Ã©galement 
+ * la modif dans la procÃ©dure Pixel_Preview_Loupe_SDL. */
 {
 //  if(x-Main_offset_X >= 0 && y - Main_offset_Y >= 0)
   Pixel_tall2(x-Main_offset_X,y-Main_offset_Y,color);
@@ -111,10 +111,10 @@
 
 void Pixel_preview_magnifier_tall2  (word x,word y,byte color)
 {
-  // Affiche le pixel dans la partie non zoomée
+  // Affiche le pixel dans la partie non zoomÃ©e
   Pixel_tall2(x-Main_offset_X,y-Main_offset_Y,color);
   
-  // Regarde si on doit aussi l'afficher dans la partie zoomée
+  // Regarde si on doit aussi l'afficher dans la partie zoomÃ©e
   if (y >= Limit_top_zoom && y <= Limit_visible_bottom_zoom
           && x >= Limit_left_zoom && x <= Limit_visible_right_zoom)
   {
@@ -124,7 +124,7 @@
 
     if (Menu_Y - y_zoom < Main_magnifier_factor)
       // On ne doit dessiner qu'un morceau du pixel
-      // sinon on dépasse sur le menu
+      // sinon on dÃ©passe sur le menu
       height = Menu_Y - y_zoom;
     else
       height = Main_magnifier_factor;
@@ -160,7 +160,7 @@
 
 void Display_brush_color_tall2(word x_pos,word y_pos,word x_offset,word y_offset,word width,word height,byte transp_color,word brush_width)
 {
-  // dest = Position à l'écran
+  // dest = Position Ã  l'Ã©cran
   byte* dest = Screen_pixels + y_pos * ZOOMY * VIDEO_LINE_WIDTH + x_pos * ZOOMX;
   // src = Position dans la brosse
   byte* src = Brush + y_offset * brush_width + x_offset;
@@ -173,7 +173,7 @@
     // Pour chaque pixel
     for(x = width;x > 0; x--)
     {
-      // On vérifie que ce n'est pas la transparence
+      // On vÃ©rifie que ce n'est pas la transparence
       if(*src != transp_color)
       {
         *(dest+3*VIDEO_LINE_WIDTH+1) = *(dest+3*VIDEO_LINE_WIDTH) = *(dest+2*VIDEO_LINE_WIDTH+1) = *(dest+2*VIDEO_LINE_WIDTH) = *(dest+VIDEO_LINE_WIDTH+1) = *(dest+VIDEO_LINE_WIDTH) = *(dest+1) = *dest = *src;
@@ -184,7 +184,7 @@
       dest+=ZOOMX;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     dest = dest + VIDEO_LINE_WIDTH*ZOOMY - width*ZOOMX;
     src = src + brush_width - width;
   }
@@ -196,8 +196,8 @@
         byte transp_color, byte color, word brush_width)
 /* On affiche la brosse en monochrome */
 {
-  byte* dest=y_pos*ZOOMY*VIDEO_LINE_WIDTH+x_pos*ZOOMX+Screen_pixels; // dest = adr destination à 
-      // l'écran
+  byte* dest=y_pos*ZOOMY*VIDEO_LINE_WIDTH+x_pos*ZOOMX+Screen_pixels; // dest = adr destination Ã  
+      // l'Ã©cran
   byte* src=brush_width*y_offset+x_offset+Brush; // src = adr ds 
       // la brosse
   int x,y;
@@ -216,7 +216,7 @@
       dest+=ZOOMX;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     src+=brush_width-width;
     dest+=VIDEO_LINE_WIDTH*ZOOMY-width*ZOOMX;
   }
@@ -225,8 +225,8 @@
 
 void Clear_brush_tall2(word x_pos,word y_pos,__attribute__((unused)) word x_offset,__attribute__((unused)) word y_offset,word width,word height,__attribute__((unused))byte transp_color,word image_width)
 {
-  byte* dest=Screen_pixels+x_pos*ZOOMX+y_pos*ZOOMY*VIDEO_LINE_WIDTH; //On va se mettre en 0,0 dans l'écran (dest)
-  byte* src = ( y_pos + Main_offset_Y ) * image_width + x_pos + Main_offset_X + Main_screen; //Coords de départ ds la source (src)
+  byte* dest=Screen_pixels+x_pos*ZOOMX+y_pos*ZOOMY*VIDEO_LINE_WIDTH; //On va se mettre en 0,0 dans l'Ã©cran (dest)
+  byte* src = ( y_pos + Main_offset_Y ) * image_width + x_pos + Main_offset_X + Main_screen; //Coords de dÃ©part ds la source (src)
   int y;
   int x;
 
@@ -243,17 +243,17 @@
       dest+=ZOOMX;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     src+=image_width-width;
     dest+=VIDEO_LINE_WIDTH*ZOOMY-width*ZOOMX;
   }
   Update_rect(x_pos,y_pos,width,height);
 }
 
-// Affiche une brosse (arbitraire) à l'écran
+// Affiche une brosse (arbitraire) Ã  l'Ã©cran
 void Display_brush_tall2(byte * brush, word x_pos,word y_pos,word x_offset,word y_offset,word width,word height,byte transp_color,word brush_width)
 {
-  // dest = Position à l'écran
+  // dest = Position Ã  l'Ã©cran
   byte* dest = Screen_pixels + y_pos * ZOOMY * VIDEO_LINE_WIDTH + x_pos * ZOOMX;
   // src = Position dans la brosse
   byte* src = brush + y_offset * brush_width + x_offset;
@@ -266,7 +266,7 @@
     // Pour chaque pixel
     for(x = width;x > 0; x--)
     {
-      // On vérifie que ce n'est pas la transparence
+      // On vÃ©rifie que ce n'est pas la transparence
       if(*src != transp_color)
       {
         *(dest+3*VIDEO_LINE_WIDTH+1)=*(dest+3*VIDEO_LINE_WIDTH)=*(dest+2*VIDEO_LINE_WIDTH+1)=*(dest+2*VIDEO_LINE_WIDTH)=*(dest+VIDEO_LINE_WIDTH+1)=*(dest+VIDEO_LINE_WIDTH)=*(dest+1)=*(dest)=*src;
@@ -276,7 +276,7 @@
       src++; dest+=ZOOMX;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     dest = dest + VIDEO_LINE_WIDTH*ZOOMY - width*ZOOMX;
     src = src + brush_width - width;
   }
@@ -284,7 +284,7 @@
 
 void Remap_screen_tall2(word x_pos,word y_pos,word width,word height,byte * conversion_table)
 {
-  // dest = coords a l'écran
+  // dest = coords a l'Ã©cran
   byte* dest = Screen_pixels + y_pos * ZOOMY * VIDEO_LINE_WIDTH + x_pos * ZOOMX;
   int x,y;
 
@@ -307,7 +307,7 @@
 
 void Display_line_on_screen_fast_tall2(word x_pos,word y_pos,word width,byte * line)
 /* On affiche toute une ligne de pixels telle quelle. */
-/* Utilisée si le buffer contient déja des pixel doublés. */
+/* UtilisÃ©e si le buffer contient dÃ©ja des pixel doublÃ©s. */
 {
   memcpy(Screen_pixels+x_pos*ZOOMX+y_pos*ZOOMY*VIDEO_LINE_WIDTH,line,width*ZOOMX);
   memcpy(Screen_pixels+x_pos*ZOOMX+(y_pos*ZOOMY+1)*VIDEO_LINE_WIDTH,line,width*ZOOMX);
@@ -331,8 +331,8 @@
 void Display_transparent_mono_line_on_screen_tall2(
         word x_pos, word y_pos, word width, byte* line, 
         byte transp_color, byte color)
-// Affiche une ligne à l'écran avec une couleur + transparence.
-// Utilisé par les brosses en mode zoom
+// Affiche une ligne Ã  l'Ã©cran avec une couleur + transparence.
+// UtilisÃ© par les brosses en mode zoom
 {
   byte* dest = Screen_pixels+ y_pos*VIDEO_LINE_WIDTH + x_pos*ZOOMX;
   int x;
@@ -354,31 +354,31 @@
 }
 
 void Display_part_of_screen_scaled_tall2(
-        word width, // width non zoomée
-        word height, // height zoomée
+        word width, // width non zoomÃ©e
+        word height, // height zoomÃ©e
         word image_width,byte * buffer)
 {
   byte* src = Main_screen + Main_magnifier_offset_Y * image_width 
                       + Main_magnifier_offset_X;
   int y = 0; // Ligne en cours de traitement
 
-  // Pour chaque ligne à zoomer
+  // Pour chaque ligne Ã  zoomer
   while(1)
   {
     int x;
     
-    // On éclate la ligne
+    // On Ã©clate la ligne
     Zoom_a_line(src,buffer,Main_magnifier_factor*ZOOMX,width);
-    // On l'affiche Facteur fois, sur des lignes consécutives
+    // On l'affiche Facteur fois, sur des lignes consÃ©cutives
     x = Main_magnifier_factor/**ZOOMY*/;
     // Pour chaque ligne
     do{
-      // On affiche la ligne zoomée
+      // On affiche la ligne zoomÃ©e
       Display_line_on_screen_fast_tall2(
         Main_X_zoom, y, width*Main_magnifier_factor,
         buffer
       );
-      // On passe à la suivante
+      // On passe Ã  la suivante
       y++;
       if(y==height/**ZOOMY*/)
       {
@@ -395,12 +395,12 @@
 // ATTENTION on n'arrive jamais ici !
 }
 
-// Affiche une partie de la brosse couleur zoomée
+// Affiche une partie de la brosse couleur zoomÃ©e
 void Display_brush_color_zoom_tall2(word x_pos,word y_pos,
         word x_offset,word y_offset,
-        word width, // width non zoomée
+        word width, // width non zoomÃ©e
         word end_y_pos,byte transp_color,
-        word brush_width, // width réelle de la brosse
+        word brush_width, // width rÃ©elle de la brosse
         byte * buffer)
 {
   byte* src = Brush+y_offset*brush_width + x_offset;
@@ -411,7 +411,7 @@
   while(1)
   {
     Zoom_a_line(src,buffer,Main_magnifier_factor,width);
-    // On affiche facteur fois la ligne zoomée
+    // On affiche facteur fois la ligne zoomÃ©e
     for(bx=Main_magnifier_factor;bx>0;bx--)
     {
       byte* line_src = buffer;
@@ -446,10 +446,10 @@
 
 void Display_brush_mono_zoom_tall2(word x_pos, word y_pos,
         word x_offset, word y_offset, 
-        word width, // width non zoomée 
+        word width, // width non zoomÃ©e 
         word end_y_pos,
         byte transp_color, byte color, 
-        word brush_width, // width réelle de la brosse
+        word brush_width, // width rÃ©elle de la brosse
         byte * buffer
 )
 
@@ -457,29 +457,29 @@
   byte* src = Brush + y_offset * brush_width + x_offset;
   int y=y_pos*ZOOMY;
 
-  //Pour chaque ligne à zoomer :
+  //Pour chaque ligne Ã  zoomer :
   while(1)
   {
     int bx;
     // src = Ligne originale
-    // On éclate la ligne
+    // On Ã©clate la ligne
     Zoom_a_line(src,buffer,Main_magnifier_factor,width);
 
-    // On affiche la ligne Facteur fois à l'écran (sur des
-    // lignes consécutives)
+    // On affiche la ligne Facteur fois Ã  l'Ã©cran (sur des
+    // lignes consÃ©cutives)
     bx = Main_magnifier_factor*ZOOMY;
 
-    // Pour chaque ligne écran
+    // Pour chaque ligne Ã©cran
     do
     {
-      // On affiche la ligne zoomée
+      // On affiche la ligne zoomÃ©e
       Display_transparent_mono_line_on_screen_tall2(
         x_pos, y, width * Main_magnifier_factor, 
         buffer, transp_color, color
       );
-      // On passe à la ligne suivante
+      // On passe Ã  la ligne suivante
       y++;
-      // On vérifie qu'on est pas à la ligne finale
+      // On vÃ©rifie qu'on est pas Ã  la ligne finale
       if(y == end_y_pos*ZOOMY)
       {
         Redraw_grid( x_pos, y_pos,
@@ -492,7 +492,7 @@
     }
     while (bx > 0);
     
-    // Passage à la ligne suivante dans la brosse aussi
+    // Passage Ã  la ligne suivante dans la brosse aussi
     src+=brush_width;
   }
 }
@@ -500,12 +500,12 @@
 void Clear_brush_scaled_tall2(word x_pos,word y_pos,word x_offset,word y_offset,word width,word end_y_pos,__attribute__((unused)) byte transp_color,word image_width,byte * buffer)
 {
 
-  // En fait on va recopier l'image non zoomée dans la partie zoomée !
+  // En fait on va recopier l'image non zoomÃ©e dans la partie zoomÃ©e !
   byte* src = Main_screen + y_offset * image_width + x_offset;
   int y = y_pos;
   int bx;
 
-  // Pour chaque ligne à zoomer
+  // Pour chaque ligne Ã  zoomer
   while(1){
     Zoom_a_line(src,buffer,Main_magnifier_factor*ZOOMX,width);
 
diff -ruN gfx2orig/src/pxtall.c grafx2/src/pxtall.c
--- gfx2orig/src/pxtall.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/pxtall.c	2022-03-20 20:19:34.108495316 -0500
@@ -39,20 +39,20 @@
 #endif
 
 void Pixel_tall (word x,word y,byte color)
-/* Affiche un pixel de la color aux coords x;y à l'écran */
+/* Affiche un pixel de la color aux coords x;y Ã  l'Ã©cran */
 {
   *(Screen_pixels + x + y*ZOOMY*VIDEO_LINE_WIDTH)=color;
   *(Screen_pixels + x + (y*ZOOMY+1)*VIDEO_LINE_WIDTH)=color;
 }
 
 byte Read_pixel_tall (word x,word y)
-/* On retourne la couleur du pixel aux coords données */
+/* On retourne la couleur du pixel aux coords donnÃ©es */
 {
   return *( Screen_pixels + y*ZOOMY*VIDEO_LINE_WIDTH + x );
 }
 
 void Block_tall (word start_x,word start_y,word width,word height,byte color)
-/* On affiche un rectangle de la couleur donnée */
+/* On affiche un rectangle de la couleur donnÃ©e */
 {
   SDL_Rect rectangle;
   rectangle.x=start_x;
@@ -63,10 +63,10 @@
 }
 
 void Display_part_of_screen_tall (word width,word height,word image_width)
-/* Afficher une partie de l'image telle quelle sur l'écran */
+/* Afficher une partie de l'image telle quelle sur l'Ã©cran */
 {
-  byte* dest=Screen_pixels; //On va se mettre en 0,0 dans l'écran (dest)
-  byte* src=Main_offset_Y*image_width+Main_offset_X+Main_screen; //Coords de départ ds la source (src)
+  byte* dest=Screen_pixels; //On va se mettre en 0,0 dans l'Ã©cran (dest)
+  byte* src=Main_offset_Y*image_width+Main_offset_X+Main_screen; //Coords de dÃ©part ds la source (src)
   int y;
 
   for(y=height;y!=0;y--)
@@ -77,7 +77,7 @@
     dest+=VIDEO_LINE_WIDTH;
     memcpy(dest,src,width);
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     src+=image_width;
     dest+=VIDEO_LINE_WIDTH;
   }
@@ -85,10 +85,10 @@
 }
 
 void Pixel_preview_normal_tall (word x,word y,byte color)
-/* Affichage d'un pixel dans l'écran, par rapport au décalage de l'image 
- * dans l'écran, en mode normal (pas en mode loupe)
- * Note: si on modifie cette procédure, il faudra penser à faire également 
- * la modif dans la procédure Pixel_Preview_Loupe_SDL. */
+/* Affichage d'un pixel dans l'Ã©cran, par rapport au dÃ©calage de l'image 
+ * dans l'Ã©cran, en mode normal (pas en mode loupe)
+ * Note: si on modifie cette procÃ©dure, il faudra penser Ã  faire Ã©galement 
+ * la modif dans la procÃ©dure Pixel_Preview_Loupe_SDL. */
 {
 //  if(x-Main_offset_X >= 0 && y - Main_offset_Y >= 0)
   Pixel_tall(x-Main_offset_X,y-Main_offset_Y,color);
@@ -96,10 +96,10 @@
 
 void Pixel_preview_magnifier_tall  (word x,word y,byte color)
 {
-  // Affiche le pixel dans la partie non zoomée
+  // Affiche le pixel dans la partie non zoomÃ©e
   Pixel_tall(x-Main_offset_X,y-Main_offset_Y,color);
   
-  // Regarde si on doit aussi l'afficher dans la partie zoomée
+  // Regarde si on doit aussi l'afficher dans la partie zoomÃ©e
   if (y >= Limit_top_zoom && y <= Limit_visible_bottom_zoom
           && x >= Limit_left_zoom && x <= Limit_visible_right_zoom)
   {
@@ -109,7 +109,7 @@
 
     if (Menu_Y - y_zoom < Main_magnifier_factor)
       // On ne doit dessiner qu'un morceau du pixel
-      // sinon on dépasse sur le menu
+      // sinon on dÃ©passe sur le menu
       height = Menu_Y - y_zoom;
     else
       height = Main_magnifier_factor;
@@ -149,7 +149,7 @@
 
 void Display_brush_color_tall(word x_pos,word y_pos,word x_offset,word y_offset,word width,word height,byte transp_color,word brush_width)
 {
-  // dest = Position à l'écran
+  // dest = Position Ã  l'Ã©cran
   byte* dest = Screen_pixels + y_pos*ZOOMY*VIDEO_LINE_WIDTH + x_pos;
   // src = Position dans la brosse
   byte* src = Brush + y_offset * brush_width + x_offset;
@@ -162,7 +162,7 @@
     // Pour chaque pixel
     for(x = width;x > 0; x--)
     {
-      // On vérifie que ce n'est pas la transparence
+      // On vÃ©rifie que ce n'est pas la transparence
       if(*src != transp_color)
       {
         *dest = *src;
@@ -173,7 +173,7 @@
       src++; dest++;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     dest = dest + ZOOMY*VIDEO_LINE_WIDTH - width;
     src = src + brush_width - width;
   }
@@ -185,8 +185,8 @@
         byte transp_color, byte color, word brush_width)
 /* On affiche la brosse en monochrome */
 {
-  byte* dest=y_pos*ZOOMY*VIDEO_LINE_WIDTH+x_pos+Screen_pixels; // dest = adr Destination à 
-      // l'écran
+  byte* dest=y_pos*ZOOMY*VIDEO_LINE_WIDTH+x_pos+Screen_pixels; // dest = adr Destination Ã  
+      // l'Ã©cran
   byte* src=brush_width*y_offset+x_offset+Brush; // src = adr ds 
       // la brosse
   int x,y;
@@ -208,7 +208,7 @@
       dest++;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     src+=brush_width-width;
     dest+=ZOOMY*VIDEO_LINE_WIDTH-width;
   }
@@ -217,8 +217,8 @@
 
 void Clear_brush_tall(word x_pos,word y_pos,__attribute__((unused)) word x_offset,__attribute__((unused)) word y_offset,word width,word height,__attribute__((unused))byte transp_color,word image_width)
 {
-  byte* dest=Screen_pixels+x_pos+y_pos*ZOOMY*VIDEO_LINE_WIDTH; //On va se mettre en 0,0 dans l'écran (dest)
-  byte* src = ( y_pos + Main_offset_Y ) * image_width + x_pos + Main_offset_X + Main_screen; //Coords de départ ds la source (src)
+  byte* dest=Screen_pixels+x_pos+y_pos*ZOOMY*VIDEO_LINE_WIDTH; //On va se mettre en 0,0 dans l'Ã©cran (dest)
+  byte* src = ( y_pos + Main_offset_Y ) * image_width + x_pos + Main_offset_X + Main_screen; //Coords de dÃ©part ds la source (src)
   int y;
 
   for(y=height;y!=0;y--)
@@ -229,17 +229,17 @@
     dest+=VIDEO_LINE_WIDTH;
     memcpy(dest,src,width);
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     src+=image_width;
     dest+=VIDEO_LINE_WIDTH;
   }
   Update_rect(x_pos,y_pos,width,height);
 }
 
-// Affiche une brosse (arbitraire) à l'écran
+// Affiche une brosse (arbitraire) Ã  l'Ã©cran
 void Display_brush_tall(byte * brush, word x_pos,word y_pos,word x_offset,word y_offset,word width,word height,byte transp_color,word brush_width)
 {
-  // dest = Position à l'écran
+  // dest = Position Ã  l'Ã©cran
   byte* dest = Screen_pixels + y_pos*ZOOMY*VIDEO_LINE_WIDTH + x_pos;
   // src = Position dans la brosse
   byte* src = brush + y_offset * brush_width + x_offset;
@@ -252,7 +252,7 @@
     // Pour chaque pixel
     for(x = width;x > 0; x--)
     {
-      // On vérifie que ce n'est pas la transparence
+      // On vÃ©rifie que ce n'est pas la transparence
       if(*src != transp_color)
       {
         *dest = *src;
@@ -263,7 +263,7 @@
       src++; dest++;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     dest = dest + VIDEO_LINE_WIDTH*ZOOMY - width;
     src = src + brush_width - width;
   }
@@ -271,7 +271,7 @@
 
 void Remap_screen_tall(word x_pos,word y_pos,word width,word height,byte * conversion_table)
 {
-  // dest = coords a l'écran
+  // dest = coords a l'Ã©cran
   byte* dest = Screen_pixels + y_pos*ZOOMY*VIDEO_LINE_WIDTH + x_pos;
   int x,y;
 
@@ -292,7 +292,7 @@
 }
 
 void Display_line_on_screen_tall(word x_pos,word y_pos,word width,byte * line)
-/* On affiche toute une ligne de pixels. Utilisé pour les textes. */
+/* On affiche toute une ligne de pixels. UtilisÃ© pour les textes. */
 {
   memcpy(Screen_pixels+x_pos+y_pos*ZOOMY*VIDEO_LINE_WIDTH,line,width);
   memcpy(Screen_pixels+x_pos+(y_pos*ZOOMY+1)*VIDEO_LINE_WIDTH,line,width);
@@ -304,31 +304,31 @@
 }
 
 void Display_part_of_screen_scaled_tall(
-        word width, // width non zoomée
-        word height, // height zoomée
+        word width, // width non zoomÃ©e
+        word height, // height zoomÃ©e
         word image_width,byte * buffer)
 {
   byte* src = Main_screen + Main_magnifier_offset_Y * image_width 
                       + Main_magnifier_offset_X;
   int y = 0; // Ligne en cours de traitement
 
-  // Pour chaque ligne à zoomer
+  // Pour chaque ligne Ã  zoomer
   while(1)
   {
     int x;
     
-    // On éclate la ligne
+    // On Ã©clate la ligne
     Zoom_a_line(src,buffer,Main_magnifier_factor,width);
-    // On l'affiche Facteur fois, sur des lignes consécutives
+    // On l'affiche Facteur fois, sur des lignes consÃ©cutives
     x = Main_magnifier_factor*ZOOMY;
     // Pour chaque ligne
     do{
-      // On affiche la ligne zoomée
+      // On affiche la ligne zoomÃ©e
       Display_line_on_screen_simple(
         Main_X_zoom, y, width*Main_magnifier_factor,
         buffer
       );
-      // On passe à la suivante
+      // On passe Ã  la suivante
       y++;
       if(y==height*ZOOMY)
       {
@@ -345,12 +345,12 @@
 // ATTENTION on n'arrive jamais ici !
 }
 
-// Affiche une partie de la brosse couleur zoomée
+// Affiche une partie de la brosse couleur zoomÃ©e
 void Display_brush_color_zoom_tall(word x_pos,word y_pos,
         word x_offset,word y_offset,
-        word width, // width non zoomée
+        word width, // width non zoomÃ©e
         word end_y_pos,byte transp_color,
-        word brush_width, // width réelle de la brosse
+        word brush_width, // width rÃ©elle de la brosse
         byte * buffer)
 {
   byte* src = Brush+y_offset*brush_width + x_offset;
@@ -361,7 +361,7 @@
   while(1)
   {
     Zoom_a_line(src,buffer,Main_magnifier_factor,width);
-    // On affiche facteur fois la ligne zoomée
+    // On affiche facteur fois la ligne zoomÃ©e
     for(bx=Main_magnifier_factor;bx>0;bx--)
     {
       Display_transparent_line_on_screen_simple(x_pos,y*ZOOMY,width*Main_magnifier_factor,buffer,transp_color);
@@ -379,10 +379,10 @@
 
 void Display_brush_mono_zoom_tall(word x_pos, word y_pos,
         word x_offset, word y_offset, 
-        word width, // width non zoomée 
+        word width, // width non zoomÃ©e 
         word end_y_pos,
         byte transp_color, byte color, 
-        word brush_width, // width réelle de la brosse
+        word brush_width, // width rÃ©elle de la brosse
         byte * buffer
 )
 
@@ -390,29 +390,29 @@
   byte* src = Brush + y_offset * brush_width + x_offset;
   int y=y_pos*ZOOMY;
 
-  //Pour chaque ligne à zoomer :
+  //Pour chaque ligne Ã  zoomer :
   while(1)
   {
     int bx;
     // src = Ligne originale
-    // On éclate la ligne
+    // On Ã©clate la ligne
     Zoom_a_line(src,buffer,Main_magnifier_factor,width);
 
-    // On affiche la ligne Facteur fois à l'écran (sur des
-    // lignes consécutives)
+    // On affiche la ligne Facteur fois Ã  l'Ã©cran (sur des
+    // lignes consÃ©cutives)
     bx = Main_magnifier_factor*ZOOMY;
 
-    // Pour chaque ligne écran
+    // Pour chaque ligne Ã©cran
     do
     {
-      // On affiche la ligne zoomée
+      // On affiche la ligne zoomÃ©e
       Display_transparent_mono_line_on_screen_simple(
         x_pos, y, width * Main_magnifier_factor, 
         buffer, transp_color, color
       );
-      // On passe à la ligne suivante
+      // On passe Ã  la ligne suivante
       y++;
-      // On vérifie qu'on est pas à la ligne finale
+      // On vÃ©rifie qu'on est pas Ã  la ligne finale
       if(y == end_y_pos*ZOOMY)
       {
         Redraw_grid( x_pos, y_pos,
@@ -425,19 +425,19 @@
     }
     while (bx > 0);
     
-    // Passage à la ligne suivante dans la brosse aussi
+    // Passage Ã  la ligne suivante dans la brosse aussi
     src+=brush_width;
   }
 }
 
 void Clear_brush_scaled_tall(word x_pos,word y_pos,word x_offset,word y_offset,word width,word end_y_pos,__attribute__((unused)) byte transp_color,word image_width,byte * buffer)
 {
-  // En fait on va recopier l'image non zoomée dans la partie zoomée !
+  // En fait on va recopier l'image non zoomÃ©e dans la partie zoomÃ©e !
   byte* src = Main_screen + y_offset * image_width + x_offset;
   int y = y_pos;
   int bx;
 
-  // Pour chaque ligne à zoomer
+  // Pour chaque ligne Ã  zoomer
   while(1){
     Zoom_a_line(src,buffer,Main_magnifier_factor,width);
 
diff -ruN gfx2orig/src/pxtriple.c grafx2/src/pxtriple.c
--- gfx2orig/src/pxtriple.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/pxtriple.c	2022-03-20 20:19:34.108495316 -0500
@@ -38,7 +38,7 @@
 #endif
 
 void Pixel_triple (word x,word y,byte color)
-/* Affiche un pixel de la color aux coords x;y à l'écran */
+/* Affiche un pixel de la color aux coords x;y Ã  l'Ã©cran */
 {
   *(Screen_pixels + x * ZOOMX + y*ZOOMY * VIDEO_LINE_WIDTH)=color;
   *(Screen_pixels + x * ZOOMX + y*ZOOMY * VIDEO_LINE_WIDTH + 1)=color;
@@ -52,13 +52,13 @@
 }
 
 byte Read_pixel_triple (word x,word y)
-/* On retourne la couleur du pixel aux coords données */
+/* On retourne la couleur du pixel aux coords donnÃ©es */
 {
   return *( Screen_pixels + y * ZOOMY * VIDEO_LINE_WIDTH + x * ZOOMX);
 }
 
 void Block_triple (word start_x,word start_y,word width,word height,byte color)
-/* On affiche un rectangle de la couleur donnée */
+/* On affiche un rectangle de la couleur donnÃ©e */
 {
   SDL_Rect rectangle;
   rectangle.x=start_x*ZOOMX;
@@ -69,10 +69,10 @@
 }
 
 void Display_part_of_screen_triple (word width,word height,word image_width)
-/* Afficher une partie de l'image telle quelle sur l'écran */
+/* Afficher une partie de l'image telle quelle sur l'Ã©cran */
 {
-  byte* dest=Screen_pixels; //On va se mettre en 0,0 dans l'écran (dest)
-  byte* src=Main_offset_Y*image_width+Main_offset_X+Main_screen; //Coords de départ ds la source (src)
+  byte* dest=Screen_pixels; //On va se mettre en 0,0 dans l'Ã©cran (dest)
+  byte* src=Main_offset_Y*image_width+Main_offset_X+Main_screen; //Coords de dÃ©part ds la source (src)
   int y;
   int dy;
 
@@ -91,7 +91,7 @@
     // On la triple
     memcpy(dest-width*ZOOMX+2*VIDEO_LINE_WIDTH,dest-width*ZOOMX,width*ZOOMX);
     
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     src+=image_width-width;
     dest+=VIDEO_LINE_WIDTH*ZOOMY - width*ZOOMX;
   }
@@ -99,10 +99,10 @@
 }
 
 void Pixel_preview_normal_triple (word x,word y,byte color)
-/* Affichage d'un pixel dans l'écran, par rapport au décalage de l'image 
- * dans l'écran, en mode normal (pas en mode loupe)
- * Note: si on modifie cette procédure, il faudra penser à faire également 
- * la modif dans la procédure Pixel_Preview_Loupe_SDL. */
+/* Affichage d'un pixel dans l'Ã©cran, par rapport au dÃ©calage de l'image 
+ * dans l'Ã©cran, en mode normal (pas en mode loupe)
+ * Note: si on modifie cette procÃ©dure, il faudra penser Ã  faire Ã©galement 
+ * la modif dans la procÃ©dure Pixel_Preview_Loupe_SDL. */
 {
 //  if(x-Main_offset_X >= 0 && y - Main_offset_Y >= 0)
   Pixel_triple(x-Main_offset_X,y-Main_offset_Y,color);
@@ -110,10 +110,10 @@
 
 void Pixel_preview_magnifier_triple  (word x,word y,byte color)
 {
-  // Affiche le pixel dans la partie non zoomée
+  // Affiche le pixel dans la partie non zoomÃ©e
   Pixel_triple(x-Main_offset_X,y-Main_offset_Y,color);
   
-  // Regarde si on doit aussi l'afficher dans la partie zoomée
+  // Regarde si on doit aussi l'afficher dans la partie zoomÃ©e
   if (y >= Limit_top_zoom && y <= Limit_visible_bottom_zoom
           && x >= Limit_left_zoom && x <= Limit_visible_right_zoom)
   {
@@ -123,7 +123,7 @@
 
     if (Menu_Y - y_zoom < Main_magnifier_factor)
       // On ne doit dessiner qu'un morceau du pixel
-      // sinon on dépasse sur le menu
+      // sinon on dÃ©passe sur le menu
       height = Menu_Y - y_zoom;
     else
       height = Main_magnifier_factor;
@@ -159,7 +159,7 @@
 
 void Display_brush_color_triple(word x_pos,word y_pos,word x_offset,word y_offset,word width,word height,byte transp_color,word brush_width)
 {
-  // dest = Position à l'écran
+  // dest = Position Ã  l'Ã©cran
   byte* dest = Screen_pixels + y_pos * ZOOMY * VIDEO_LINE_WIDTH + x_pos * ZOOMX;
   // src = Position dans la brosse
   byte* src = Brush + y_offset * brush_width + x_offset;
@@ -172,7 +172,7 @@
     // Pour chaque pixel
     for(x = width;x > 0; x--)
     {
-      // On vérifie que ce n'est pas la transparence
+      // On vÃ©rifie que ce n'est pas la transparence
       if(*src != transp_color)
       {
         *(dest+2*VIDEO_LINE_WIDTH+2) = *(dest+2*VIDEO_LINE_WIDTH+1) = *(dest+2*VIDEO_LINE_WIDTH) = *(dest+VIDEO_LINE_WIDTH+2) = *(dest+VIDEO_LINE_WIDTH+1) = *(dest+VIDEO_LINE_WIDTH) = *(dest+2) = *(dest+1) = *dest = *src;
@@ -183,7 +183,7 @@
       dest+=ZOOMX;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     dest = dest + VIDEO_LINE_WIDTH*ZOOMY - width*ZOOMX;
     src = src + brush_width - width;
   }
@@ -195,8 +195,8 @@
         byte transp_color, byte color, word brush_width)
 /* On affiche la brosse en monochrome */
 {
-  byte* dest=y_pos*ZOOMY*VIDEO_LINE_WIDTH+x_pos*ZOOMX+Screen_pixels; // dest = adr destination à 
-      // l'écran
+  byte* dest=y_pos*ZOOMY*VIDEO_LINE_WIDTH+x_pos*ZOOMX+Screen_pixels; // dest = adr destination Ã  
+      // l'Ã©cran
   byte* src=brush_width*y_offset+x_offset+Brush; // src = adr ds 
       // la brosse
   int x,y;
@@ -215,7 +215,7 @@
       dest+=ZOOMX;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     src+=brush_width-width;
     dest+=VIDEO_LINE_WIDTH*ZOOMY-width*ZOOMX;
   }
@@ -224,8 +224,8 @@
 
 void Clear_brush_triple(word x_pos,word y_pos,__attribute__((unused)) word x_offset,__attribute__((unused)) word y_offset,word width,word height,__attribute__((unused))byte transp_color,word image_width)
 {
-  byte* dest=Screen_pixels+x_pos*ZOOMX+y_pos*ZOOMY*VIDEO_LINE_WIDTH; //On va se mettre en 0,0 dans l'écran (dest)
-  byte* src = ( y_pos + Main_offset_Y ) * image_width + x_pos + Main_offset_X + Main_screen; //Coords de départ ds la source (src)
+  byte* dest=Screen_pixels+x_pos*ZOOMX+y_pos*ZOOMY*VIDEO_LINE_WIDTH; //On va se mettre en 0,0 dans l'Ã©cran (dest)
+  byte* src = ( y_pos + Main_offset_Y ) * image_width + x_pos + Main_offset_X + Main_screen; //Coords de dÃ©part ds la source (src)
   int y;
   int x;
 
@@ -242,17 +242,17 @@
       dest+=ZOOMX;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     src+=image_width-width;
     dest+=VIDEO_LINE_WIDTH*ZOOMY-width*ZOOMX;
   }
   Update_rect(x_pos,y_pos,width,height);
 }
 
-// Affiche une brosse (arbitraire) à l'écran
+// Affiche une brosse (arbitraire) Ã  l'Ã©cran
 void Display_brush_triple(byte * brush, word x_pos,word y_pos,word x_offset,word y_offset,word width,word height,byte transp_color,word brush_width)
 {
-  // dest = Position à l'écran
+  // dest = Position Ã  l'Ã©cran
   byte* dest = Screen_pixels + y_pos * ZOOMY * VIDEO_LINE_WIDTH + x_pos * ZOOMX;
   // src = Position dans la brosse
   byte* src = brush + y_offset * brush_width + x_offset;
@@ -265,7 +265,7 @@
     // Pour chaque pixel
     for(x = width;x > 0; x--)
     {
-      // On vérifie que ce n'est pas la transparence
+      // On vÃ©rifie que ce n'est pas la transparence
       if(*src != transp_color)
       {
         *(dest+2*VIDEO_LINE_WIDTH+2)=*(dest+2*VIDEO_LINE_WIDTH+1)=*(dest+2*VIDEO_LINE_WIDTH)=*(dest+VIDEO_LINE_WIDTH+2)=*(dest+VIDEO_LINE_WIDTH+1)=*(dest+VIDEO_LINE_WIDTH)=*(dest+2)=*(dest+1)=*dest=*src;
@@ -275,7 +275,7 @@
       src++; dest+=ZOOMX;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     dest = dest + VIDEO_LINE_WIDTH*ZOOMY - width*ZOOMX;
     src = src + brush_width - width;
   }
@@ -283,7 +283,7 @@
 
 void Remap_screen_triple(word x_pos,word y_pos,word width,word height,byte * conversion_table)
 {
-  // dest = coords a l'écran
+  // dest = coords a l'Ã©cran
   byte* dest = Screen_pixels + y_pos * ZOOMY * VIDEO_LINE_WIDTH + x_pos * ZOOMX;
   int x,y;
 
@@ -306,7 +306,7 @@
 
 void Display_line_on_screen_fast_triple(word x_pos,word y_pos,word width,byte * line)
 /* On affiche toute une ligne de pixels telle quelle. */
-/* Utilisée si le buffer contient déja des pixel doublés. */
+/* UtilisÃ©e si le buffer contient dÃ©ja des pixel doublÃ©s. */
 {
   memcpy(Screen_pixels+x_pos*ZOOMX+y_pos*ZOOMY*VIDEO_LINE_WIDTH,line,width*ZOOMX);
   memcpy(Screen_pixels+x_pos*ZOOMX+(y_pos*ZOOMY+1)*VIDEO_LINE_WIDTH,line,width*ZOOMX);
@@ -329,8 +329,8 @@
 void Display_transparent_mono_line_on_screen_triple(
         word x_pos, word y_pos, word width, byte* line, 
         byte transp_color, byte color)
-// Affiche une ligne à l'écran avec une couleur + transparence.
-// Utilisé par les brosses en mode zoom
+// Affiche une ligne Ã  l'Ã©cran avec une couleur + transparence.
+// UtilisÃ© par les brosses en mode zoom
 {
   byte* dest = Screen_pixels+ y_pos*VIDEO_LINE_WIDTH + x_pos*ZOOMX;
   int x;
@@ -352,31 +352,31 @@
 }
 
 void Display_part_of_screen_scaled_triple(
-        word width, // width non zoomée
-        word height, // height zoomée
+        word width, // width non zoomÃ©e
+        word height, // height zoomÃ©e
         word image_width,byte * buffer)
 {
   byte* src = Main_screen + Main_magnifier_offset_Y * image_width 
                       + Main_magnifier_offset_X;
   int y = 0; // Ligne en cours de traitement
 
-  // Pour chaque ligne à zoomer
+  // Pour chaque ligne Ã  zoomer
   while(1)
   {
     int x;
     
-    // On éclate la ligne
+    // On Ã©clate la ligne
     Zoom_a_line(src,buffer,Main_magnifier_factor*ZOOMX,width);
-    // On l'affiche Facteur fois, sur des lignes consécutives
+    // On l'affiche Facteur fois, sur des lignes consÃ©cutives
     x = Main_magnifier_factor/**ZOOMY*/;
     // Pour chaque ligne
     do{
-      // On affiche la ligne zoomée
+      // On affiche la ligne zoomÃ©e
       Display_line_on_screen_fast_triple(
         Main_X_zoom, y, width*Main_magnifier_factor,
         buffer
       );
-      // On passe à la suivante
+      // On passe Ã  la suivante
       y++;
       if(y==height/**ZOOMY*/)
       {
@@ -393,12 +393,12 @@
 // ATTENTION on n'arrive jamais ici !
 }
 
-// Affiche une partie de la brosse couleur zoomée
+// Affiche une partie de la brosse couleur zoomÃ©e
 void Display_brush_color_zoom_triple(word x_pos,word y_pos,
         word x_offset,word y_offset,
-        word width, // width non zoomée
+        word width, // width non zoomÃ©e
         word end_y_pos,byte transp_color,
-        word brush_width, // width réelle de la brosse
+        word brush_width, // width rÃ©elle de la brosse
         byte * buffer)
 {
   byte* src = Brush+y_offset*brush_width + x_offset;
@@ -409,7 +409,7 @@
   while(1)
   {
     Zoom_a_line(src,buffer,Main_magnifier_factor,width);
-    // On affiche facteur fois la ligne zoomée
+    // On affiche facteur fois la ligne zoomÃ©e
     for(bx=Main_magnifier_factor;bx>0;bx--)
     {
       byte* line_src = buffer;
@@ -442,10 +442,10 @@
 
 void Display_brush_mono_zoom_triple(word x_pos, word y_pos,
         word x_offset, word y_offset, 
-        word width, // width non zoomée 
+        word width, // width non zoomÃ©e 
         word end_y_pos,
         byte transp_color, byte color, 
-        word brush_width, // width réelle de la brosse
+        word brush_width, // width rÃ©elle de la brosse
         byte * buffer
 )
 
@@ -453,29 +453,29 @@
   byte* src = Brush + y_offset * brush_width + x_offset;
   int y=y_pos*ZOOMY;
 
-  //Pour chaque ligne à zoomer :
+  //Pour chaque ligne Ã  zoomer :
   while(1)
   {
     int bx;
     // src = Ligne originale
-    // On éclate la ligne
+    // On Ã©clate la ligne
     Zoom_a_line(src,buffer,Main_magnifier_factor,width);
 
-    // On affiche la ligne Facteur fois à l'écran (sur des
-    // lignes consécutives)
+    // On affiche la ligne Facteur fois Ã  l'Ã©cran (sur des
+    // lignes consÃ©cutives)
     bx = Main_magnifier_factor*ZOOMY;
 
-    // Pour chaque ligne écran
+    // Pour chaque ligne Ã©cran
     do
     {
-      // On affiche la ligne zoomée
+      // On affiche la ligne zoomÃ©e
       Display_transparent_mono_line_on_screen_triple(
         x_pos, y, width * Main_magnifier_factor, 
         buffer, transp_color, color
       );
-      // On passe à la ligne suivante
+      // On passe Ã  la ligne suivante
       y++;
-      // On vérifie qu'on est pas à la ligne finale
+      // On vÃ©rifie qu'on est pas Ã  la ligne finale
       if(y == end_y_pos*ZOOMY)
       {
         Redraw_grid( x_pos, y_pos,
@@ -488,7 +488,7 @@
     }
     while (bx > 0);
     
-    // Passage à la ligne suivante dans la brosse aussi
+    // Passage Ã  la ligne suivante dans la brosse aussi
     src+=brush_width;
   }
 }
@@ -496,12 +496,12 @@
 void Clear_brush_scaled_triple(word x_pos,word y_pos,word x_offset,word y_offset,word width,word end_y_pos,__attribute__((unused)) byte transp_color,word image_width,byte * buffer)
 {
 
-  // En fait on va recopier l'image non zoomée dans la partie zoomée !
+  // En fait on va recopier l'image non zoomÃ©e dans la partie zoomÃ©e !
   byte* src = Main_screen + y_offset * image_width + x_offset;
   int y = y_pos;
   int bx;
 
-  // Pour chaque ligne à zoomer
+  // Pour chaque ligne Ã  zoomer
   while(1){
     Zoom_a_line(src,buffer,Main_magnifier_factor*ZOOMX,width);
 
diff -ruN gfx2orig/src/pxwide2.c grafx2/src/pxwide2.c
--- gfx2orig/src/pxwide2.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/pxwide2.c	2022-03-20 20:19:34.108495316 -0500
@@ -38,7 +38,7 @@
 #endif
 
 void Pixel_wide2 (word x,word y,byte color)
-/* Affiche un pixel de la color aux coords x;y à l'écran */
+/* Affiche un pixel de la color aux coords x;y Ã  l'Ã©cran */
 {
   *(Screen_pixels + x * ZOOMX + y*ZOOMY * VIDEO_LINE_WIDTH)=color;
   *(Screen_pixels + x * ZOOMX + y*ZOOMY * VIDEO_LINE_WIDTH + 1)=color;
@@ -51,13 +51,13 @@
 }
 
 byte Read_pixel_wide2 (word x,word y)
-/* On retourne la couleur du pixel aux coords données */
+/* On retourne la couleur du pixel aux coords donnÃ©es */
 {
   return *( Screen_pixels + y * ZOOMY * VIDEO_LINE_WIDTH + x * ZOOMX);
 }
 
 void Block_wide2 (word start_x,word start_y,word width,word height,byte color)
-/* On affiche un rectangle de la couleur donnée */
+/* On affiche un rectangle de la couleur donnÃ©e */
 {
   SDL_Rect rectangle;
   rectangle.x=start_x*ZOOMX;
@@ -68,10 +68,10 @@
 }
 
 void Display_part_of_screen_wide2 (word width,word height,word image_width)
-/* Afficher une partie de l'image telle quelle sur l'écran */
+/* Afficher une partie de l'image telle quelle sur l'Ã©cran */
 {
-  byte* dest=Screen_pixels; //On va se mettre en 0,0 dans l'écran (dest)
-  byte* src=Main_offset_Y*image_width+Main_offset_X+Main_screen; //Coords de départ ds la source (src)
+  byte* dest=Screen_pixels; //On va se mettre en 0,0 dans l'Ã©cran (dest)
+  byte* src=Main_offset_Y*image_width+Main_offset_X+Main_screen; //Coords de dÃ©part ds la source (src)
   int y;
   int dy;
 
@@ -88,7 +88,7 @@
     // On double la ligne qu'on vient de copier
     memcpy(dest-width*ZOOMX+VIDEO_LINE_WIDTH,dest-width*ZOOMX,width*ZOOMX);
     
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     src+=image_width-width;
     dest+=VIDEO_LINE_WIDTH*ZOOMY - width*ZOOMX;
   }
@@ -96,10 +96,10 @@
 }
 
 void Pixel_preview_normal_wide2 (word x,word y,byte color)
-/* Affichage d'un pixel dans l'écran, par rapport au décalage de l'image 
- * dans l'écran, en mode normal (pas en mode loupe)
- * Note: si on modifie cette procédure, il faudra penser à faire également 
- * la modif dans la procédure Pixel_Preview_Loupe_SDL. */
+/* Affichage d'un pixel dans l'Ã©cran, par rapport au dÃ©calage de l'image 
+ * dans l'Ã©cran, en mode normal (pas en mode loupe)
+ * Note: si on modifie cette procÃ©dure, il faudra penser Ã  faire Ã©galement 
+ * la modif dans la procÃ©dure Pixel_Preview_Loupe_SDL. */
 {
 //  if(x-Main_offset_X >= 0 && y - Main_offset_Y >= 0)
   Pixel_wide2(x-Main_offset_X,y-Main_offset_Y,color);
@@ -107,10 +107,10 @@
 
 void Pixel_preview_magnifier_wide2  (word x,word y,byte color)
 {
-  // Affiche le pixel dans la partie non zoomée
+  // Affiche le pixel dans la partie non zoomÃ©e
   Pixel_wide2(x-Main_offset_X,y-Main_offset_Y,color);
   
-  // Regarde si on doit aussi l'afficher dans la partie zoomée
+  // Regarde si on doit aussi l'afficher dans la partie zoomÃ©e
   if (y >= Limit_top_zoom && y <= Limit_visible_bottom_zoom
           && x >= Limit_left_zoom && x <= Limit_visible_right_zoom)
   {
@@ -120,7 +120,7 @@
 
     if (Menu_Y - y_zoom < Main_magnifier_factor)
       // On ne doit dessiner qu'un morceau du pixel
-      // sinon on dépasse sur le menu
+      // sinon on dÃ©passe sur le menu
       height = Menu_Y - y_zoom;
     else
       height = Main_magnifier_factor;
@@ -156,7 +156,7 @@
 
 void Display_brush_color_wide2(word x_pos,word y_pos,word x_offset,word y_offset,word width,word height,byte transp_color,word brush_width)
 {
-  // dest = Position à l'écran
+  // dest = Position Ã  l'Ã©cran
   byte* dest = Screen_pixels + y_pos * ZOOMY * VIDEO_LINE_WIDTH + x_pos * ZOOMX;
   // src = Position dans la brosse
   byte* src = Brush + y_offset * brush_width + x_offset;
@@ -169,7 +169,7 @@
     // Pour chaque pixel
     for(x = width;x > 0; x--)
     {
-      // On vérifie que ce n'est pas la transparence
+      // On vÃ©rifie que ce n'est pas la transparence
       if(*src != transp_color)
       {
         *(dest+VIDEO_LINE_WIDTH+3) = *(dest+VIDEO_LINE_WIDTH+2) = *(dest+VIDEO_LINE_WIDTH+1) = *(dest+VIDEO_LINE_WIDTH) = *(dest+3) = *(dest+2) = *(dest+1) = *dest = *src;
@@ -180,7 +180,7 @@
       dest+=ZOOMX;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     dest = dest + VIDEO_LINE_WIDTH*ZOOMY - width*ZOOMX;
     src = src + brush_width - width;
   }
@@ -192,8 +192,8 @@
         byte transp_color, byte color, word brush_width)
 /* On affiche la brosse en monochrome */
 {
-  byte* dest=y_pos*ZOOMY*VIDEO_LINE_WIDTH+x_pos*ZOOMX+Screen_pixels; // dest = adr destination à 
-      // l'écran
+  byte* dest=y_pos*ZOOMY*VIDEO_LINE_WIDTH+x_pos*ZOOMX+Screen_pixels; // dest = adr destination Ã  
+      // l'Ã©cran
   byte* src=brush_width*y_offset+x_offset+Brush; // src = adr ds 
       // la brosse
   int x,y;
@@ -212,7 +212,7 @@
       dest+=ZOOMX;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     src+=brush_width-width;
     dest+=VIDEO_LINE_WIDTH*ZOOMY-width*ZOOMX;
   }
@@ -221,8 +221,8 @@
 
 void Clear_brush_wide2(word x_pos,word y_pos,__attribute__((unused)) word x_offset,__attribute__((unused)) word y_offset,word width,word height,__attribute__((unused))byte transp_color,word image_width)
 {
-  byte* dest=Screen_pixels+x_pos*ZOOMX+y_pos*ZOOMY*VIDEO_LINE_WIDTH; //On va se mettre en 0,0 dans l'écran (dest)
-  byte* src = ( y_pos + Main_offset_Y ) * image_width + x_pos + Main_offset_X + Main_screen; //Coords de départ ds la source (src)
+  byte* dest=Screen_pixels+x_pos*ZOOMX+y_pos*ZOOMY*VIDEO_LINE_WIDTH; //On va se mettre en 0,0 dans l'Ã©cran (dest)
+  byte* src = ( y_pos + Main_offset_Y ) * image_width + x_pos + Main_offset_X + Main_screen; //Coords de dÃ©part ds la source (src)
   int y;
   int x;
 
@@ -239,17 +239,17 @@
       dest+=ZOOMX;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     src+=image_width-width;
     dest+=VIDEO_LINE_WIDTH*ZOOMY-width*ZOOMX;
   }
   Update_rect(x_pos,y_pos,width,height);
 }
 
-// Affiche une brosse (arbitraire) à l'écran
+// Affiche une brosse (arbitraire) Ã  l'Ã©cran
 void Display_brush_wide2(byte * brush, word x_pos,word y_pos,word x_offset,word y_offset,word width,word height,byte transp_color,word brush_width)
 {
-  // dest = Position à l'écran
+  // dest = Position Ã  l'Ã©cran
   byte* dest = Screen_pixels + y_pos * ZOOMY * VIDEO_LINE_WIDTH + x_pos * ZOOMX;
   // src = Position dans la brosse
   byte* src = brush + y_offset * brush_width + x_offset;
@@ -262,7 +262,7 @@
     // Pour chaque pixel
     for(x = width;x > 0; x--)
     {
-      // On vérifie que ce n'est pas la transparence
+      // On vÃ©rifie que ce n'est pas la transparence
       if(*src != transp_color)
       {
         *(dest+VIDEO_LINE_WIDTH+3)=*(dest+VIDEO_LINE_WIDTH+2)=*(dest+VIDEO_LINE_WIDTH+1)=*(dest+VIDEO_LINE_WIDTH)=*(dest+3)=*(dest+2)=*(dest+1)=*dest=*src;
@@ -272,7 +272,7 @@
       src++; dest+=ZOOMX;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     dest = dest + VIDEO_LINE_WIDTH*ZOOMY - width*ZOOMX;
     src = src + brush_width - width;
   }
@@ -280,7 +280,7 @@
 
 void Remap_screen_wide2(word x_pos,word y_pos,word width,word height,byte * conversion_table)
 {
-  // dest = coords a l'écran
+  // dest = coords a l'Ã©cran
   byte* dest = Screen_pixels + y_pos * ZOOMY * VIDEO_LINE_WIDTH + x_pos * ZOOMX;
   int x,y;
 
@@ -303,7 +303,7 @@
 
 void Display_line_on_screen_fast_wide2(word x_pos,word y_pos,word width,byte * line)
 /* On affiche toute une ligne de pixels telle quelle. */
-/* Utilisée si le buffer contient déja des pixel doublés. */
+/* UtilisÃ©e si le buffer contient dÃ©ja des pixel doublÃ©s. */
 {
   memcpy(Screen_pixels+x_pos*ZOOMX+y_pos*ZOOMY*VIDEO_LINE_WIDTH,line,width*ZOOMX);
   memcpy(Screen_pixels+x_pos*ZOOMX+(y_pos*ZOOMY+1)*VIDEO_LINE_WIDTH,line,width*ZOOMX);
@@ -325,8 +325,8 @@
 void Display_transparent_mono_line_on_screen_wide2(
         word x_pos, word y_pos, word width, byte* line, 
         byte transp_color, byte color)
-// Affiche une ligne à l'écran avec une couleur + transparence.
-// Utilisé par les brosses en mode zoom
+// Affiche une ligne Ã  l'Ã©cran avec une couleur + transparence.
+// UtilisÃ© par les brosses en mode zoom
 {
   byte* dest = Screen_pixels+ y_pos*VIDEO_LINE_WIDTH + x_pos*ZOOMX;
   int x;
@@ -348,31 +348,31 @@
 }
 
 void Display_part_of_screen_scaled_wide2(
-        word width, // width non zoomée
-        word height, // height zoomée
+        word width, // width non zoomÃ©e
+        word height, // height zoomÃ©e
         word image_width,byte * buffer)
 {
   byte* src = Main_screen + Main_magnifier_offset_Y * image_width 
                       + Main_magnifier_offset_X;
   int y = 0; // Ligne en cours de traitement
 
-  // Pour chaque ligne à zoomer
+  // Pour chaque ligne Ã  zoomer
   while(1)
   {
     int x;
     
-    // On éclate la ligne
+    // On Ã©clate la ligne
     Zoom_a_line(src,buffer,Main_magnifier_factor*ZOOMX,width);
-    // On l'affiche Facteur fois, sur des lignes consécutives
+    // On l'affiche Facteur fois, sur des lignes consÃ©cutives
     x = Main_magnifier_factor/**ZOOMY*/;
     // Pour chaque ligne
     do{
-      // On affiche la ligne zoomée
+      // On affiche la ligne zoomÃ©e
       Display_line_on_screen_fast_wide2(
         Main_X_zoom, y, width*Main_magnifier_factor,
         buffer
       );
-      // On passe à la suivante
+      // On passe Ã  la suivante
       y++;
       if(y==height/**ZOOMY*/)
       {
@@ -389,12 +389,12 @@
 // ATTENTION on n'arrive jamais ici !
 }
 
-// Affiche une partie de la brosse couleur zoomée
+// Affiche une partie de la brosse couleur zoomÃ©e
 void Display_brush_color_zoom_wide2(word x_pos,word y_pos,
         word x_offset,word y_offset,
-        word width, // width non zoomée
+        word width, // width non zoomÃ©e
         word end_y_pos,byte transp_color,
-        word brush_width, // width réelle de la brosse
+        word brush_width, // width rÃ©elle de la brosse
         byte * buffer)
 {
   byte* src = Brush+y_offset*brush_width + x_offset;
@@ -405,7 +405,7 @@
   while(1)
   {
     Zoom_a_line(src,buffer,Main_magnifier_factor,width);
-    // On affiche facteur fois la ligne zoomée
+    // On affiche facteur fois la ligne zoomÃ©e
     for(bx=Main_magnifier_factor;bx>0;bx--)
     {
       byte* line_src = buffer;
@@ -436,10 +436,10 @@
 
 void Display_brush_mono_zoom_wide2(word x_pos, word y_pos,
         word x_offset, word y_offset, 
-        word width, // width non zoomée 
+        word width, // width non zoomÃ©e 
         word end_y_pos,
         byte transp_color, byte color, 
-        word brush_width, // width réelle de la brosse
+        word brush_width, // width rÃ©elle de la brosse
         byte * buffer
 )
 
@@ -447,29 +447,29 @@
   byte* src = Brush + y_offset * brush_width + x_offset;
   int y=y_pos*ZOOMY;
 
-  //Pour chaque ligne à zoomer :
+  //Pour chaque ligne Ã  zoomer :
   while(1)
   {
     int bx;
     // src = Ligne originale
-    // On éclate la ligne
+    // On Ã©clate la ligne
     Zoom_a_line(src,buffer,Main_magnifier_factor,width);
 
-    // On affiche la ligne Facteur fois à l'écran (sur des
-    // lignes consécutives)
+    // On affiche la ligne Facteur fois Ã  l'Ã©cran (sur des
+    // lignes consÃ©cutives)
     bx = Main_magnifier_factor*ZOOMY;
 
-    // Pour chaque ligne écran
+    // Pour chaque ligne Ã©cran
     do
     {
-      // On affiche la ligne zoomée
+      // On affiche la ligne zoomÃ©e
       Display_transparent_mono_line_on_screen_wide2(
         x_pos, y, width * Main_magnifier_factor, 
         buffer, transp_color, color
       );
-      // On passe à la ligne suivante
+      // On passe Ã  la ligne suivante
       y++;
-      // On vérifie qu'on est pas à la ligne finale
+      // On vÃ©rifie qu'on est pas Ã  la ligne finale
       if(y == end_y_pos*ZOOMY)
       {
         Redraw_grid( x_pos, y_pos,
@@ -482,7 +482,7 @@
     }
     while (bx > 0);
     
-    // Passage à la ligne suivante dans la brosse aussi
+    // Passage Ã  la ligne suivante dans la brosse aussi
     src+=brush_width;
   }
 }
@@ -490,12 +490,12 @@
 void Clear_brush_scaled_wide2(word x_pos,word y_pos,word x_offset,word y_offset,word width,word end_y_pos,__attribute__((unused)) byte transp_color,word image_width,byte * buffer)
 {
 
-  // En fait on va recopier l'image non zoomée dans la partie zoomée !
+  // En fait on va recopier l'image non zoomÃ©e dans la partie zoomÃ©e !
   byte* src = Main_screen + y_offset * image_width + x_offset;
   int y = y_pos;
   int bx;
 
-  // Pour chaque ligne à zoomer
+  // Pour chaque ligne Ã  zoomer
   while(1){
     Zoom_a_line(src,buffer,Main_magnifier_factor*ZOOMX,width);
 
diff -ruN gfx2orig/src/pxwide.c grafx2/src/pxwide.c
--- gfx2orig/src/pxwide.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/pxwide.c	2022-03-20 20:19:34.108495316 -0500
@@ -38,20 +38,20 @@
 #endif
 
 void Pixel_wide (word x,word y,byte color)
-/* Affiche un pixel de la color aux coords x;y à l'écran */
+/* Affiche un pixel de la color aux coords x;y Ã  l'Ã©cran */
 {
   *(Screen_pixels + x * ZOOMX + y*ZOOMY * VIDEO_LINE_WIDTH)=color;
   *(Screen_pixels + x * ZOOMX + y*ZOOMY * VIDEO_LINE_WIDTH + 1)=color;
 }
 
 byte Read_pixel_wide (word x,word y)
-/* On retourne la couleur du pixel aux coords données */
+/* On retourne la couleur du pixel aux coords donnÃ©es */
 {
   return *( Screen_pixels + y * ZOOMY * VIDEO_LINE_WIDTH + x * ZOOMX);
 }
 
 void Block_wide (word start_x,word start_y,word width,word height,byte color)
-/* On affiche un rectangle de la couleur donnée */
+/* On affiche un rectangle de la couleur donnÃ©e */
 {
   SDL_Rect rectangle;
   rectangle.x=start_x*ZOOMX;
@@ -62,10 +62,10 @@
 }
 
 void Display_part_of_screen_wide (word width,word height,word image_width)
-/* Afficher une partie de l'image telle quelle sur l'écran */
+/* Afficher une partie de l'image telle quelle sur l'Ã©cran */
 {
-  byte* dest=Screen_pixels; //On va se mettre en 0,0 dans l'écran (dest)
-  byte* src=Main_offset_Y*image_width+Main_offset_X+Main_screen; //Coords de départ ds la source (src)
+  byte* dest=Screen_pixels; //On va se mettre en 0,0 dans l'Ã©cran (dest)
+  byte* src=Main_offset_Y*image_width+Main_offset_X+Main_screen; //Coords de dÃ©part ds la source (src)
   int y;
   int dy;
 
@@ -80,7 +80,7 @@
       dest+=ZOOMX;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     src+=image_width-width;
     dest+=VIDEO_LINE_WIDTH*ZOOMY - width*ZOOMX;
   }
@@ -88,10 +88,10 @@
 }
 
 void Pixel_preview_normal_wide (word x,word y,byte color)
-/* Affichage d'un pixel dans l'écran, par rapport au décalage de l'image 
- * dans l'écran, en mode normal (pas en mode loupe)
- * Note: si on modifie cette procédure, il faudra penser à faire également 
- * la modif dans la procédure Pixel_Preview_Loupe_SDL. */
+/* Affichage d'un pixel dans l'Ã©cran, par rapport au dÃ©calage de l'image 
+ * dans l'Ã©cran, en mode normal (pas en mode loupe)
+ * Note: si on modifie cette procÃ©dure, il faudra penser Ã  faire Ã©galement 
+ * la modif dans la procÃ©dure Pixel_Preview_Loupe_SDL. */
 {
 //  if(x-Main_offset_X >= 0 && y - Main_offset_Y >= 0)
   Pixel_wide(x-Main_offset_X,y-Main_offset_Y,color);
@@ -99,10 +99,10 @@
 
 void Pixel_preview_magnifier_wide  (word x,word y,byte color)
 {
-  // Affiche le pixel dans la partie non zoomée
+  // Affiche le pixel dans la partie non zoomÃ©e
   Pixel_wide(x-Main_offset_X,y-Main_offset_Y,color);
   
-  // Regarde si on doit aussi l'afficher dans la partie zoomée
+  // Regarde si on doit aussi l'afficher dans la partie zoomÃ©e
   if (y >= Limit_top_zoom && y <= Limit_visible_bottom_zoom
           && x >= Limit_left_zoom && x <= Limit_visible_right_zoom)
   {
@@ -112,7 +112,7 @@
 
     if (Menu_Y - y_zoom < Main_magnifier_factor)
       // On ne doit dessiner qu'un morceau du pixel
-      // sinon on dépasse sur le menu
+      // sinon on dÃ©passe sur le menu
       height = Menu_Y - y_zoom;
     else
       height = Main_magnifier_factor;
@@ -148,7 +148,7 @@
 
 void Display_brush_color_wide(word x_pos,word y_pos,word x_offset,word y_offset,word width,word height,byte transp_color,word brush_width)
 {
-  // dest = Position à l'écran
+  // dest = Position Ã  l'Ã©cran
   byte* dest = Screen_pixels + y_pos * ZOOMY * VIDEO_LINE_WIDTH + x_pos * ZOOMX;
   // src = Position dans la brosse
   byte* src = Brush + y_offset * brush_width + x_offset;
@@ -161,7 +161,7 @@
     // Pour chaque pixel
     for(x = width;x > 0; x--)
     {
-      // On vérifie que ce n'est pas la transparence
+      // On vÃ©rifie que ce n'est pas la transparence
       if(*src != transp_color)
       {
         *(dest+1) = *dest = *src;
@@ -172,7 +172,7 @@
       dest+=ZOOMX;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     dest = dest + VIDEO_LINE_WIDTH*ZOOMY - width*ZOOMX;
     src = src + brush_width - width;
   }
@@ -184,8 +184,8 @@
         byte transp_color, byte color, word brush_width)
 /* On affiche la brosse en monochrome */
 {
-  byte* dest=y_pos*ZOOMY*VIDEO_LINE_WIDTH+x_pos*ZOOMX+Screen_pixels; // dest = adr destination à 
-      // l'écran
+  byte* dest=y_pos*ZOOMY*VIDEO_LINE_WIDTH+x_pos*ZOOMX+Screen_pixels; // dest = adr destination Ã  
+      // l'Ã©cran
   byte* src=brush_width*y_offset+x_offset+Brush; // src = adr ds 
       // la brosse
   int x,y;
@@ -204,7 +204,7 @@
       dest+=ZOOMX;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     src+=brush_width-width;
     dest+=VIDEO_LINE_WIDTH*ZOOMY-width*ZOOMX;
   }
@@ -213,8 +213,8 @@
 
 void Clear_brush_wide(word x_pos,word y_pos,__attribute__((unused)) word x_offset,__attribute__((unused)) word y_offset,word width,word height,__attribute__((unused))byte transp_color,word image_width)
 {
-  byte* dest=Screen_pixels+x_pos*ZOOMX+y_pos*ZOOMY*VIDEO_LINE_WIDTH; //On va se mettre en 0,0 dans l'écran (dest)
-  byte* src = ( y_pos + Main_offset_Y ) * image_width + x_pos + Main_offset_X + Main_screen; //Coords de départ ds la source (src)
+  byte* dest=Screen_pixels+x_pos*ZOOMX+y_pos*ZOOMY*VIDEO_LINE_WIDTH; //On va se mettre en 0,0 dans l'Ã©cran (dest)
+  byte* src = ( y_pos + Main_offset_Y ) * image_width + x_pos + Main_offset_X + Main_screen; //Coords de dÃ©part ds la source (src)
   int y;
   int x;
 
@@ -231,17 +231,17 @@
       dest+=ZOOMX;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     src+=image_width-width;
     dest+=VIDEO_LINE_WIDTH*ZOOMY-width*ZOOMX;
   }
   Update_rect(x_pos,y_pos,width,height);
 }
 
-// Affiche une brosse (arbitraire) à l'écran
+// Affiche une brosse (arbitraire) Ã  l'Ã©cran
 void Display_brush_wide(byte * brush, word x_pos,word y_pos,word x_offset,word y_offset,word width,word height,byte transp_color,word brush_width)
 {
-  // dest = Position à l'écran
+  // dest = Position Ã  l'Ã©cran
   byte* dest = Screen_pixels + y_pos * ZOOMY * VIDEO_LINE_WIDTH + x_pos * ZOOMX;
   // src = Position dans la brosse
   byte* src = brush + y_offset * brush_width + x_offset;
@@ -254,7 +254,7 @@
     // Pour chaque pixel
     for(x = width;x > 0; x--)
     {
-      // On vérifie que ce n'est pas la transparence
+      // On vÃ©rifie que ce n'est pas la transparence
       if(*src != transp_color)
       {
         *(dest+1) = *dest = *src;
@@ -264,7 +264,7 @@
       src++; dest+=ZOOMX;
     }
 
-    // On passe à la ligne suivante
+    // On passe Ã  la ligne suivante
     dest = dest + VIDEO_LINE_WIDTH*ZOOMY - width*ZOOMX;
     src = src + brush_width - width;
   }
@@ -272,7 +272,7 @@
 
 void Remap_screen_wide(word x_pos,word y_pos,word width,word height,byte * conversion_table)
 {
-  // dest = coords a l'écran
+  // dest = coords a l'Ã©cran
   byte* dest = Screen_pixels + y_pos * ZOOMY * VIDEO_LINE_WIDTH + x_pos * ZOOMX;
   int x,y;
 
@@ -294,7 +294,7 @@
 
 void Display_line_on_screen_fast_wide(word x_pos,word y_pos,word width,byte * line)
 /* On affiche toute une ligne de pixels telle quelle. */
-/* Utilisée si le buffer contient déja des pixel doublés. */
+/* UtilisÃ©e si le buffer contient dÃ©ja des pixel doublÃ©s. */
 {
   memcpy(Screen_pixels+x_pos*ZOOMX+y_pos*ZOOMY*VIDEO_LINE_WIDTH,line,width*ZOOMX);
 }
@@ -315,8 +315,8 @@
 void Display_transparent_mono_line_on_screen_wide(
         word x_pos, word y_pos, word width, byte* line, 
         byte transp_color, byte color)
-// Affiche une ligne à l'écran avec une couleur + transparence.
-// Utilisé par les brosses en mode zoom
+// Affiche une ligne Ã  l'Ã©cran avec une couleur + transparence.
+// UtilisÃ© par les brosses en mode zoom
 {
   byte* dest = Screen_pixels+ y_pos*VIDEO_LINE_WIDTH + x_pos*ZOOMX;
   int x;
@@ -338,31 +338,31 @@
 }
 
 void Display_part_of_screen_scaled_wide(
-        word width, // width non zoomée
-        word height, // height zoomée
+        word width, // width non zoomÃ©e
+        word height, // height zoomÃ©e
         word image_width,byte * buffer)
 {
   byte* src = Main_screen + Main_magnifier_offset_Y * image_width 
                       + Main_magnifier_offset_X;
   int y = 0; // Ligne en cours de traitement
 
-  // Pour chaque ligne à zoomer
+  // Pour chaque ligne Ã  zoomer
   while(1)
   {
     int x;
     
-    // On éclate la ligne
+    // On Ã©clate la ligne
     Zoom_a_line(src,buffer,Main_magnifier_factor*ZOOMX,width);
-    // On l'affiche Facteur fois, sur des lignes consécutives
+    // On l'affiche Facteur fois, sur des lignes consÃ©cutives
     x = Main_magnifier_factor;
     // Pour chaque ligne
     do{
-      // On affiche la ligne zoomée
+      // On affiche la ligne zoomÃ©e
       Display_line_on_screen_fast_wide(
         Main_X_zoom, y, width*Main_magnifier_factor,
         buffer
       );
-      // On passe à la suivante
+      // On passe Ã  la suivante
       y++;
       if(y==height)
       {
@@ -397,12 +397,12 @@
   }
 }
 
-// Affiche une partie de la brosse couleur zoomée
+// Affiche une partie de la brosse couleur zoomÃ©e
 void Display_brush_color_zoom_wide(word x_pos,word y_pos,
         word x_offset,word y_offset,
-        word width, // width non zoomée
+        word width, // width non zoomÃ©e
         word end_y_pos,byte transp_color,
-        word brush_width, // width réelle de la brosse
+        word brush_width, // width rÃ©elle de la brosse
         byte * buffer)
 {
   byte* src = Brush+y_offset*brush_width + x_offset;
@@ -413,7 +413,7 @@
   while(1)
   {
     Zoom_a_line(src,buffer,Main_magnifier_factor,width);
-    // On affiche facteur fois la ligne zoomée
+    // On affiche facteur fois la ligne zoomÃ©e
     for(bx=Main_magnifier_factor;bx>0;bx--)
     {
       Display_transparent_line_on_screen_wide(x_pos,y*ZOOMY,width*Main_magnifier_factor,buffer,transp_color);
@@ -430,10 +430,10 @@
 
 void Display_brush_mono_zoom_wide(word x_pos, word y_pos,
         word x_offset, word y_offset, 
-        word width, // width non zoomée 
+        word width, // width non zoomÃ©e 
         word end_y_pos,
         byte transp_color, byte color, 
-        word brush_width, // width réelle de la brosse
+        word brush_width, // width rÃ©elle de la brosse
         byte * buffer
 )
 
@@ -441,29 +441,29 @@
   byte* src = Brush + y_offset * brush_width + x_offset;
   int y=y_pos*ZOOMY;
 
-  //Pour chaque ligne à zoomer :
+  //Pour chaque ligne Ã  zoomer :
   while(1)
   {
     int bx;
     // src = Ligne originale
-    // On éclate la ligne
+    // On Ã©clate la ligne
     Zoom_a_line(src,buffer,Main_magnifier_factor,width);
 
-    // On affiche la ligne Facteur fois à l'écran (sur des
-    // lignes consécutives)
+    // On affiche la ligne Facteur fois Ã  l'Ã©cran (sur des
+    // lignes consÃ©cutives)
     bx = Main_magnifier_factor*ZOOMY;
 
-    // Pour chaque ligne écran
+    // Pour chaque ligne Ã©cran
     do
     {
-      // On affiche la ligne zoomée
+      // On affiche la ligne zoomÃ©e
       Display_transparent_mono_line_on_screen_wide(
         x_pos, y, width * Main_magnifier_factor, 
         buffer, transp_color, color
       );
-      // On passe à la ligne suivante
+      // On passe Ã  la ligne suivante
       y++;
-      // On vérifie qu'on est pas à la ligne finale
+      // On vÃ©rifie qu'on est pas Ã  la ligne finale
       if(y == end_y_pos*ZOOMY)
       {
         Redraw_grid( x_pos, y_pos,
@@ -476,19 +476,19 @@
     }
     while (bx > 0);
     
-    // Passage à la ligne suivante dans la brosse aussi
+    // Passage Ã  la ligne suivante dans la brosse aussi
     src+=brush_width;
   }
 }
 
 void Clear_brush_scaled_wide(word x_pos,word y_pos,word x_offset,word y_offset,word width,word end_y_pos,__attribute__((unused)) byte transp_color,word image_width,byte * buffer)
 {
-  // En fait on va recopier l'image non zoomée dans la partie zoomée !
+  // En fait on va recopier l'image non zoomÃ©e dans la partie zoomÃ©e !
   byte* src = Main_screen + y_offset * image_width + x_offset;
   int y = y_pos;
   int bx;
 
-  // Pour chaque ligne à zoomer
+  // Pour chaque ligne Ã  zoomer
   while(1){
     Zoom_a_line(src,buffer,Main_magnifier_factor*ZOOMX,width);
 
diff -ruN gfx2orig/src/readini.c grafx2/src/readini.c
--- gfx2orig/src/readini.c	2010-03-22 04:36:40.000000000 -0500
+++ grafx2/src/readini.c	2022-03-20 20:19:34.112495316 -0500
@@ -44,7 +44,7 @@
     {
       equal_found=1;
       index++;
-      // On enleve les espaces après le '='
+      // On enleve les espaces aprÃ¨s le '='
       while (str[index]==' ' || str[index]=='\t')
         memmove(str+index,str+index+1,strlen(str+index));
     }
@@ -68,14 +68,14 @@
     {
       if (!equal_found)
       {
-        // Passage en majuscule d'un caractère:
+        // Passage en majuscule d'un caractÃ¨re:
   
         str[index]=toupper((int)str[index]);
       }
       index++;
     }
   }
-  // On enlève les espaces avant la fin de chaine
+  // On enlÃ¨ve les espaces avant la fin de chaine
   while (index>0 && (str[index-1]==' ' || str[index-1]=='\t'))
   {
     index--;
@@ -90,22 +90,22 @@
   int buffer_index;
   int pattern_index;
 
-  // A partir de chaque lettre de la chaîne buffer
+  // A partir de chaque lettre de la chaÃ®ne buffer
   for (buffer_index=0;buffer[buffer_index]!='\0';buffer_index++)
   {
-    // On regarde si la chaîne pattern est équivalente à la position courante
-    // de la chaîne buffer:
+    // On regarde si la chaÃ®ne pattern est Ã©quivalente Ã  la position courante
+    // de la chaÃ®ne buffer:
     for (pattern_index=0;(pattern[pattern_index]!='\0') && (buffer[buffer_index+pattern_index]==pattern[pattern_index]);pattern_index++);
 
-    // Si on a trouvé la chaîne pattern dans la chaîne buffer, on renvoie la
-    // position à laquelle on l'a trouvée (+1 pour que si on la trouve au
-    // début ça ne renvoie pas la même chose que si on ne l'avait pas
-    // trouvée):
+    // Si on a trouvÃ© la chaÃ®ne pattern dans la chaÃ®ne buffer, on renvoie la
+    // position Ã  laquelle on l'a trouvÃ©e (+1 pour que si on la trouve au
+    // dÃ©but Ã§a ne renvoie pas la mÃªme chose que si on ne l'avait pas
+    // trouvÃ©e):
     if (pattern[pattern_index]=='\0')
       return (buffer_index+1);
   }
 
-  // Si on ne l'a pas trouvée, on renvoie 0:
+  // Si on ne l'a pas trouvÃ©e, on renvoie 0:
   return 0;
 }
 
@@ -117,11 +117,11 @@
   char * group_upper;
   char * upper_buffer;
 
-  // On alloue les zones de mémoire:
+  // On alloue les zones de mÃ©moire:
   group_upper=(char *)malloc(1024);
   upper_buffer=(char *)malloc(1024);
 
-  // On commence par se faire une version majuscule du groupe à rechercher:
+  // On commence par se faire une version majuscule du groupe Ã  rechercher:
   strcpy(group_upper,group);
   Load_INI_clear_string(group_upper, 0);
 
@@ -142,7 +142,7 @@
     strcpy(upper_buffer,buffer);
     Load_INI_clear_string(upper_buffer, 0);
 
-    // On compare la chaîne avec le groupe recherché:
+    // On compare la chaÃ®ne avec le groupe recherchÃ©:
     stop_seek=Load_INI_seek_pattern(upper_buffer,group_upper);
   }
   while (!stop_seek);
@@ -167,11 +167,11 @@
   char * upper_buffer;
   int    buffer_index;
 
-  // On alloue les zones de mémoire:
+  // On alloue les zones de mÃ©moire:
   option_upper=(char *)malloc(1024);
   upper_buffer=(char *)malloc(1024);
 
-  // On commence par se faire une version majuscule de l'option à rechercher:
+  // On commence par se faire une version majuscule de l'option Ã  rechercher:
   strcpy(option_upper,option_name);
   Load_INI_clear_string(option_upper, 0);
 
@@ -192,13 +192,13 @@
     strcpy(upper_buffer,buffer);
     Load_INI_clear_string(upper_buffer, raw_text);
 
-    // On compare la chaîne avec l'option recherchée:
+    // On compare la chaÃ®ne avec l'option recherchÃ©e:
     stop_seek=Load_INI_seek_pattern(upper_buffer,option_upper);
 
-    // Si on l'a trouvée:
+    // Si on l'a trouvÃ©e:
     if (stop_seek)
     {
-      // On se positionne juste après la chaîne "="
+      // On se positionne juste aprÃ¨s la chaÃ®ne "="
       buffer_index=Load_INI_seek_pattern(upper_buffer,"=");
 
       strcpy(return_code, upper_buffer + buffer_index);
@@ -209,7 +209,11 @@
   free(upper_buffer);
   free(option_upper);
 
+#if defined(FDOS)
+  return strlen(return_code) == 0; // Empty strings should be failures.
+#else
   return 0;
+#endif
 }
 
 int Load_INI_get_value(char * str,int * index,int * value)
@@ -347,11 +351,11 @@
   int    buffer_index;
   int    nb_values;
 
-  // On alloue les zones de mémoire:
+  // On alloue les zones de mÃ©moire:
   option_upper=(char *)malloc(1024);
   upper_buffer=(char *)malloc(1024);
 
-  // On commence par se faire une version majuscule de l'option à rechercher:
+  // On commence par se faire une version majuscule de l'option Ã  rechercher:
   strcpy(option_upper,option_name);
   Load_INI_clear_string(option_upper, 0);
 
@@ -372,15 +376,15 @@
     strcpy(upper_buffer,buffer);
     Load_INI_clear_string(upper_buffer, 0);
 
-    // On compare la chaîne avec l'option recherchée:
+    // On compare la chaÃ®ne avec l'option recherchÃ©e:
     stop_seek=Load_INI_seek_pattern(upper_buffer,option_upper);
 
-    // Si on l'a trouvée:
+    // Si on l'a trouvÃ©e:
     if (stop_seek)
     {
       nb_values=0;
 
-      // On se positionne juste après la chaîne "="
+      // On se positionne juste aprÃ¨s la chaÃ®ne "="
       buffer_index=Load_INI_seek_pattern(upper_buffer,"=");
 
       // Tant qu'on a pas atteint la fin de la ligne
@@ -433,7 +437,7 @@
 
   Line_number_in_INI_file=0;
 
-  // On alloue les zones de mémoire:
+  // On alloue les zones de mÃ©moire:
   buffer=(char *)malloc(1024);
   filename=(char *)malloc(256);
 
@@ -704,7 +708,7 @@
     goto Erreur_ERREUR_INI_CORROMPU;
   conf->Auto_nb_used=values[0];
 
-  // Optionnel, le mode video par défaut (à partir de beta 97.0%)
+  // Optionnel, le mode video par dÃ©faut (Ã  partir de beta 97.0%)
   conf->Default_resolution=0;
   if (!Load_INI_get_string (file,buffer,"Default_video_mode",value_label, 0))
   {
@@ -713,7 +717,7 @@
       conf->Default_resolution=mode;
   }
   
-  // Optionnel, les dimensions de la fenêtre (à partir de beta 97.0%)
+  // Optionnel, les dimensions de la fenÃªtre (Ã  partir de beta 97.0%)
   // Do that only if the first mode is actually windowed (not the case on gp2x for example)
   if(Video_mode[0].Fullscreen==0)
   {
@@ -729,7 +733,7 @@
   }
 
   conf->Mouse_merge_movement=100;
-  // Optionnel, paramètre pour grouper les mouvements souris (>98.0%)
+  // Optionnel, paramÃ¨tre pour grouper les mouvements souris (>98.0%)
   if (!Load_INI_get_values (file,buffer,"Merge_movement",1,values))
   {
     if ((values[0]<0) || (values[0]>1000))
diff -ruN gfx2orig/src/readline.c grafx2/src/readline.c
--- gfx2orig/src/readline.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/readline.c	2022-03-20 20:19:34.108495316 -0500
@@ -21,7 +21,7 @@
 */
 /************************************************************************
 *                                                                       *
-* READLINE (procédure permettant de saisir une chaîne de caractères) *
+* READLINE (procÃ©dure permettant de saisir une chaÃ®ne de caractÃ¨res) *
 *                                                                       *
 ************************************************************************/
 
@@ -40,12 +40,16 @@
 #include "windows.h"
 #include "input.h"
 
+#if defined(FDOS)
+#include "shim.h" // snprintf
+#endif
+
 #define TEXT_COLOR         MC_Black
 #define BACKGROUND_COLOR          MC_Light
 #define CURSOR_COLOR MC_Black
 #define CURSOR_BACKGROUND_COLOR  MC_Dark
 
-// Suppresion d'un caractère à une certaine POSITION dans une CHAINE.
+// Suppresion d'un caractÃ¨re Ã  une certaine POSITION dans une CHAINE.
 void Remove_character(char * str, byte position)
 {
   for (;str[position]!='\0';position++)
@@ -54,18 +58,18 @@
 
 
 void Insert_character(char * str, char letter, byte position)
-//  Insertion d'une LETTRE à une certaine POSITION
+//  Insertion d'une LETTRE Ã  une certaine POSITION
 //  dans une CHAINE d'une certaine TAILLE.
 {
   char temp_char;
 
   for (;letter!='\0';position++)
   {
-    // On mémorise le caractère qui se trouve en "position"
+    // On mÃ©morise le caractÃ¨re qui se trouve en "position"
     temp_char=str[position];
-    // On splotch la lettre à insérer
+    // On splotch la lettre Ã  insÃ©rer
     str[position]=letter;
-    // On place le caractère mémorisé dans "letter" comme nouvelle lettre à insérer
+    // On place le caractÃ¨re mÃ©morisÃ© dans "letter" comme nouvelle lettre Ã  insÃ©rer
     letter=temp_char;
   }
   // On termine la chaine
@@ -75,9 +79,9 @@
 int Valid_character(int c)
 {
   // Sous Linux: Seul le / est strictement interdit, mais beaucoup
-  // d'autres poseront des problèmes au shell, alors on évite.
-  // Sous Windows : c'est moins grave car le fopen() échouerait de toutes façons.
-  // AmigaOS4: Pas de ':' car utilisé pour les volumes.
+  // d'autres poseront des problÃ¨mes au shell, alors on Ã©vite.
+  // Sous Windows : c'est moins grave car le fopen() Ã©chouerait de toutes faÃ§ons.
+  // AmigaOS4: Pas de ':' car utilisÃ© pour les volumes.
   #if defined(__WIN32__)
   char forbidden_char[] = {'/', '|', '?', '*', '<', '>', ':', '\\'};
   #elif defined (__amigaos4__)
@@ -106,17 +110,17 @@
 *           Enhanced super scanf deluxe pro plus giga mieux :-)             *
 ****************************************************************************/
 byte Readline(word x_pos,word y_pos,char * str,byte visible_size,byte input_type)
-// Paramètres:
-//   x_pos, y_pos : Coordonnées de la saisie dans la fenêtre
-//   str       : Chaîne recevant la saisie (et contenant éventuellement une valeur initiale)
-//   max_size  : Nombre de caractères logeant dans la zone de saisie
-//   input_type  : 0=Chaîne, 1=Nombre, 2=Nom de fichier
+// ParamÃ¨tres:
+//   x_pos, y_pos : CoordonnÃ©es de la saisie dans la fenÃªtre
+//   str       : ChaÃ®ne recevant la saisie (et contenant Ã©ventuellement une valeur initiale)
+//   max_size  : Nombre de caractÃ¨res logeant dans la zone de saisie
+//   input_type  : 0=ChaÃ®ne, 1=Nombre, 2=Nom de fichier
 // Sortie:
 //   0: Sortie par annulation (Esc.) / 1: sortie par acceptation (Return)
 {
   byte max_size;
-  // Grosse astuce pour les noms de fichiers: La taille affichée est différente
-  // de la taille maximum gérée.
+  // Grosse astuce pour les noms de fichiers: La taille affichÃ©e est diffÃ©rente
+  // de la taille maximum gÃ©rÃ©e.
   if (input_type == 2)
     max_size = 255;
   else
@@ -128,10 +132,10 @@
 *           Enhanced super scanf deluxe pro plus giga mieux :-)             *
 ****************************************************************************/
 byte Readline_ex(word x_pos,word y_pos,char * str,byte visible_size,byte max_size, byte input_type, byte decimal_places)
-// Paramètres:
-//   x_pos, y_pos : Coordonnées de la saisie dans la fenêtre
-//   str       : Chaîne recevant la saisie (et contenant éventuellement une valeur initiale)
-//   max_size  : Nombre de caractères logeant dans la zone de saisie
+// ParamÃ¨tres:
+//   x_pos, y_pos : CoordonnÃ©es de la saisie dans la fenÃªtre
+//   str       : ChaÃ®ne recevant la saisie (et contenant Ã©ventuellement une valeur initiale)
+//   max_size  : Nombre de caractÃ¨res logeant dans la zone de saisie
 //   input_type  : 0=String, 1=Unsigned int, 2=Filename 3=Signed Double
 //   decimal_places: Number of decimal places for a double
 // Sortie:
@@ -144,13 +148,13 @@
   word input_key=0;
   byte is_authorized;
 
-  byte offset=0; // index du premier caractère affiché
+  byte offset=0; // index du premier caractÃ¨re affichÃ©
 
-  // Si on a commencé à editer par un clic-droit, on vide la chaine.
+  // Si on a commencÃ© Ã  editer par un clic-droit, on vide la chaine.
   if (Mouse_K==RIGHT_SIDE)
     str[0]='\0';
   else if (input_type==1)
-    snprintf(str,10,"%d",atoi(str)); // On tasse la chaine à gauche
+    snprintf(str,10,"%d",atoi(str)); // On tasse la chaine Ã  gauche
   else if (input_type==3)
   {
     //  Nothing. The caller should have used Sprint_double, with min_positions
@@ -161,13 +165,13 @@
   Keyboard_click_allowed = 0;
   Hide_cursor();
 
-  // Effacement de la chaîne
+  // Effacement de la chaÃ®ne
   Block(Window_pos_X+(x_pos*Menu_factor_X),Window_pos_Y+(y_pos*Menu_factor_Y),
         visible_size*(Menu_factor_X<<3),(Menu_factor_Y<<3),BACKGROUND_COLOR);
   Update_rect(Window_pos_X+(x_pos*Menu_factor_X),Window_pos_Y+(y_pos*Menu_factor_Y),
         visible_size*(Menu_factor_X<<3),(Menu_factor_Y<<3));
 
-  // Mise à jour des variables se rapportant à la chaîne en fonction de la chaîne initiale
+  // Mise Ã  jour des variables se rapportant Ã  la chaÃ®ne en fonction de la chaÃ®ne initiale
   strcpy(initial_string,str);
 
   size=strlen(str);
@@ -204,7 +208,7 @@
               Remove_character(str,position);
               size--;
               
-              // Effacement de la chaîne
+              // Effacement de la chaÃ®ne
               Block(Window_pos_X+(x_pos*Menu_factor_X),Window_pos_Y+(y_pos*Menu_factor_Y),
                     visible_size*(Menu_factor_X<<3),(Menu_factor_Y<<3),BACKGROUND_COLOR);
               goto affichage;
@@ -213,7 +217,7 @@
       case SDLK_LEFT : // Gauche
             if (position>0)
             {
-              // Effacement de la chaîne
+              // Effacement de la chaÃ®ne
               if (position==size)
                 Block(Window_pos_X+(x_pos*Menu_factor_X),Window_pos_Y+(y_pos*Menu_factor_Y),
                       visible_size*(Menu_factor_X<<3),(Menu_factor_Y<<3),BACKGROUND_COLOR);
@@ -237,7 +241,7 @@
       case SDLK_HOME : // Home
             if (position)
             {
-              // Effacement de la chaîne
+              // Effacement de la chaÃ®ne
               if (position==size)
                 Block(Window_pos_X+(x_pos*Menu_factor_X),Window_pos_Y+(y_pos*Menu_factor_Y),
                       visible_size*(Menu_factor_X<<3),(Menu_factor_Y<<3),BACKGROUND_COLOR);
@@ -264,7 +268,7 @@
             offset--;
           Remove_character(str,position);
           size--;
-          // Effacement de la chaîne
+          // Effacement de la chaÃ®ne
           Block(Window_pos_X+(x_pos*Menu_factor_X),Window_pos_Y+(y_pos*Menu_factor_Y),
                 visible_size*(Menu_factor_X<<3),(Menu_factor_Y<<3),BACKGROUND_COLOR);
           goto affichage;
@@ -285,7 +289,7 @@
           is_authorized=0; // On commence par supposer qu'elle est interdite
           switch(input_type)
           {
-            case 0 : // N'importe quelle chaîne:
+            case 0 : // N'importe quelle chaÃ®ne:
               if (input_key>=' ' && input_key<= 255)
                 is_authorized=1;
               break;
@@ -302,19 +306,19 @@
                 is_authorized=1;
               break;
             default : // Nom de fichier
-              // On regarde si la touche est autorisée
+              // On regarde si la touche est autorisÃ©e
               if ( Valid_character(input_key))
                 is_authorized=1;
           } // End du "switch(input_type)"
 
-          // Si la touche était autorisée...
+          // Si la touche Ã©tait autorisÃ©e...
           if (is_authorized)
           {
-            // ... alors on l'insère ...
+            // ... alors on l'insÃ¨re ...
             Insert_character(str,input_key,position/*,size*/);
             // ce qui augmente la taille de la chaine
             size++;
-            // et qui risque de déplacer le curseur vers la droite
+            // et qui risque de dÃ©placer le curseur vers la droite
             if (size<max_size)
             {
               position++;
@@ -346,7 +350,7 @@
   } // End du "while"
   Keyboard_click_allowed = 1;
 
-  // Effacement de la chaîne
+  // Effacement de la chaÃ®ne
   Block(Window_pos_X+(x_pos*Menu_factor_X),Window_pos_Y+(y_pos*Menu_factor_Y),
         visible_size*(Menu_factor_X<<3),(Menu_factor_Y<<3),BACKGROUND_COLOR);
   // On raffiche la chaine correctement
diff -ruN gfx2orig/src/readpng.c grafx2/src/readpng.c
--- gfx2orig/src/readpng.c	1969-12-31 18:00:00.000000000 -0600
+++ grafx2/src/readpng.c	2022-03-20 20:19:34.112495316 -0500
@@ -0,0 +1,184 @@
+// Adapted from:
+// http://www.libpng.org/pub/png/libpng-1.2.5-manual.html#section-3
+#include <stdlib.h>
+#include <png.h>
+#include <zlib.h>
+
+#include "readpng.h"
+
+
+void errmsg(const char * s, ...)
+{
+    va_list args;
+    va_start(args, s);
+    vfprintf(stderr, s, args);
+    fprintf(stderr, "\n");
+    va_end(args);
+}
+
+
+int read_png_file(char* file_name, pngdat * pdat)
+{
+    int x, y;
+    int i, n;
+
+    png_byte header[8];    // 8 is the maximum size that can be checked
+    png_bytep * row_pointers = NULL;
+    png_structp png_ptr;
+    png_infop info_ptr;
+
+    png_colorp palette;
+    int num_palette;
+
+    FILE *fp = fopen(file_name, "rb");
+    if (!fp) {
+        errmsg("[read_png_file] File %s could not be opened for reading", file_name);
+        return 0;
+    }
+
+    fread(&header[0], 1, 8, fp);
+    if (png_sig_cmp(&header[0], 0, 8)) {
+        fclose(fp);
+        errmsg("[read_png_file] File %s is not recognized as a PNG file", file_name);
+        return 0;
+    }
+
+    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
+    if (!png_ptr) {
+        fclose(fp);
+        errmsg("[read_png_file] png_create_read_struct failed");
+        return 0;
+    }
+
+    info_ptr = png_create_info_struct(png_ptr);
+    if (!info_ptr) {
+        fclose(fp);
+        errmsg("[read_png_file] png_create_info_struct failed");
+        return 0;
+    }
+
+    if (setjmp(png_jmpbuf(png_ptr))) {
+        fclose(fp);
+        errmsg("[read_png_file] Error during init_io");
+        return 0;
+    }
+
+    png_init_io(png_ptr, fp);
+    png_set_sig_bytes(png_ptr, 8);
+
+    png_read_info(png_ptr, info_ptr);
+
+
+
+    pdat->width = png_get_image_width(png_ptr, info_ptr);
+    pdat->height = png_get_image_height(png_ptr, info_ptr);
+    pdat->bit_depth = png_get_bit_depth(png_ptr, info_ptr);
+    pdat->color_type = png_get_color_type(png_ptr, info_ptr);
+
+    pdat->bytes_per_pixel = (pdat->bit_depth / 8) + ((pdat->bit_depth % 8) ? 1 : 0);
+
+    png_read_update_info(png_ptr, info_ptr);
+
+
+
+    if (setjmp(png_jmpbuf(png_ptr))) {
+        fclose(fp);
+        errmsg("[read_png_file] Error during read_image");
+        return 0;
+    }
+
+    row_pointers = (png_bytep*) malloc(sizeof(png_bytep) * (pdat->height));
+    if (!row_pointers) {
+        fclose(fp);
+        errmsg("[read_png_file] Error malloc row_pointers");
+        return 0;
+    }
+
+    for (y=0; y<pdat->height; y++) {
+        row_pointers[y] = (png_byte*) malloc(png_get_rowbytes(png_ptr, info_ptr));
+        if (!row_pointers[y]) {
+            while(y>=0) {
+                free(row_pointers[y--]);
+            }
+            return 0;
+        }
+    }
+
+    // For each pass of an interlaced image, use png_read_rows() instead.
+    png_read_image(png_ptr, row_pointers);
+
+    fclose(fp);
+
+
+
+    pdat->pixels = malloc(pdat->height * pdat->width * pdat->bytes_per_pixel);
+    if (pdat->pixels) {
+        for (y=0; y<pdat->height; y++) {
+            png_byte* row = row_pointers[y];
+            for (x=0; x<pdat->width; x++) {
+                png_byte* ptr = &(row[x*pdat->bytes_per_pixel]);
+                n = ((y * pdat->width) + x) * pdat->bytes_per_pixel;
+                for (i=0; i<pdat->bytes_per_pixel; i++) {
+                    *(pdat->pixels + n + i) = ptr[i];
+                }
+            }
+        }
+
+        if (pdat->color_type == PNG_COLOR_TYPE_PALETTE) {
+            if (png_get_PLTE(png_ptr, info_ptr, &palette, &num_palette)) {
+                if (num_palette > READPNG_MAX_PALETTE_NUM) {
+                    num_palette = READPNG_MAX_PALETTE_NUM;
+                }
+                pdat->num_palette = num_palette;
+                pdat->palette = malloc(READPNG_MAX_PALETTE_NUM * sizeof(png_color));
+                if (pdat->palette) {
+                    for(i=0; i<num_palette; i++) {
+                        *(pdat->palette + i*3 + 0) = palette[i].red;
+                        *(pdat->palette + i*3 + 1) = palette[i].green;
+                        *(pdat->palette + i*3 + 2) = palette[i].blue;
+                    }
+                    for(i=num_palette; i<READPNG_MAX_PALETTE_NUM; i++) {
+                        *(pdat->palette + i*3 + 0) = 0;
+                        *(pdat->palette + i*3 + 1) = 0;
+                        *(pdat->palette + i*3 + 2) = 0;
+                    }
+                }
+            }
+        }
+    }
+
+    if (row_pointers[0]) {
+        y = pdat->height-1;
+        while (y>=0) {
+            free(row_pointers[y--]);
+        }
+    }
+
+    return 1;
+}
+
+
+
+void free_pngdat(pngdat * pdat) {
+    if (pdat) {
+        if (pdat->pixels) {
+            free(pdat->pixels);
+            pdat->pixels = NULL;
+        }
+        if (pdat->palette) {
+            free(pdat->palette);
+            pdat->palette = NULL;
+        }
+    }
+}
+
+
+void read_png_version_info() {
+    fprintf(stderr, "   Compiled with libpng %s; using libpng %s.\n",
+      PNG_LIBPNG_VER_STRING, png_libpng_ver);
+    fprintf(stderr, "   Compiled with zlib %s; using zlib %s.\n",
+      ZLIB_VERSION, zlib_version);
+}
+
+
+
diff -ruN gfx2orig/src/readpng.h grafx2/src/readpng.h
--- gfx2orig/src/readpng.h	1969-12-31 18:00:00.000000000 -0600
+++ grafx2/src/readpng.h	2022-03-20 20:19:34.112495316 -0500
@@ -0,0 +1,23 @@
+#ifndef _READPNG_H_
+#define _READPNG_H_
+
+#define READPNG_MAX_PALETTE_NUM 256
+
+typedef struct {
+    int width;
+    int height;
+    int bit_depth;
+    int bytes_per_pixel;
+    int color_type;
+    unsigned char * pixels;
+    int  num_palette;
+    unsigned char * palette;
+} pngdat;
+
+void free_pngdat(pngdat * pdat);
+
+int read_png_file(char* file_name, pngdat * dat);
+
+void read_png_version_info();
+
+#endif
diff -ruN gfx2orig/src/realpath.c grafx2/src/realpath.c
--- gfx2orig/src/realpath.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/realpath.c	2022-03-20 20:19:34.108495316 -0500
@@ -7,6 +7,10 @@
 #include <string.h>
 #include <unistd.h>
 
+#if defined(FDOS)
+#include <limits.h> // PATH_MAX  (512 bytes)
+#endif
+
 #if defined(__AROS__) || defined(__BEOS__) || defined(__MORPHOS__) || defined(__GP2X__) || defined(__amigaos__)
 // These platforms don't have realpath().
 // We use the following implementation, found in:
@@ -107,6 +111,75 @@
     {
         return _fullpath(resolved_path,_path,260);
     }
+#elif defined(FDOS)
+    // Appends tail to body only if total length is less than PATH_MAX. 
+    // Returns 1 on success, 0 on failure.
+    int catpaths(char* body, const char* tail) {
+        if (strlen(body) + strlen(tail) < PATH_MAX) {
+            strcat(body, tail);
+            return 1;
+        }
+        return 0;
+    }
+
+    // Returns the absolute path of the '_path' parameter or NULL on error.
+    // If NULL is supplied as the 'resolved_path' parameter, the returned
+    // string will have been malloc()ed and should be free()ed when it is
+    // no longer needed.
+    //
+    // Both forward and back slashes can be used as the directory separator,
+    // however, if _path is from the command line the path must use '\' as the
+    // dircetory separator otherwise Grafx2 will interpret it as a parameter.
+    // The returned string will have all '\' converted to '/'.
+    // Paths can be relative or absolute. e.g.:
+    //     c:\dir\file.png
+    //     file.png
+    //     dir\file.png
+    //     ..\dir\file.png
+    // Invalid paths such as 'c:file.png' or 'c:dir/file.png' will cause Grafx2
+    // to abort with file not found error.
+    char *Realpath(const char *_path, char *resolved_path)
+    {
+        char* p;
+        if (! resolved_path) {
+            resolved_path = malloc(PATH_MAX);
+        }
+
+        if (resolved_path) {
+            resolved_path[0] = '\0';
+
+            if (index(_path, ':')) { // We have absolute path.
+                if (!catpaths(resolved_path, _path)) {
+                    return NULL;
+                }
+            } else {
+                char current_dir_path[PATH_MAX];
+                // getcwd() returns 'c:/' at root and 'c:/dir' in dir.
+                if (getcwd(current_dir_path, PATH_MAX-2)) {
+                    int n = strlen(current_dir_path);
+                    if (current_dir_path[n-1] != '/') {
+                        current_dir_path[n] = '/';
+                        current_dir_path[n+1] = '\0';
+                    }
+                    if (!catpaths(resolved_path, current_dir_path)) {
+                        return NULL;
+                    }
+                    if (!catpaths(resolved_path, _path)) {
+                        return NULL;
+                    }
+                }
+            }
+
+            // Change all '\' to '/'.
+            p = resolved_path;
+            while (*p) {
+                if (*p == '\\') { *p = '/'; }
+                p++;
+            }
+
+        }
+        return resolved_path;
+    }
 #else
 // Use the stdlib function.
     char *Realpath(const char *_path, char *resolved_path)
diff -ruN gfx2orig/src/saveini.c grafx2/src/saveini.c
--- gfx2orig/src/saveini.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/saveini.c	2022-03-20 20:19:34.112495316 -0500
@@ -37,11 +37,11 @@
   char * group_upper;
   char * upper_buffer;
 
-  // On alloue les zones de mémoire:
+  // On alloue les zones de mÃ©moire:
   group_upper =(char *)malloc(1024);
   upper_buffer=(char *)malloc(1024);
 
-  // On commence par se faire une version majuscule du groupe à rechercher:
+  // On commence par se faire une version majuscule du groupe Ã  rechercher:
   strcpy(group_upper,group);
   Load_INI_clear_string(group_upper, 0);
 
@@ -60,7 +60,7 @@
     strcpy(upper_buffer,buffer);
     Load_INI_clear_string(upper_buffer, 0);
 
-    // On compare la chaîne avec le groupe recherché:
+    // On compare la chaÃ®ne avec le groupe recherchÃ©:
     stop_seek=Load_INI_seek_pattern(upper_buffer,group_upper);
     if (fprintf(new_file,"%s",buffer)<0)
     {
@@ -123,16 +123,16 @@
   for (;source[source_index]==' ';source_index++)
     dest[source_index]=source[source_index];
 
-  // Pour l'instant, la source et la destination en sont au même point:
+  // Pour l'instant, la source et la destination en sont au mÃªme point:
   dest_index=source_index;
 
-  // Puis pour chaque valeur à recopier:
+  // Puis pour chaque valeur Ã  recopier:
   for (value_index=0;value_index<nb_values_to_set;value_index++)
   {
-    // Dans la destination, on écrit la valeur:
+    // Dans la destination, on Ã©crit la valeur:
     if (litteral)
     {
-      // La valeur doit être écrite sous la forme Yes/No
+      // La valeur doit Ãªtre Ã©crite sous la forme Yes/No
 
       if (values[value_index])
       {
@@ -151,22 +151,22 @@
     }
     else
     {
-      // La valeur doit être écrite sous forme numérique
+      // La valeur doit Ãªtre Ã©crite sous forme numÃ©rique
 
       if (source[source_index]=='$')
       {
-        // On va écrire la valeur sous forme hexadécimale:
+        // On va Ã©crire la valeur sous forme hexadÃ©cimale:
 
         // On commence par inscrire le symbole '$':
         dest[dest_index]='$';
 
-        // Puis on y concatène la valeur:
+        // Puis on y concatÃ¨ne la valeur:
         sprintf(dest+dest_index+1,"%x",values[value_index]);
         dest_index+=strlen(dest+dest_index);
       }
       else
       {
-        // On va écrire la valeur sous forme décimale:
+        // On va Ã©crire la valeur sous forme dÃ©cimale:
 
         sprintf(dest+dest_index,"%d",values[value_index]);
         dest_index+=strlen(dest+dest_index);
@@ -178,16 +178,16 @@
 
     if (value_index!=(nb_values_to_set-1))
     {
-      // Il reste d'autres valeurs à écrire
+      // Il reste d'autres valeurs Ã  Ã©crire
 
-      // On recopie tous les caractères de la source jusqu'au suivant qui
-      // désigne une valeur:
+      // On recopie tous les caractÃ¨res de la source jusqu'au suivant qui
+      // dÃ©signe une valeur:
       for (;(!Save_INI_char_in_value_alphabet(source[source_index])) && (source[source_index]!='\0');source_index++,dest_index++)
         dest[dest_index]=source[source_index];
     }
     else
     {
-      // C'est la dernière valeur à initialiser
+      // C'est la derniÃ¨re valeur Ã  initialiser
 
       // On recopie toute la fin de la ligne:
       for (;source[source_index]!='\0';source_index++,dest_index++)
@@ -216,10 +216,10 @@
   for (;source[source_index]==' ';source_index++)
     dest[source_index]=source[source_index];
 
-  // Pour l'instant, la source et la destination en sont au même point:
+  // Pour l'instant, la source et la destination en sont au mÃªme point:
   dest_index=source_index;
 
-  // Dans la destination, on écrit la valeur:
+  // Dans la destination, on Ã©crit la valeur:
   strcpy(dest+dest_index,value);
   dest_index+=strlen(value);
 
@@ -242,7 +242,7 @@
   char * result_buffer;
   //int    buffer_index;
 
-  // On alloue les zones de mémoire:
+  // On alloue les zones de mÃ©moire:
   option_upper=(char *)malloc(1024);
   upper_buffer=(char *)malloc(1024);
   result_buffer=(char *)malloc(1024);
@@ -251,7 +251,7 @@
   if (value == NULL)
     value="";
 
-  // On commence par se faire une version majuscule de l'option à rechercher:
+  // On commence par se faire une version majuscule de l'option Ã  rechercher:
   strcpy(option_upper,option_name);
   Load_INI_clear_string(option_upper, 0);
 
@@ -271,12 +271,12 @@
     strcpy(upper_buffer,buffer);
     Load_INI_clear_string(upper_buffer, 0);
 
-    // On compare la chaîne avec l'option recherchée:
+    // On compare la chaÃ®ne avec l'option recherchÃ©e:
     stop_seek=Load_INI_seek_pattern(upper_buffer,option_upper);
 
     if (stop_seek)
     {
-      // On l'a trouvée:
+      // On l'a trouvÃ©e:
 
       Save_INI_set_string(result_buffer,buffer,value);
       if (fprintf(new_file,"%s",result_buffer)<0)
@@ -289,7 +289,7 @@
     }
     else
     {
-      // On l'a pas trouvée:
+      // On l'a pas trouvÃ©e:
 
       if (fprintf(new_file,"%s",buffer)<0)
       {
@@ -317,12 +317,12 @@
   char * result_buffer;
   //int    buffer_index;
 
-  // On alloue les zones de mémoire:
+  // On alloue les zones de mÃ©moire:
   option_upper=(char *)malloc(1024);
   upper_buffer=(char *)malloc(1024);
   result_buffer=(char *)malloc(1024);
 
-  // On commence par se faire une version majuscule de l'option à rechercher:
+  // On commence par se faire une version majuscule de l'option Ã  rechercher:
   strcpy(option_upper,option_name);
   Load_INI_clear_string(option_upper, 0);
 
@@ -343,12 +343,12 @@
     strcpy(upper_buffer,buffer);
     Load_INI_clear_string(upper_buffer, 0);
 
-    // On compare la chaîne avec l'option recherchée:
+    // On compare la chaÃ®ne avec l'option recherchÃ©e:
     stop_seek=Load_INI_seek_pattern(upper_buffer,option_upper);
 
     if (stop_seek)
     {
-      // On l'a trouvée:
+      // On l'a trouvÃ©e:
 
       Save_INI_set_value(result_buffer,buffer,nb_values_to_set,values,litteral);
       if (fprintf(new_file,"%s",result_buffer)<0)
@@ -361,7 +361,7 @@
     }
     else
     {
-      // On l'a pas trouvée:
+      // On l'a pas trouvÃ©e:
 
       if (fprintf(new_file,"%s",buffer)<0)
       {
@@ -404,14 +404,14 @@
   int    ini_file_exists;
   int index;
 
-  // On alloue les zones de mémoire:
+  // On alloue les zones de mÃ©moire:
   buffer=(char *)malloc(1024);
   
   // On calcule les noms des fichiers qu'on manipule:
   strcpy(filename,Config_directory);
   strcat(filename,"gfx2.ini");
 
-  // On vérifie si le fichier INI existe
+  // On vÃ©rifie si le fichier INI existe
   if ((ini_file_exists = File_exists(filename)))
   {
     strcpy(temp_filename,Config_directory);
@@ -423,7 +423,7 @@
       goto Erreur_ERREUR_SAUVEGARDE_INI;
     }
   }
-  // On récupère un fichier INI "propre" à partir de gfx2def.ini
+  // On rÃ©cupÃ¨re un fichier INI "propre" Ã  partir de gfx2def.ini
   strcpy(ref_ini_file,Data_directory);
   strcat(ref_ini_file,"gfx2def.ini");
   Ancien_fichier=fopen(ref_ini_file,"rb");
diff -ruN gfx2orig/src/SDL_byteorder.h grafx2/src/SDL_byteorder.h
--- gfx2orig/src/SDL_byteorder.h	1969-12-31 18:00:00.000000000 -0600
+++ grafx2/src/SDL_byteorder.h	2022-03-20 20:19:34.112495316 -0500
@@ -0,0 +1 @@
+// This file only exists to satisfy '#include' directives in source files.
diff -ruN gfx2orig/src/SDL.c grafx2/src/SDL.c
--- gfx2orig/src/SDL.c	1969-12-31 18:00:00.000000000 -0600
+++ grafx2/src/SDL.c	2022-03-20 20:19:34.112495316 -0500
@@ -0,0 +1,1245 @@
+#if defined(FDOS)
+// This implements SDL functions necessary for Grafx2 to run under FreeDOS.
+// Alhough this implements SDL functions, do not assume the functions behave
+// as described in official SDL documentation. Attempting to use these SDL
+// functions with any program other than Grafx2 may or may not succeed.
+
+#include <stdio.h>       // printf
+#include <stdlib.h>      // free
+#include <string.h>      // memset
+#include <dos.h>         // int86
+#include <sys/nearptr.h> // _djgpp_nearptr_disable
+
+#include "SDL.h"
+#include "readpng.h"
+
+
+#define VIDEO_INT    0x10
+#define BIOS15_INT   0x15
+#define KEYBOARD_INT 0x16
+#define DOS_INT      0x21
+#define MOUSE_INT    0x33
+
+
+// VGA video DAC PEL mask
+// #define VGA_PALETTE_MASK_PORT  0x03c6
+
+// VGA video DAC PEL address port
+#define VGA_PALETTE_INDEX_PORT  0x03c8
+
+// VGA video DAC port
+#define VGA_PALETTE_COLOR_PORT  0x03c9
+
+
+#define VGA_START_ADDR  0xA0000
+
+
+#define FDOS_SCREEN_WIDTH   320
+#define FDOS_SCREEN_HEIGHT  200
+
+
+#define MOD_UNSET(m, f) (m &= ~(f))
+#define MOD_SET(m, f) (m |= (f))
+
+#define FAKE_MOD_UNSET(f) (MOD_UNSET(FAKE_MODIFIERS, (f)))
+#define FAKE_MOD_SET(f)   (MOD_SET(FAKE_MODIFIERS, (f)))
+
+#define IS_MOD_SET(m, f) ((m) & (f))
+
+#define IS_FAKE_MOD_SET(f) (IS_MOD_SET(FAKE_MODIFIERS, (f)))
+
+
+static SDL_Rect  screen_rect;
+static SDL_Rect* screen_modes[2];
+
+
+static unsigned int PREV_MOUSE_BTN_LEFT   = 0;
+static unsigned int PREV_MOUSE_BTN_MIDDLE = 0;
+static unsigned int PREV_MOUSE_BTN_RIGHT  = 0;
+static Sint32 PREV_MOUSE_X = 160;
+static Sint32 PREV_MOUSE_Y = 100;
+static SDLKey PREV_KEY = 0;
+
+
+static Uint32 TICKS_EPOCH = 0;
+
+
+static SDLMod JOYSTICK_MODIFIERS = 0;
+
+static Uint32 FAKE_MODIFIERS = 0;
+
+// Modify the saved mouse position so the next call to SDL_PollEvent() will
+// trigger a SDL_MOUSEMOTION event causing the mouse cursor to be redrawn..
+void mod_prev_mouse_position() {
+  if (PREV_MOUSE_X) {
+      PREV_MOUSE_X--;
+  } else {
+      PREV_MOUSE_X++;
+  }
+}
+
+SDL_Surface* malloc_surface(Uint32 flags, int width, int height, int bpp, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask) {
+    int i;
+    int bytes_per_pixel;
+    SDL_Color       * colors;
+    SDL_Palette     * palette;
+    SDL_PixelFormat * format;
+    char            * pixels;
+    SDL_Surface     * surface;
+
+    bytes_per_pixel = (bpp / 8) + ((bpp % 8) ? 1 : 0);
+
+    colors = (SDL_Color *) malloc(sizeof(SDL_Color) * 256);
+    if (colors == NULL) {
+        return NULL;
+    }
+
+    palette = (SDL_Palette *) malloc(sizeof(SDL_Palette)); 
+    if (palette == NULL) {
+        free(colors);
+        return NULL;
+    }
+
+    format = (SDL_PixelFormat *) malloc(sizeof(SDL_PixelFormat));
+    if (format == NULL) {
+        free(colors);
+        free(palette);
+        return NULL;
+    }
+
+    pixels = (char *) malloc(width * height * bytes_per_pixel);
+    if (pixels == NULL) {
+        free(colors);
+        free(palette);
+        free(format);
+        return NULL;
+    }
+    memset(pixels, 0, width * height * bytes_per_pixel);
+
+    surface = (SDL_Surface *) malloc(sizeof(SDL_Surface));
+    if (surface == NULL) {
+        free(colors);
+        free(palette);
+        free(format);
+        free(pixels);
+        return NULL;
+    }
+
+    palette->colors = colors;
+    format->palette = palette;
+    surface->format = format;
+    surface->pixels = pixels;
+
+    palette->version = 0;
+    palette->refcount = 1;
+    palette->ncolors = 256;
+    for (i=0; i<palette->ncolors; i++) {
+        colors[i].r = 0;
+        colors[i].g = 0;
+        colors[i].b = 0;
+        colors[i].a = 0;
+    }
+
+    format->BitsPerPixel = bpp;
+    format->BytesPerPixel = bytes_per_pixel;
+    format->Rmask = Rmask;
+    format->Gmask = Gmask;
+    format->Bmask = Bmask;
+    format->Amask = Amask;
+
+    surface->flags = flags;
+    surface->pitch = width * bytes_per_pixel;
+    surface->w = width;
+    surface->h = height;
+    surface->refcount = 1;
+    surface->locked = 0;
+
+    return surface;
+}
+
+
+SDL_Surface * IMG_Load(char * path) {
+    SDL_Surface * surf = NULL;
+    int i;
+    pngdat pdat;
+    Uint32 flags = 0;
+    int pathlen = strlen(path);
+    if (pathlen > 3) {
+        if ((strcmp(&path[pathlen-4], ".png") == 0) || (strcmp(&path[pathlen-4], ".PNG") == 0)) {
+            if (read_png_file(path, &pdat)) {
+                flags = SDL_SWSURFACE;
+
+                surf = malloc_surface(flags, pdat.width, pdat.height, pdat.bit_depth, 0, 0, 0, 0);
+                if (surf) {
+                    surf->format->palette->ncolors = pdat.num_palette;
+
+                    // Copy pixels
+                    memcpy(surf->pixels, pdat.pixels, pdat.height * pdat.width * pdat.bytes_per_pixel);
+
+                    // Copy palette
+                    for (i=0; i<pdat.num_palette; i++) {
+                        surf->format->palette->colors[i].r = pdat.palette[i*3];
+                        surf->format->palette->colors[i].g = pdat.palette[i*3+1];
+                        surf->format->palette->colors[i].b = pdat.palette[i*3+2];
+                        surf->format->palette->colors[i].a = 0;
+                    }
+
+                    free_pngdat(&pdat);
+
+                }
+            }
+        }
+    }
+    return surf;
+}
+
+
+void reset_video() {
+    union REGS regs;
+    regs.h.ah = 0x00;
+    // regs.h.al = 0x03;
+    regs.h.al = 0x07; // 80x25 black/white
+    int86(VIDEO_INT, &regs, &regs);
+}
+
+
+// Set the appropriate bits in FAKE_MODIFIERS.
+// The 'fake_mods' parameter can be a bitfield values OR'ed together.
+void set_fake_modifiers(Uint32 fake_mods) {
+    if (fake_mods & FAKE_MOD_LS_ALT) {
+        FAKE_MOD_SET(FAKE_MOD_LS_ALT);
+        FAKE_MOD_UNSET(FAKE_MOD_LS_CTRL);
+    }
+    if (fake_mods & FAKE_MOD_LS_CTRL) {
+        FAKE_MOD_SET(FAKE_MOD_LS_CTRL);
+        FAKE_MOD_UNSET(FAKE_MOD_LS_ALT);
+    }
+    if (fake_mods & FAKE_MOD_RS_ALT) {
+        FAKE_MOD_SET(FAKE_MOD_RS_ALT);
+        FAKE_MOD_UNSET(FAKE_MOD_RS_CTRL);
+    }
+    if (fake_mods & FAKE_MOD_RS_CTRL) {
+        FAKE_MOD_SET(FAKE_MOD_RS_CTRL);
+        FAKE_MOD_UNSET(FAKE_MOD_RS_ALT);
+    }
+    if (fake_mods & FAKE_MOD_CL_ALT) {
+        FAKE_MOD_SET(FAKE_MOD_CL_ALT);
+        FAKE_MOD_UNSET(FAKE_MOD_CL_CTRL);
+    }
+    if (fake_mods & FAKE_MOD_CL_CTRL) {
+        FAKE_MOD_SET(FAKE_MOD_CL_CTRL);
+        FAKE_MOD_UNSET(FAKE_MOD_CL_ALT);
+    }
+    if (fake_mods & FAKE_MOD_NL_ALT) {
+        FAKE_MOD_SET(FAKE_MOD_NL_ALT);
+        FAKE_MOD_UNSET(FAKE_MOD_NL_CTRL);
+    }
+    if (fake_mods & FAKE_MOD_NL_CTRL) {
+        FAKE_MOD_SET(FAKE_MOD_NL_CTRL);
+        FAKE_MOD_UNSET(FAKE_MOD_NL_ALT);
+    }
+}
+
+
+SDL_Surface* SDL_CreateRGBSurface(Uint32 flags, int width, int height, int depth, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask){
+  return malloc_surface(flags, width, height, depth, Rmask, Gmask, Bmask, Amask);
+}
+
+
+//If 'x', 'y', 'w' and 'h' are all 0, SDL_UpdateRect will update the entire screen.
+void SDL_UpdateRect(SDL_Surface *screen, Sint32 x, Sint32 y, Sint32 w, Sint32 h){
+    int xx;
+    int yy;
+    // char *VGA = (char *)0xA0000;
+    char *VGA = (char *)VGA_START_ADDR;
+    char* px = (char*)(screen->pixels);
+
+    VGA += __djgpp_conventional_base;
+
+    if (x == 0 && y == 0 && w == 0 && h == 0) {
+        h = screen->h;
+        w = screen->w;
+    }
+
+    for(yy=y; yy<y+h; yy++) {
+      for(xx=x; xx<x+w; xx++) {
+        VGA[yy*(screen->w)+xx] = px[yy*(screen->w)+xx];
+      }
+    }
+
+}
+
+
+// Returns 0 on success or a negative error code on failure
+int SDL_FillRect(SDL_Surface * dst, const SDL_Rect * rect, Uint32 color) {
+    int xx;
+    int yy;
+
+    char cval = (char)(color & 0xFF); // Just to be safe.
+    char *px = (char*)(dst->pixels);
+
+    for(yy=rect->y; yy<rect->y+rect->h; yy++) {
+        for(xx=rect->x; xx<rect->x+rect->w; xx++) {
+            *(px + (yy*(dst->w)+xx)) = cval;
+        }
+    }
+
+   return 0;
+}
+
+
+
+
+void SDL_FreeSurface(SDL_Surface * surface) {
+    if (surface) {
+        if (surface->format) {
+            if (surface->format->palette) {
+                if (surface->format->palette->colors) {
+                    free(surface->format->palette->colors);
+                    surface->format->palette->colors = NULL;
+                }
+                free(surface->format->palette);
+                surface->format->palette = NULL;
+            }
+            free(surface->format);
+            surface->format = NULL;
+        }
+        if (surface->pixels) {
+            free(surface->pixels);
+            surface->pixels = NULL;
+        }
+        free(surface);
+        surface = NULL;
+    }
+}
+
+
+// Return elapsed time in milliseconds since starting. This should give
+// run-time for a month before rollover. FreeDOS has 5/100 sec resolution.
+// Uint32 is 2^32     = 4,294,967,295
+// 31*24*60*60*100*10 = 2,678,400,000
+Uint32 get_millis() {
+  static int init_day = 0;
+  static int max_day = 0;
+  union REGS regs;
+  int multiplier;
+  int days;
+  int hours;
+  int minutes;
+  int seconds;
+  int hundreths;
+
+
+  // Get date
+  regs.h.ah = 0x2a; // function Get system date
+  int86(DOS_INT, &regs, &regs);
+  // year = regs.x.cx;  // (1980-2099)
+  // month = regs.h.dh; // (1-12)
+  days = regs.h.dl;     // (1-31)
+
+  if (!init_day) {
+    init_day = days;
+    init_day--;
+  }
+
+  if (days > max_day) {
+    max_day = days;
+  }
+
+  multiplier = max_day - init_day;
+  if (days < init_day) {
+       multiplier += days;
+  }
+
+  // Get time
+  regs.h.ah = 0x2c; // function Get system time
+  int86(DOS_INT, &regs, &regs);
+  hours = regs.h.ch;     // (0-23)
+  minutes = regs.h.cl;   // (0-59)
+  seconds = regs.h.dh;   // (0-59)
+  hundreths = regs.h.dl; // (0-99)
+
+  //return multiplier * (((((((hours*60) + minutes)*60) + seconds)*100) + hundreths)*10);
+
+  // FIXME? This seems to result in fewer eratic mouse movements.
+  return (((((hours*60) + minutes)*60) + seconds)*100) + hundreths;
+}
+
+
+// Returns 0 on success or -1 on error.
+int SDL_Init(int flags){
+  union REGS regs;
+  int is_mouse_avail = 0;
+
+  (void)flags; // ignored
+
+  TICKS_EPOCH = get_millis();
+
+  __djgpp_nearptr_enable(); // Disable 640K memory protection.
+                            // This allows writing to video memory.
+
+
+
+  // resets mouse to default driver values:
+  //    mouse is positioned to screen center
+  //    mouse cursor is reset and hidden
+  //    no interrupts are enabled (mask = 0)
+  //    double speed threshold set to 64 mickeys per second
+  //    horizontal mickey to pixel ratio (8 to 8)
+  //    vertical mickey to pixel ratio (16 to 8)
+  //    max width and height are set to maximum for video mode
+  regs.x.ax = 0x0;
+  int86(MOUSE_INT, &regs, &regs);
+  is_mouse_avail = regs.x.ax;
+  
+  if (is_mouse_avail == 0xFFFF) {
+    // Mouse is available.
+
+    // Set mouse sensitivity.
+    regs.x.ax = 0x1a;
+    regs.x.bx = 20; // horz-rez (0-100) default: 50
+    regs.x.cx = 20; // vert-rez (0-100) default: 50
+    regs.x.dx = 0; // double-speed threashold
+    int86(MOUSE_INT, &regs, &regs);
+  }
+
+  return 0;
+}
+
+
+
+// Returns a joystick identifier or NULL if an error occurred.
+// (Joystick is currently not supported.)
+SDL_Joystick * SDL_JoystickOpen(int device_index) {
+  (void) device_index;
+  return NULL;
+}
+
+
+
+
+
+void SDL_Delay(int ms) {
+    union REGS regs;
+    // CX:DX number of microseconds to wait
+    // granularity is 976 microseconds
+    long micro_secs = ms * 1000;
+    int cx = micro_secs / 0xFFFF;
+    int dx = micro_secs - (cx * 0xFFFF);
+    regs.h.ah = 0x86;
+    regs.x.cx = cx;
+    regs.x.dx = dx;
+    int86(BIOS15_INT, &regs, &regs);
+}
+
+
+// e.g. SDL_EnableKeyRepeat(250, 32);
+void SDL_EnableKeyRepeat(int delay_ms, int interval_ms) {
+  union REGS regs;
+  int delay_val = 0;
+  int interval_val = 30;
+
+  if (delay_ms == 250) {
+    delay_val = 0;
+  }
+  if (interval_ms == 32) {
+    interval_val = 30;
+  }
+
+  regs.h.ah = 0x03;         // typematic function
+  regs.h.al = 0x05;         // set rate/delay
+  regs.h.bh = delay_val;    // 0=250, 1=500, 2=750, 3=1000 
+  regs.h.bl = interval_val; // 0=30, 0x1f=2
+  int86(VIDEO_INT, &regs, &regs);
+}
+
+void SDL_EnableUNICODE(int flag) {
+  (void)flag;
+  // Ignored
+}
+
+
+// Copied from SDL-1.2/src/video/SDL_pixels.c
+// Match an RGB value to a particular palette index
+Uint8 SDL_FindColor(SDL_Palette *pal, Uint8 r, Uint8 g, Uint8 b)
+{
+    // Do colorspace distance matching
+    unsigned int smallest;
+    unsigned int distance;
+    int rd, gd, bd;
+    int i;
+    Uint8 pixel=0;
+
+    smallest = ~0;
+    for ( i=0; i<pal->ncolors; ++i ) {
+        rd = pal->colors[i].r - r;
+        gd = pal->colors[i].g - g;
+        bd = pal->colors[i].b - b;
+        distance = (rd*rd)+(gd*gd)+(bd*bd);
+        if ( distance < smallest ) {
+            pixel = i;
+            if ( distance == 0 ) { // Perfect match!
+                break;
+            }
+            smallest = distance;
+        }
+    }
+    return(pixel);
+}
+
+// In Grafx2 SDL_SetModState() is only used to set modifier keys when using
+// a joystick. Since a Joysticks is not supported, this function is basically
+// useless and only exists to allow compiling to succeed.
+void SDL_SetModState(SDLMod mod) {
+  JOYSTICK_MODIFIERS = mod;
+}
+
+// Get the state of modifiers.
+SDLMod SDL_GetModState(void){
+    unsigned int mod_flags = 0;
+    unsigned int mod = 0;
+    union REGS regs;
+
+    // Returns the current status of the shift flags in ax.
+    // The shift flags are defined as follows:
+    //   bit 15: SysReq key pressed             0x8000
+    //   bit 14: Capslock key currently down    0x4000
+    //   bit 13: Numlock key currently down     0x2000
+    //   bit 12: Scroll lock key currently down 0x1000
+    //   bit 11: Right alt key is down          0x0800
+    //   bit 10: Right ctrl key is down         0x0400
+    //   bit 9: Left alt key is down            0x0200
+    //   bit 8: Left ctrl key is down           0x0100
+    //   bit 7: Insert toggle                   0x80
+    //   bit 6: Capslock toggle                 0x40
+    //   bit 5: Numlock toggle                  0x20
+    //   bit 4: Scroll lock toggle              0x10
+    //   bit 3: Either alt key is down (some machines, left only) 0x8
+    //   bit 2: Either ctrl key is down         0x4
+    //   bit 1: Left shift key is down          0x2
+    //   bit 0: Right shift key is down         0x1
+
+    regs.h.ah = 0x12;
+    int86(KEYBOARD_INT, &regs, &regs);
+    mod_flags = regs.x.ax;
+
+    if (mod_flags & 0x4000) {
+        MOD_SET(mod, KMOD_CAPS);
+    }
+    if (mod_flags & 0x2000) {
+        MOD_SET(mod, KMOD_NUM);
+    }
+    if (mod_flags & 0x8) {
+        MOD_SET(mod, KMOD_ALT);
+    }
+    if (mod_flags & 0x4) {
+        MOD_SET(mod, KMOD_CTRL);
+    }
+    if (mod_flags & 0x2) {
+        MOD_SET(mod, KMOD_LSHIFT);
+    }
+    if (mod_flags & 0x1) {
+        MOD_SET(mod, KMOD_RSHIFT);
+    }
+
+
+    if (IS_MOD_SET(mod, KMOD_CAPS)) {
+        if (IS_FAKE_MOD_SET(FAKE_MOD_CL_CTRL)) {
+            MOD_UNSET(mod, KMOD_CAPS);
+            MOD_SET(mod, KMOD_CTRL);
+        } else if (IS_FAKE_MOD_SET(FAKE_MOD_CL_ALT)) {
+            MOD_UNSET(mod, KMOD_CAPS);
+            MOD_SET(mod, KMOD_ALT);
+        }
+    }
+
+    if (IS_MOD_SET(mod, KMOD_NUM)) {
+        if (IS_FAKE_MOD_SET(FAKE_MOD_NL_CTRL)) {
+            MOD_UNSET(mod, KMOD_NUM);
+            MOD_SET(mod, KMOD_CTRL);
+        } else if (IS_FAKE_MOD_SET(FAKE_MOD_NL_ALT)) {
+            MOD_UNSET(mod, KMOD_NUM);
+            MOD_SET(mod, KMOD_ALT);
+        }
+    }
+
+    if (IS_MOD_SET(mod, KMOD_RSHIFT)) {
+        if (IS_FAKE_MOD_SET(FAKE_MOD_RS_CTRL)) {
+            MOD_UNSET(mod, KMOD_RSHIFT);
+            MOD_SET(mod, KMOD_CTRL);
+        } else if (IS_FAKE_MOD_SET(FAKE_MOD_RS_ALT)) {
+            MOD_UNSET(mod, KMOD_RSHIFT);
+            MOD_SET(mod, KMOD_ALT);
+        }
+    }
+
+    if (IS_MOD_SET(mod, KMOD_LSHIFT)) {
+        if (IS_FAKE_MOD_SET(FAKE_MOD_LS_CTRL)) {
+            MOD_UNSET(mod, KMOD_LSHIFT);
+            MOD_SET(mod, KMOD_CTRL);
+        } else if (IS_FAKE_MOD_SET(FAKE_MOD_LS_ALT)) {
+            MOD_UNSET(mod, KMOD_LSHIFT);
+            MOD_SET(mod, KMOD_ALT);
+        }
+    }
+
+    // return mod | JOYSTICK_MODIFIERS;
+    return mod;
+}
+
+// Return the number of milliseconds since the SDL library initialization.
+// Due to DOS, resolution is 50 ms (5/100 second).
+Uint32 SDL_GetTicks(void) {
+  return get_millis() - TICKS_EPOCH;
+}
+
+
+// Returns array of SDL_Rect
+SDL_Rect ** SDL_ListModes(SDL_PixelFormat *format, Uint32 flags) {
+    (void)format;
+    (void) flags;
+
+    screen_rect.x = 0;
+    screen_rect.y = 0;
+    screen_rect.w = FDOS_SCREEN_WIDTH;
+    screen_rect.h = FDOS_SCREEN_HEIGHT;
+
+    screen_modes[0] = &screen_rect;
+    screen_modes[1] = NULL; // Terminate list.
+
+    return screen_modes;
+}
+
+// Locking a surface is not enforced. Always returns 0.
+int SDL_LockSurface(SDL_Surface * surface){
+    surface->locked++;
+    return 0;
+}
+
+// Return the index of the color that most closely matches r, g, b.
+Uint32 SDL_MapRGB(const SDL_PixelFormat * format, Uint8 r, Uint8 g, Uint8 b){
+    return SDL_FindColor(format->palette, r, g, b);
+}
+
+
+void SDL_Quit(void) {
+    union REGS regs;
+
+    // Set video (Text mode)
+    regs.h.ah = 0x00;
+    regs.h.al = 0x03; // 80x25 16 color
+    // regs.h.al = 0x07; // 80x25 black/white
+    int86(VIDEO_INT, &regs, &regs);
+
+    // Reset typematic rate
+    regs.h.ah = 0x03; // set rate function
+    regs.h.al = 0x00; // reset to default delay
+    int86(KEYBOARD_INT, &regs, &regs);
+
+    // Disable direct accett to lower 640K.
+    __djgpp_nearptr_disable();
+}
+
+
+// Palettized (8-bit) screen surfaces with the SDL_HWPALETTE flag have two
+// palettes, a logical palette that is used for mapping blits to/from the
+// surface and a physical palette (that determines how the hardware will map
+// the colors to the display). SDL_SetColors modifies both palettes
+// (if present), and is equivalent to calling SDL_SetPalette with the flags set
+// to (SDL_LOGPAL | SDL_PHYSPAL).
+// Copied from ./src/video/SDL_video.c
+int SDL_SetColors(SDL_Surface *screen, SDL_Color *colors, int firstcolor, int ncolors){
+    return SDL_SetPalette(screen, SDL_LOGPAL | SDL_PHYSPAL, colors, firstcolor, ncolors);
+}
+
+
+// VGA only uses the lower six bits of each color byte. Shifting the value of
+// the actual color value right by two bits will give approximately the same
+// color when displayed by VGA hardware.
+// Writing to the VGA_PALETTE_COLOR_PORT will automatically advance the index.
+int SDL_SetPalette(SDL_Surface *surface, int flags, SDL_Color *colors, int firstcolor, int ncolors) {
+    int i;
+
+    if (firstcolor < 0 || firstcolor >= 256) {
+        printf("Err: firstcolor must be between 0 and 255.\n");
+        return -1;
+    }
+    if ( (ncolors != 1) && (ncolors != 256) ) {
+        printf("Warn: ncolors must be 1 or 256\n");
+        return -1;
+    }
+
+    if (flags & SDL_PHYSPAL) {
+        if (ncolors == 1) {
+            outp(VGA_PALETTE_INDEX_PORT, firstcolor); // Index palette to change
+            outp(VGA_PALETTE_COLOR_PORT, colors[0].r >> 2);
+            outp(VGA_PALETTE_COLOR_PORT, colors[0].g >> 2);
+            outp(VGA_PALETTE_COLOR_PORT, colors[0].b >> 2);
+        } else { //  ncolors == 256
+            outp(VGA_PALETTE_INDEX_PORT, 0); // Signal output 256 colors.
+            for(i=0; i<256; i++)
+            {
+                outp(VGA_PALETTE_COLOR_PORT, colors[i].r >> 2);
+                outp(VGA_PALETTE_COLOR_PORT, colors[i].g >> 2);
+                outp(VGA_PALETTE_COLOR_PORT, colors[i].b >> 2);
+            }
+        }
+    }
+
+    if (surface) {
+        if (ncolors == 1) {
+            surface->format->palette->colors[firstcolor].r = colors[0].r;
+            surface->format->palette->colors[firstcolor].g = colors[0].g;
+            surface->format->palette->colors[firstcolor].b = colors[0].b;
+        } else { // ncolors == 256
+            for(i=0; i<256; i++)
+            {
+                surface->format->palette->colors[i].r = colors[i].r;
+                surface->format->palette->colors[i].g = colors[i].g;
+                surface->format->palette->colors[i].b = colors[i].b;
+            }
+        }
+    }
+
+    return 0;
+}
+
+
+// The 'visible' parameter should be SDL_ENABLE or SDL_DISABLE.
+// The value passed in will be returned.
+int SDL_ShowCursor(int visible) {
+    union REGS regs;
+    if (visible) {
+        regs.x.ax=0x1; // show;
+    } else {
+        regs.x.ax=0x2; // hide;
+    }
+    int86(MOUSE_INT, &regs, &regs);
+
+   return visible;
+}
+
+// Locking surfaces is not enforced.
+void SDL_UnlockSurface(SDL_Surface * surface){
+    surface->locked--;
+}
+
+
+// Return 1 on success, otherwise 0.
+int SDL_VideoModeOK(int width, int height, int bpp, Uint32 flags) {
+   if (width != FDOS_SCREEN_WIDTH) return 0;
+   if (height != FDOS_SCREEN_HEIGHT) return 0;
+   if (bpp != 8) return 0;  // 2^8 ==256
+   if (flags != SDL_FULLSCREEN) return 0;
+   return 1;
+}
+
+
+void SDL_WarpMouse(Uint16 x, Uint16 y) {
+    union REGS regs;
+    if (x >= FDOS_SCREEN_WIDTH) x = FDOS_SCREEN_WIDTH - 1;
+    if (y >= FDOS_SCREEN_HEIGHT) y = FDOS_SCREEN_HEIGHT - 1;
+    regs.x.ax=0x4; // set mouse cursor position
+    regs.x.cx=x;   // horz pos
+    regs.x.dx=y;   // vert pos
+    int86(MOUSE_INT, &regs, &regs);
+}
+
+
+void  SDL_WM_SetCaption(const char * s1, const char * s2) {
+  (void)s1;
+  (void)s2;
+  // Ignored
+}
+
+
+void SDL_WM_SetIcon(SDL_Surface *icon, Uint8 *mask) {
+  (void)icon;
+  (void)mask;
+  // Ignored
+}
+
+
+// Except where noted, these (should) match the scancodes listed in keyboard.c.
+int get_sdlkey(unsigned char scancode) {
+    switch(scancode) {
+
+        case 0x00: return SDLK_UNKNOWN; // Pressing Ctrl-2 twice will generate this on second pressing.
+        case 0x01: return SDLK_ESCAPE;
+        case 0x02: return SDLK_1;
+        case 0x03: return SDLK_2;
+        case 0x04: return SDLK_3;
+        case 0x05: return SDLK_4;
+        case 0x06: return SDLK_5;
+        case 0x07: return SDLK_6;
+        case 0x08: return SDLK_7;
+        case 0x09: return SDLK_8;
+        case 0x0a: return SDLK_9;
+        case 0x0b: return SDLK_0;
+        case 0x0c: return SDLK_MINUS;
+        case 0x0d: return SDLK_EQUALS;
+        case 0x0e: return SDLK_BACKSPACE;
+        case 0x0f: return SDLK_TAB;
+        case 0x10: return SDLK_q;
+        case 0x11: return SDLK_w;
+        case 0x12: return SDLK_e;
+        case 0x13: return SDLK_r;
+        case 0x14: return SDLK_t;
+        case 0x15: return SDLK_y;
+        case 0x16: return SDLK_u;
+        case 0x17: return SDLK_i;
+        case 0x18: return SDLK_o;
+        case 0x19: return SDLK_p;
+        case 0x1a: return SDLK_LEFTBRACKET;
+        case 0x1b: return SDLK_RIGHTBRACKET;
+        case 0x1c: return SDLK_RETURN; 
+        case 0x1d: return SDLK_LCTRL; // keyboard.c has SDLK_UNKNOWN
+        case 0x1e: return SDLK_a;
+        case 0x1f: return SDLK_s;
+        case 0x20: return SDLK_d;
+        case 0x21: return SDLK_f;
+        case 0x22: return SDLK_g;
+        case 0x23: return SDLK_h;
+        case 0x24: return SDLK_j;
+        case 0x25: return SDLK_k;
+        case 0x26: return SDLK_l;
+        case 0x27: return SDLK_SEMICOLON;
+        case 0x28: return SDLK_QUOTE;
+        case 0x29: return SDLK_BACKQUOTE;
+        case 0x2a: return SDLK_LSHIFT;  // keyboard.c has SDLK_UNKNOWN
+        case 0x2b: return SDLK_BACKSLASH;
+        case 0x2c: return SDLK_z;
+        case 0x2d: return SDLK_x;
+        case 0x2e: return SDLK_c;
+        case 0x2f: return SDLK_v;
+        case 0x30: return SDLK_b;
+        case 0x31: return SDLK_n;
+        case 0x32: return SDLK_m;
+        case 0x33: return SDLK_COMMA;
+        case 0x34: return SDLK_PERIOD;
+        case 0x35: return SDLK_SLASH;
+        case 0x36: return SDLK_RSHIFT; // keyboard.c has SDLK_UNKNOWN
+        case 0x37: return SDLK_KP_MULTIPLY;
+        case 0x38: return SDLK_LALT; // keyboard.c has SDLK_UNKNOWN
+        case 0x39: return SDLK_SPACE;
+        case 0x3a: return SDLK_CAPSLOCK;  // keyboard.c has SDLK_UNKNOWN
+        case 0x3b: return SDLK_F1;
+        case 0x3c: return SDLK_F2;
+        case 0x3d: return SDLK_F3;
+        case 0x3e: return SDLK_F4;
+        case 0x3f: return SDLK_F5;
+        case 0x40: return SDLK_F6;
+        case 0x41: return SDLK_F7;
+        case 0x42: return SDLK_F8;
+        case 0x43: return SDLK_F9;
+        case 0x44: return SDLK_F10;
+        case 0x45: return SDLK_NUMLOCK; // keyboard.c has SDLK_UNKNOWN
+        case 0x46: return SDLK_SCROLLOCK;  // keyboard.c has SDLK_UNKNOWN
+        case 0x47: return SDLK_HOME;
+        case 0x48: return SDLK_UP;
+        case 0x49: return SDLK_PAGEUP;
+        case 0x4a: return SDLK_KP_MINUS;
+        case 0x4b: return SDLK_LEFT;
+        case 0x4c: return SDLK_KP5;
+        case 0x4d: return SDLK_RIGHT;
+        case 0x4e: return SDLK_KP_PLUS;
+        case 0x4f: return SDLK_END;
+        case 0x50: return SDLK_DOWN;
+        case 0x51: return SDLK_PAGEDOWN;
+        case 0x52: return SDLK_INSERT;
+        case 0x53: return SDLK_DELETE;
+        case 0x54: return SDLK_F1;
+        case 0x55: return SDLK_F2;
+        case 0x56: return SDLK_F3;
+        case 0x57: return SDLK_F4;
+        case 0x58: return SDLK_F5;
+        case 0x59: return SDLK_F6;
+        case 0x5a: return SDLK_F7;
+        case 0x5b: return SDLK_F8;
+        case 0x5c: return SDLK_F9;
+        case 0x5d: return SDLK_F10;
+        case 0x5e: return SDLK_F1;
+        case 0x5f: return SDLK_F2;
+        case 0x60: return SDLK_F3;
+        case 0x61: return SDLK_F4;
+        case 0x62: return SDLK_F5;
+        case 0x63: return SDLK_F6;
+        case 0x64: return SDLK_F7;
+        case 0x65: return SDLK_F8;
+        case 0x66: return SDLK_F9;
+        case 0x67: return SDLK_F10;
+        case 0x68: return SDLK_F1;
+        case 0x69: return SDLK_F2;
+        case 0x6a: return SDLK_F3;
+        case 0x6b: return SDLK_F4;
+        case 0x6c: return SDLK_F5;
+        case 0x6d: return SDLK_F6;
+        case 0x6e: return SDLK_F7;
+        case 0x6f: return SDLK_F8;
+        case 0x70: return SDLK_F9;
+        case 0x71: return SDLK_F10;
+        case 0x72: return SDLK_SYSREQ; // keyboard.c has SDLK_UNKNOWN
+        case 0x73: return SDLK_LEFT;
+        case 0x74: return SDLK_RIGHT;
+        case 0x75: return SDLK_END;
+        case 0x76: return SDLK_PAGEDOWN;
+        case 0x77: return SDLK_HOME;
+        case 0x78: return SDLK_1;
+        case 0x79: return SDLK_2;
+        case 0x7A: return SDLK_3;
+        case 0x7B: return SDLK_4;
+        case 0x7C: return SDLK_5;
+        case 0x7D: return SDLK_6;
+        case 0x7E: return SDLK_7;
+        case 0x7F: return SDLK_8;
+        case 0x80: return SDLK_9;
+        case 0x81: return SDLK_0;
+        case 0x82: return SDLK_MINUS;
+        case 0x83: return SDLK_EQUALS;
+        case 0x84: return SDLK_PAGEUP;
+        case 0x85: return SDLK_F11;
+        case 0x86: return SDLK_F12;
+        case 0x87: return SDLK_F11;
+        case 0x88: return SDLK_F12;
+        case 0x89: return SDLK_F11;
+        case 0x8a: return SDLK_F12;
+        case 0x8b: return SDLK_F11;
+        case 0x8c: return SDLK_F12;
+        case 0x8d: return SDLK_UP;
+        case 0x8e: return SDLK_KP_MINUS;
+        case 0x8f: return SDLK_KP5;
+        case 0x90: return SDLK_KP_PLUS;
+        case 0x91: return SDLK_DOWN;
+        case 0x92: return SDLK_INSERT;
+        case 0x93: return SDLK_DELETE;
+        case 0x94: return SDLK_TAB;
+        case 0x95: return SDLK_KP_DIVIDE;
+        case 0x96: return SDLK_KP_MULTIPLY;
+        case 0x97: return SDLK_HOME;
+        case 0x98: return SDLK_UP;
+        case 0x99: return SDLK_PAGEUP;
+        // 0x9a
+        case 0x9b: return SDLK_LEFT;
+        // 0x9c
+        case 0x9d: return SDLK_RIGHT;
+        // 0x9e
+        case 0x9f: return SDLK_END;
+        case 0xa0: return SDLK_DOWN;
+        case 0xa1: return SDLK_PAGEDOWN;
+        case 0xa2: return SDLK_INSERT;
+        case 0xa3: return SDLK_DELETE;
+        case 0xa4: return SDLK_KP_DIVIDE;
+        case 0xa5: return SDLK_TAB;
+        case 0xa6: return SDLK_KP_ENTER;
+        default:
+            printf("Err: unhandled scancode %x\n", scancode);
+            return SDLK_UNKNOWN;
+    }
+}
+
+
+// This does not actually return a Unicode value (other than 0x01-0x7f).
+// (DOS does not natively support Unicode.)
+// Grafx2 uses the '.unicode' value when entering text in (e.g.) Text window.
+int get_unicode_val(unsigned char ch) {
+    if (ch > 0 && ch < 0x7f) {
+        return ch;
+    }
+    return 0;
+}
+
+
+// When calling DOS_INT/0x7:
+//   if non-zero is return, a key was pressed
+//   if zero is returned, call DOS_INT/0x7 again to get the extended key.
+
+// Keys with extended scancodes is emitted twice by FreeDOS.
+// This function 'swallows' the second emitted key.
+// The Enter on keypad is emitted twice but cannot easily be swallowed because
+// it is exactly the same code as the Enter on the keyboard.
+void swallow_duplicate_scancode(SDLKey sym) {
+    union REGS regs;
+    switch (sym) {
+        case SDLK_HOME:
+        case SDLK_UP:
+        case SDLK_PAGEUP:
+        case SDLK_LEFT:
+        case SDLK_RIGHT:
+        case SDLK_END:
+        case SDLK_DOWN:
+        case SDLK_PAGEDOWN:
+        case SDLK_INSERT:
+        case SDLK_DELETE:
+        // case SDLK_RETURN:
+        // case SDLK_KP_ENTER:
+
+            // Read and ignore
+            regs.h.ah = 0x07;
+            int86(DOS_INT, &regs, &regs);
+
+            // Read and ignore
+            regs.h.ah = 0x07;
+            int86(DOS_INT, &regs, &regs);
+            break;
+        default:
+            // Ignore
+            break;
+    }
+}
+
+
+// Returns 1 if there is a pending event or 0 if there are none available.
+int SDL_PollEvent(SDL_Event * event){
+   union REGS regs;
+   unsigned char dosch = '\0';
+   unsigned char scancode = '\0';
+   SDLKey symch = 0;
+   unsigned int chready = 0;
+   Sint32 mouse_x = 0;
+   Sint32 mouse_y = 0;
+   unsigned int mouse_left   = 0;
+   unsigned int mouse_middle = 0;
+   unsigned int mouse_right  = 0;
+
+    if (!event) {
+        return 0;
+    }
+
+    if (PREV_KEY) {
+        // Simulete a key-up event.
+        event->type = SDL_KEYUP;
+        event->key.type = event->type;
+        event->key.keysym.sym = PREV_KEY;
+        event->key.keysym.scancode = 0;
+        event->key.keysym.unicode = 0;
+        event->key.keysym.mod = 0;
+        PREV_KEY = 0; // Clear
+        return 1;
+    }
+
+    // Check if a key has been pressed
+    regs.h.ah = 0x0b;
+    int86(DOS_INT, &regs, &regs);
+    chready = regs.h.al;
+
+    if (chready) {
+
+        // Peek at scancode. Does not remove data from keyboard buffer.
+        regs.h.ah = 0x01;
+        int86(KEYBOARD_INT, &regs, &regs);
+        scancode = regs.h.ah;
+
+        // Read key from keyboard buffer
+        regs.h.ah = 0x7;
+        int86(DOS_INT, &regs, &regs);
+        dosch = regs.h.al;
+
+        if (dosch == 0) {
+
+            // Read (extended) key from keyboard buffer
+            regs.h.ah = 0x07;
+            int86(DOS_INT, &regs, &regs);
+            scancode = regs.h.al;
+
+            symch = get_sdlkey(scancode);
+
+            swallow_duplicate_scancode(symch);
+
+        } else if (dosch > 0 && dosch < 0x7f) {
+
+            symch = get_sdlkey(scancode);
+
+        } else {
+            // Ignore (0x0 or 0x7f).
+            return 0;
+        }
+
+
+        event->type = SDL_KEYDOWN;
+        event->key.type = event->type;
+        event->key.keysym.sym = symch; // SDL Keysym
+        event->key.keysym.scancode = scancode;
+        event->key.keysym.unicode = get_unicode_val(dosch);
+        event->key.keysym.mod = 0; // Not used. Grafx2 uses SDL_GetModState().
+
+        PREV_KEY = symch;
+        return 1;
+    }
+
+  
+    // Get mouse status and button states.
+    // Middle mouse button is not supported by FreeDOS driver.
+    // The interrupt often returns invalid values for mouse_x and mouse_y.
+    // This results is a 'moving' mouse.
+    regs.x.ax = 0x3;
+    int86(MOUSE_INT, &regs, &regs);
+    // Shouldn't need to '&0xFFF' but if not, sometimes values are way out of
+    // line.
+    mouse_x = regs.x.cx & 0xFFF; // 0..639
+    mouse_y = regs.x.dx & 0xFFF; // 0..199
+    mouse_left  = regs.x.bx & 0x1;
+    mouse_right = regs.x.bx & 0x2;
+    mouse_middle = regs.x.bx & 0x4;
+
+    if (mouse_left != PREV_MOUSE_BTN_LEFT) { // left button changed
+        event->type = (mouse_left ? SDL_MOUSEBUTTONDOWN : SDL_MOUSEBUTTONUP);
+        event->button.type = event->type;
+        event->button.button = SDL_BUTTON_LEFT;
+        PREV_MOUSE_BTN_LEFT = mouse_left;
+        return 1;
+    }
+
+    if (mouse_right != PREV_MOUSE_BTN_RIGHT) { // right button changed
+        event->type = (mouse_right ? SDL_MOUSEBUTTONDOWN : SDL_MOUSEBUTTONUP);
+        event->button.type = event->type;
+        event->button.button = SDL_BUTTON_RIGHT;
+        PREV_MOUSE_BTN_RIGHT = mouse_right;
+        return 1;
+    }
+
+    if (mouse_middle != PREV_MOUSE_BTN_MIDDLE) { // middle button changed
+        event->type = (mouse_right ? SDL_MOUSEBUTTONDOWN : SDL_MOUSEBUTTONUP);
+        event->button.type = event->type;
+        event->button.button = SDL_BUTTON_MIDDLE;
+        PREV_MOUSE_BTN_MIDDLE = mouse_right;
+        return 1;
+    }
+
+    if (mouse_x != PREV_MOUSE_X || mouse_y != PREV_MOUSE_Y) { // mouse moved
+        event->type = SDL_MOUSEMOTION;
+        event->motion.type = event->type;
+        event->motion.x = mouse_x;
+        event->motion.y = mouse_y;
+        PREV_MOUSE_X = mouse_x;
+        PREV_MOUSE_Y = mouse_y;
+        return 1;
+    }    
+
+    return 0;
+}
+
+
+// Returns a surface of 320x200 with 8bpp, (regardless of 'width', 'height' or
+// 'bpp' parameters) or NULL on failure; The 'flags' value is mostly ignored.
+SDL_Surface *SDL_SetVideoMode(int width, int height, int bpp, Uint32 flags) {
+   union REGS regs;
+
+    if (width != FDOS_SCREEN_WIDTH) {
+        fprintf(stderr, "Ignoring width %d; only %d is supported.\n", width, FDOS_SCREEN_WIDTH);
+    }
+    if (height != FDOS_SCREEN_HEIGHT) {
+        fprintf(stderr, "Ignoring height %d; only %d is supported.\n", height, FDOS_SCREEN_HEIGHT);
+    }
+    if (bpp != 8) {
+        fprintf(stderr, "Ignoring bpp %d; only 8 is supported.\n", bpp);
+    }
+    if (flags & SDL_FULLSCREEN) {
+        fprintf(stderr, "SDL_FULLSCREEN is not supported; removing flag.\n");
+        flags &= ~SDL_FULLSCREEN;
+    }
+    // The SDL_RESIZABLE flag is also not supported, but we'll ignore it.
+
+    // set video (Graphics mode)
+    regs.h.ah = 0x00;
+    regs.h.al = 0x13; // set 256 color mode
+    int86(VIDEO_INT, &regs, &regs);
+
+    return malloc_surface(flags, FDOS_SCREEN_WIDTH, FDOS_SCREEN_HEIGHT, 8, 0, 0, 0, 0);
+}
+
+
+
+
+
+
+
+// If set, the SD_COLORKEY defines a pixel value that will be treated as
+// transparent when blitting.
+int SDL_SetColorKey(SDL_Surface * surface, int flag, Uint32 key) {
+    if (flag & SDL_SRCCOLORKEY) {
+        surface->flags |= SDL_SRCCOLORKEY; // Enable
+        surface->format->colorkey = key;
+    } else if (flag == 0) {
+        surface->flags &= ~SDL_SRCCOLORKEY; // Disable
+        surface->format->colorkey = 0; // Set color index to 0.
+    }
+    return 0;
+}
+
+
+// Convert format of 'surface' to one that is suitable for displaying.
+// When running on DOS, this simply returns a copy of 'surface'.
+SDL_Surface *SDL_DisplayFormat(SDL_Surface *surface) {
+    int i;
+    SDL_Surface * surf = NULL;
+    surf = malloc_surface(surface->flags, surface->w, surface->h, surface->format->BitsPerPixel, surface->format->Rmask, surface->format->Gmask, surface->format->Bmask, surface->format->Amask);
+    if (surf) {
+        // copy pixels
+        memcpy(surf->pixels, surface->pixels, surface->h * surface->w * surface->format->BytesPerPixel);
+
+        // copy palette
+        for (i=0; i<surface->format->palette->ncolors; i++) {
+            surf->format->palette->colors[i].r = surface->format->palette->colors[i].r;
+            surf->format->palette->colors[i].g = surface->format->palette->colors[i].g;
+            surf->format->palette->colors[i].b = surface->format->palette->colors[i].b;
+            surf->format->palette->colors[i].a = surface->format->palette->colors[i].a;
+        }
+    }
+    return surf;
+}
+
+
+// Performs a blit from the source surface to the destination surface.
+// Returns 0 if the blit is successful or a negative value on failure.
+int SDL_BlitSurface(SDL_Surface* src, const SDL_Rect* src_rect, SDL_Surface* dst, SDL_Rect* dst_rect){
+    int x, y;
+    unsigned int src_offs;
+    unsigned int dst_offs;
+    unsigned char * src_ptr;
+    unsigned char * dst_ptr;
+    int do_copy = 0;
+    unsigned char px = 0;
+
+    if (src_rect->w != dst_rect->w) {
+        printf("Err: width not equal\n");
+        return -1;
+    }
+    if (src_rect->h !=  dst_rect->h) {
+        printf("Err: height not equal\n");
+        return -1;
+    }
+    if (src->format->BytesPerPixel != 1) {
+        printf("Err: src BytesPerPixel not 1 %d\n", src->format->BytesPerPixel);
+        return -1;
+    }
+    if (dst->format->BytesPerPixel != 1) {
+        printf("Err: dst BytesPerPixel not equal %d\n", dst->format->BytesPerPixel);
+        return -1;
+    }
+
+    src_offs = ((src_rect->y * src->w) + src_rect->x) * src->format->BytesPerPixel;
+    dst_offs = ((dst_rect->y * dst->w) + dst_rect->x) * dst->format->BytesPerPixel;
+
+    for (y=0; y<src_rect->h; y++) {
+        for (x=0; x<src_rect->w; x++) {
+            if (src_rect->x + x < src->w && src_rect->y + y < src->h &&
+                dst_rect->x + x < dst->w && dst_rect->y + y < dst->h) {
+
+                  src_ptr = (src->pixels + src_offs + (((y * src->w) + x) * src->format->BytesPerPixel));
+                  dst_ptr = (dst->pixels + dst_offs + (((y * dst->w) + x) * dst->format->BytesPerPixel));
+
+                  px = *(src_ptr);
+
+                  // Per SDL documentation, if SDL_SRCCOLORKEY is set, only
+                  // copy pixels that do not match colorkey.
+                  do_copy = ((src->flags & SDL_SRCCOLORKEY) ? (px != src->format->colorkey) : 1);
+                  if (do_copy) {
+                      *(dst_ptr) = px;
+                  }
+           }
+        }
+    }
+    return 0;
+}
+
+#endif
diff -ruN gfx2orig/src/SDL_endian.h grafx2/src/SDL_endian.h
--- gfx2orig/src/SDL_endian.h	1969-12-31 18:00:00.000000000 -0600
+++ grafx2/src/SDL_endian.h	2022-03-20 20:19:34.108495316 -0500
@@ -0,0 +1 @@
+// This file only exists to satisfy '#include' directives in source files.
diff -ruN gfx2orig/src/SDL.h grafx2/src/SDL.h
--- gfx2orig/src/SDL.h	1969-12-31 18:00:00.000000000 -0600
+++ grafx2/src/SDL.h	2022-03-20 20:19:34.112495316 -0500
@@ -0,0 +1,595 @@
+// SDL - Simple DirectMedia Layer
+// This is not a port of SDL; it emulates the functionality needed for Grafx2.
+
+#ifndef _SDL_H_
+#define _SDL_H_
+
+typedef unsigned char      Uint8;
+typedef unsigned short int Uint16;
+typedef signed short       Sint16;
+typedef unsigned int       Uint32;
+typedef signed long        Sint32;
+
+
+/* Make sure the types really have the right sizes */
+#define SDL_COMPILE_TIME_ASSERT(name, x)               \
+       typedef int SDL_dummy_ ## name[(x) * 2 - 1]
+
+SDL_COMPILE_TIME_ASSERT(uint8, sizeof(Uint8) == 1);
+SDL_COMPILE_TIME_ASSERT(uint16, sizeof(Uint16) == 2);
+SDL_COMPILE_TIME_ASSERT(sint16, sizeof(Sint16) == 2);
+SDL_COMPILE_TIME_ASSERT(uint32, sizeof(Uint32) == 4);
+SDL_COMPILE_TIME_ASSERT(sint32, sizeof(Sint32) == 4);
+
+
+// Allows using alternate keys for modifiers.
+//  LS  Left Shift
+//  RS  Right Shift
+//  CL  Caps Lock
+//  NL  Num Lock
+// Athough it is technically possible to set both (e.g.) LS_ALT and LS_CTRL,
+// exactly one or zero should be set.
+#define FAKE_MOD_LS_ALT   0x0001
+#define FAKE_MOD_LS_CTRL  0x0002
+#define FAKE_MOD_RS_ALT   0x0004
+#define FAKE_MOD_RS_CTRL  0x0008
+#define FAKE_MOD_CL_ALT   0x0010
+#define FAKE_MOD_CL_CTRL  0x0020
+#define FAKE_MOD_NL_ALT   0x0040
+#define FAKE_MOD_NL_CTRL  0x0080
+// #define FAKE_MOD_TOG_NL   0x0100
+// #define FAKE_MOD_TOG_CL   0x0200
+
+
+
+// from SDL_sysjoystick.h
+typedef struct SDL_Joystick
+{
+  // Dummy
+} SDL_Joystick;
+
+typedef struct SDL_Color
+{
+    Uint8 r;
+    Uint8 g;
+    Uint8 b;
+    Uint8 a;
+} SDL_Color;
+
+typedef struct SDL_Palette
+{
+    int ncolors;
+    SDL_Color *colors;
+    Uint32 version;
+    int refcount;
+} SDL_Palette;
+
+typedef struct SDL_PixelFormat
+{
+    SDL_Palette *palette;
+    Uint8  BitsPerPixel;
+    Uint8  BytesPerPixel;
+    Uint8  Rloss;
+    Uint8  Gloss;
+    Uint8  Bloss;
+    Uint8  Aloss;
+    Uint8  Rshift;
+    Uint8  Gshift;
+    Uint8  Bshift;
+    Uint8  Ashift;
+    Uint32 Rmask;
+    Uint32 Gmask;
+    Uint32 Bmask;
+    Uint32 Amask;
+
+    /** RGB color key information */
+    Uint32 colorkey;
+    /** Alpha value information (per-surface alpha) */
+    Uint8  alpha;
+} SDL_PixelFormat;
+
+
+
+typedef struct SDL_Rect
+{
+    int x, y;
+    int w, h;
+} SDL_Rect;
+
+typedef struct SDL_Surface
+{
+    Uint32 flags;               /**< Read-only */
+    SDL_PixelFormat *format;    /**< Read-only */
+    int w, h;                   /**< Read-only */
+    Uint16 pitch;                  /**< Read-only */
+    void *pixels;               /**< Read-write */
+
+    /** clipping information */
+    SDL_Rect clip_rect;         /**< Read-only */
+
+    /** information needed for surfaces requiring locks */
+    Uint32 locked;                 /**< Read-only */
+
+    /** Reference count -- used when freeing surface */
+    int refcount;               /**< Read-mostly */
+} SDL_Surface;
+
+
+
+typedef Sint32 SDL_Keycode;
+
+
+typedef enum {
+        /** @name ASCII mapped keysyms
+         *  The keyboard syms have been cleverly chosen to map to ASCII
+         */
+        /*@{*/
+    SDLK_UNKNOWN      = 0,
+    SDLK_FIRST        = 0,
+    SDLK_BACKSPACE    = 8,
+    SDLK_TAB          = 9,
+    SDLK_CLEAR        = 12,
+    SDLK_RETURN       = 13,
+    SDLK_PAUSE        = 19,
+    SDLK_ESCAPE       = 27,
+    SDLK_SPACE        = 32,
+    SDLK_EXCLAIM      = 33,
+    SDLK_QUOTEDBL     = 34,
+    SDLK_HASH         = 35,
+    SDLK_DOLLAR       = 36,
+    SDLK_AMPERSAND    = 38,
+    SDLK_QUOTE        = 39,
+    SDLK_LEFTPAREN    = 40,
+    SDLK_RIGHTPAREN   = 41,
+    SDLK_ASTERISK     = 42,
+    SDLK_PLUS         = 43,
+    SDLK_COMMA        = 44,
+    SDLK_MINUS        = 45,
+    SDLK_PERIOD       = 46,
+    SDLK_SLASH        = 47,
+    SDLK_0            = 48,
+    SDLK_1            = 49,
+    SDLK_2            = 50,
+    SDLK_3            = 51,
+    SDLK_4            = 52,
+    SDLK_5            = 53,
+    SDLK_6            = 54,
+    SDLK_7            = 55,
+    SDLK_8            = 56,
+    SDLK_9            = 57,
+    SDLK_COLON        = 58,
+    SDLK_SEMICOLON    = 59,
+    SDLK_LESS         = 60,
+    SDLK_EQUALS       = 61,
+    SDLK_GREATER      = 62,
+    SDLK_QUESTION     = 63,
+    SDLK_AT           = 64,
+    /* 
+       Skip uppercase letters
+     */
+    SDLK_LEFTBRACKET  = 91,
+    SDLK_BACKSLASH    = 92,
+    SDLK_RIGHTBRACKET = 93,
+    SDLK_CARET        = 94,
+    SDLK_UNDERSCORE   = 95,
+    SDLK_BACKQUOTE    = 96,
+    SDLK_a            = 97,
+    SDLK_b            = 98,
+    SDLK_c            = 99,
+    SDLK_d            = 100,
+    SDLK_e            = 101,
+    SDLK_f            = 102,
+    SDLK_g            = 103,
+    SDLK_h            = 104,
+    SDLK_i            = 105,
+    SDLK_j            = 106,
+    SDLK_k            = 107,
+    SDLK_l            = 108,
+    SDLK_m            = 109,
+    SDLK_n            = 110,
+    SDLK_o            = 111,
+    SDLK_p            = 112,
+    SDLK_q            = 113,
+    SDLK_r            = 114,
+    SDLK_s            = 115,
+    SDLK_t            = 116,
+    SDLK_u            = 117,
+    SDLK_v            = 118,
+    SDLK_w            = 119,
+    SDLK_x            = 120,
+    SDLK_y            = 121,
+    SDLK_z            = 122,
+    SDLK_DELETE       = 127,
+    /* End of ASCII mapped keysyms */
+        /*@}*/
+
+    /** @name International keyboard syms */
+        /*@{*/
+    SDLK_WORLD_0      = 160,    /* 0xA0 */
+    SDLK_WORLD_1      = 161,
+    SDLK_WORLD_2      = 162,
+    SDLK_WORLD_3      = 163,
+    SDLK_WORLD_4      = 164,
+    SDLK_WORLD_5      = 165,
+    SDLK_WORLD_6      = 166,
+    SDLK_WORLD_7      = 167,
+    SDLK_WORLD_8      = 168,
+    SDLK_WORLD_9      = 169,
+    SDLK_WORLD_10     = 170,
+    SDLK_WORLD_11     = 171,
+    SDLK_WORLD_12     = 172,
+    SDLK_WORLD_13     = 173,
+    SDLK_WORLD_14     = 174,
+    SDLK_WORLD_15     = 175,
+    SDLK_WORLD_16     = 176,
+    SDLK_WORLD_17     = 177,
+    SDLK_WORLD_18     = 178,
+    SDLK_WORLD_19     = 179,
+    SDLK_WORLD_20     = 180,
+    SDLK_WORLD_21     = 181,
+    SDLK_WORLD_22     = 182,
+    SDLK_WORLD_23     = 183,
+    SDLK_WORLD_24     = 184,
+    SDLK_WORLD_25     = 185,
+    SDLK_WORLD_26     = 186,
+    SDLK_WORLD_27     = 187,
+    SDLK_WORLD_28     = 188,
+    SDLK_WORLD_29     = 189,
+    SDLK_WORLD_30     = 190,
+    SDLK_WORLD_31     = 191,
+    SDLK_WORLD_32     = 192,
+    SDLK_WORLD_33     = 193,
+    SDLK_WORLD_34     = 194,
+    SDLK_WORLD_35     = 195,
+    SDLK_WORLD_36     = 196,
+    SDLK_WORLD_37     = 197,
+    SDLK_WORLD_38     = 198,
+    SDLK_WORLD_39     = 199,
+    SDLK_WORLD_40     = 200,
+    SDLK_WORLD_41     = 201,
+    SDLK_WORLD_42     = 202,
+    SDLK_WORLD_43     = 203,
+    SDLK_WORLD_44     = 204,
+    SDLK_WORLD_45     = 205,
+    SDLK_WORLD_46     = 206,
+    SDLK_WORLD_47     = 207,
+    SDLK_WORLD_48     = 208,
+    SDLK_WORLD_49     = 209,
+    SDLK_WORLD_50     = 210,
+    SDLK_WORLD_51     = 211,
+    SDLK_WORLD_52     = 212,
+    SDLK_WORLD_53     = 213,
+    SDLK_WORLD_54     = 214,
+    SDLK_WORLD_55     = 215,
+    SDLK_WORLD_56     = 216,
+    SDLK_WORLD_57     = 217,
+    SDLK_WORLD_58     = 218,
+    SDLK_WORLD_59     = 219,
+    SDLK_WORLD_60     = 220,
+    SDLK_WORLD_61     = 221,
+    SDLK_WORLD_62     = 222,
+    SDLK_WORLD_63     = 223,
+    SDLK_WORLD_64     = 224,
+    SDLK_WORLD_65     = 225,
+    SDLK_WORLD_66     = 226,
+    SDLK_WORLD_67     = 227,
+    SDLK_WORLD_68     = 228,
+    SDLK_WORLD_69     = 229,
+    SDLK_WORLD_70     = 230,
+    SDLK_WORLD_71     = 231,
+    SDLK_WORLD_72     = 232,
+    SDLK_WORLD_73     = 233,
+    SDLK_WORLD_74     = 234,
+    SDLK_WORLD_75     = 235,
+    SDLK_WORLD_76     = 236,
+    SDLK_WORLD_77     = 237,
+    SDLK_WORLD_78     = 238,
+    SDLK_WORLD_79     = 239,
+    SDLK_WORLD_80     = 240,
+    SDLK_WORLD_81     = 241,
+    SDLK_WORLD_82     = 242,
+    SDLK_WORLD_83     = 243,
+    SDLK_WORLD_84     = 244,
+    SDLK_WORLD_85     = 245,
+    SDLK_WORLD_86     = 246,
+    SDLK_WORLD_87     = 247,
+    SDLK_WORLD_88     = 248,
+    SDLK_WORLD_89     = 249,
+    SDLK_WORLD_90     = 250,
+    SDLK_WORLD_91     = 251,
+    SDLK_WORLD_92     = 252,
+    SDLK_WORLD_93     = 253,
+    SDLK_WORLD_94     = 254,
+    SDLK_WORLD_95     = 255,    /* 0xFF */
+        /*@}*/
+
+    /** @name Numeric keypad */
+        /*@{*/
+    SDLK_KP0          = 256,
+    SDLK_KP1          = 257,
+    SDLK_KP2          = 258,
+    SDLK_KP3          = 259,
+    SDLK_KP4          = 260,
+    SDLK_KP5          = 261,
+    SDLK_KP6          = 262,
+    SDLK_KP7          = 263,
+    SDLK_KP8          = 264,
+    SDLK_KP9          = 265,
+    SDLK_KP_PERIOD    = 266,
+    SDLK_KP_DIVIDE    = 267,
+    SDLK_KP_MULTIPLY  = 268,
+    SDLK_KP_MINUS     = 269,
+    SDLK_KP_PLUS      = 270,
+    SDLK_KP_ENTER     = 271,
+    SDLK_KP_EQUALS    = 272,
+        /*@}*/
+
+    /** @name Arrows + Home/End pad */
+        /*@{*/
+    SDLK_UP           = 273,
+    SDLK_DOWN         = 274,
+    SDLK_RIGHT        = 275,
+    SDLK_LEFT         = 276,
+    SDLK_INSERT       = 277,
+    SDLK_HOME         = 278,
+    SDLK_END          = 279,
+    SDLK_PAGEUP       = 280,
+    SDLK_PAGEDOWN     = 281,
+        /*@}*/
+
+    /** @name Function keys */
+        /*@{*/
+    SDLK_F1           = 282,
+    SDLK_F2           = 283,
+    SDLK_F3           = 284,
+    SDLK_F4           = 285,
+    SDLK_F5           = 286,
+    SDLK_F6           = 287,
+    SDLK_F7           = 288,
+    SDLK_F8           = 289,
+    SDLK_F9           = 290,
+    SDLK_F10          = 291,
+    SDLK_F11          = 292,
+    SDLK_F12          = 293,
+    SDLK_F13          = 294,
+    SDLK_F14          = 295,
+    SDLK_F15          = 296,
+        /*@}*/
+
+    /** @name Key state modifier keys */
+        /*@{*/
+    SDLK_NUMLOCK      = 300,
+    SDLK_CAPSLOCK     = 301,
+    SDLK_SCROLLOCK    = 302,
+    SDLK_RSHIFT       = 303,
+    SDLK_LSHIFT       = 304,
+    SDLK_RCTRL        = 305,
+    SDLK_LCTRL        = 306,
+    SDLK_RALT         = 307,
+    SDLK_LALT         = 308,
+    SDLK_RMETA        = 309,
+    SDLK_LMETA        = 310,
+    SDLK_LSUPER       = 311,    /**< Left "Windows" key */
+    SDLK_RSUPER       = 312,   /**< Right "Windows" key */
+    SDLK_MODE         = 313,   /**< "Alt Gr" key */
+    SDLK_COMPOSE      = 314,    /**< Multi-key compose key */
+        /*@}*/
+
+    /** @name Miscellaneous function keys */
+        /*@{*/
+    SDLK_HELP         = 315,
+    SDLK_PRINT        = 316,
+    SDLK_SYSREQ       = 317,
+    SDLK_BREAK        = 318,
+    SDLK_MENU         = 319,
+    SDLK_POWER        = 320,    /**< Power Macintosh power key */
+    SDLK_EURO         = 321,   /**< Some european keyboards */
+    SDLK_UNDO         = 322,   /**< Atari keyboard has Undo */
+        /*@}*/
+
+    /* Add any other keys here */
+
+    SDLK_LAST
+} SDLKey;
+
+typedef enum {
+  KMOD_NONE  = 0x0000,
+  KMOD_LSHIFT= 0x0001,
+  KMOD_RSHIFT= 0x0002,
+  KMOD_LCTRL = 0x0040,
+  KMOD_RCTRL = 0x0080,
+  KMOD_LALT  = 0x0100,
+  KMOD_RALT  = 0x0200,
+  KMOD_LMETA = 0x0400,
+  KMOD_RMETA = 0x0800,
+  KMOD_NUM   = 0x1000,
+  KMOD_CAPS  = 0x2000,
+  KMOD_MODE  = 0x4000,
+} SDLMod;
+
+#define KMOD_CTRL   (KMOD_LCTRL  | KMOD_RCTRL )
+#define KMOD_SHIFT  (KMOD_LSHIFT | KMOD_RSHIFT)
+#define KMOD_ALT    (KMOD_LALT   | KMOD_RALT  )
+#define KMOD_META   (KMOD_LMETA  | KMOD_RMETA )
+
+typedef struct SDL_keysym {
+    Uint8 scancode;    /**< hardware specific scancode */
+    SDLKey sym;        /**< SDL virtual keysym */
+    SDLMod mod;        /**< current key modifiers */
+    Uint16 unicode;    /**< translated character */
+} SDL_keysym;
+
+
+/** Joystick button event structure */
+typedef struct SDL_JoyButtonEvent {
+    Uint8 type;   /**< SDL_JOYBUTTONDOWN or SDL_JOYBUTTONUP */
+    Uint8 which;  /**< The joystick device index */
+    Uint8 button; /**< The joystick button index */
+    Uint8 state;  /**< SDL_PRESSED or SDL_RELEASED */
+} SDL_JoyButtonEvent;
+
+/** Joystick axis motion event structure */
+typedef struct SDL_JoyAxisEvent {
+    Uint8 type;   /**< SDL_JOYAXISMOTION */
+    Uint8 which;  /**< The joystick device index */
+    Uint8 axis;   /**< The joystick axis index */
+    Sint16 value; /**< The axis value (range: -32768 to 32767) */
+} SDL_JoyAxisEvent;
+
+typedef struct{
+  Uint8 type;
+} SDL_QuitEvent;
+
+typedef struct{
+    Uint32 type;
+    int w;
+    int h;
+} SDL_ResizeEvent;
+
+typedef struct SDL_KeyboardEvent
+{
+    Uint32 type;        /**< ::SDL_KEYDOWN or ::SDL_KEYUP */
+    Uint32 timestamp;
+    Uint32 windowID;    /**< The window with keyboard focus, if any */
+    Uint8 state;        /**< ::SDL_PRESSED or ::SDL_RELEASED */
+    Uint8 repeat;       /**< Non-zero if this is a key repeat */
+    Uint8 padding2;
+    Uint8 padding3;
+    SDL_keysym keysym;  /**< The key that was pressed or released */
+} SDL_KeyboardEvent;
+
+
+typedef struct SDL_MouseMotionEvent
+{
+    Uint32 type;        /**< ::SDL_MOUSEMOTION */
+    Uint8 state;        /**< The current button state */
+    Sint32 x;           /**< X coordinate, relative to window */
+    Sint32 y;           /**< Y coordinate, relative to window */
+    Sint32 xrel;        /**< The relative motion in the X direction */
+    Sint32 yrel;        /**< The relative motion in the Y direction */
+} SDL_MouseMotionEvent;
+
+typedef struct SDL_MouseButtonEvent
+{
+    Uint32 type;        /**< ::SDL_MOUSEBUTTONDOWN or ::SDL_MOUSEBUTTONUP */
+    Uint8 button;       /**< The mouse button index */
+    Uint8 state;        /**< ::SDL_PRESSED or ::SDL_RELEASED */
+    Uint8 padding1;
+    Uint8 padding2;
+    Sint32 x;           /**< X coordinate, relative to window */
+    Sint32 y;           /**< Y coordinate, relative to window */
+} SDL_MouseButtonEvent;
+
+typedef union SDL_Event
+{
+    Uint32 type;                    /**< Event type, shared with all events */
+     SDL_KeyboardEvent key;          /**< Keyboard event data */
+     SDL_MouseMotionEvent motion;    /**< Mouse motion event data */
+     SDL_MouseButtonEvent button;    /**< Mouse button event data */
+     SDL_QuitEvent quit;             /**< Quit request event data */
+     SDL_JoyAxisEvent jaxis;
+     SDL_JoyButtonEvent jbutton;
+  // 
+  //   / * This is necessary for ABI compatibility between Visual C++ and GCC
+  //      Visual C++ will respect the push pack pragma and use 52 bytes for
+  //      this structure, and GCC will use the alignment of the largest datatype
+  //      within the union, which is 8 bytes.
+  //      So... we'll add padding to force the size to be 56 bytes for both.
+  //   * /
+     Uint8 padding[56];
+} SDL_Event;
+
+
+// From SDL_video.h
+#define SDL_SWSURFACE   0x00000000    /**< Surface is in system memory */
+
+#define SDL_FULLSCREEN  0x80000000    /**< Surface is a full screen display */
+#define SDL_RESIZABLE   0x00000010    /**< This video mode may be resized */
+
+#define SDL_LOGPAL  0x01
+#define SDL_PHYSPAL 0x02
+
+#define SDL_SRCCOLORKEY 0x00001000    /**< Blit uses a source color key */
+
+
+
+
+
+
+
+
+
+#define SDL_INIT_TIMER    0x00000001
+#define SDL_INIT_VIDEO    0x00000020
+#define SDL_INIT_JOYSTICK 0x00000200
+
+
+
+
+// SDL Events
+typedef enum {
+    SDL_NOEVENT = 0,
+    SDL_KEYDOWN,
+    SDL_KEYUP,
+    SDL_MOUSEMOTION,
+    SDL_MOUSEBUTTONDOWN,
+    SDL_MOUSEBUTTONUP,
+    SDL_JOYAXISMOTION,
+    SDL_JOYBUTTONDOWN,
+    SDL_JOYBUTTONUP,
+    SDL_VIDEORESIZE,
+    SDL_QUIT
+} SDL_EventType;
+
+
+// SDL_mouse.h
+#define SDL_BUTTON_LEFT       1
+#define SDL_BUTTON_MIDDLE     2
+#define SDL_BUTTON_RIGHT      3
+#define SDL_BUTTON_WHEELUP    4
+#define SDL_BUTTON_WHEELDOWN  5
+
+
+// For SDL_ShowCursor
+#define SDL_ENABLE  1
+#define SDL_DISABLE 0
+
+
+
+
+SDL_Surface * IMG_Load(char * path);
+
+int            SDL_BlitSurface(SDL_Surface* src, const SDL_Rect* srcrect, SDL_Surface* dst, SDL_Rect* dstrect);
+SDL_Surface*   SDL_CreateRGBSurface(Uint32 flags, int width, int height, int depth, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask);
+void           SDL_Delay(int ms);
+SDL_Surface *  SDL_DisplayFormat(SDL_Surface *surface);
+void           SDL_EnableKeyRepeat(int a, int b);
+void           SDL_EnableUNICODE(int flag);
+int            SDL_FillRect(SDL_Surface * dst, const SDL_Rect * rect, Uint32 color);
+void           SDL_FreeSurface(SDL_Surface * icon);
+SDLMod         SDL_GetModState(void);
+void           SDL_SetModState(SDLMod mod);
+Uint32         SDL_GetTicks(void);
+int            SDL_Init(int flags);
+SDL_Joystick * SDL_JoystickOpen(int num);
+SDL_Rect **    SDL_ListModes(SDL_PixelFormat *format, Uint32 flags);
+int            SDL_LockSurface(SDL_Surface * surface);
+Uint32         SDL_MapRGB(const SDL_PixelFormat * format, Uint8 r, Uint8 g, Uint8 b);
+int            SDL_PollEvent(SDL_Event * event);
+void           SDL_Quit(void);
+int            SDL_SetColorKey(SDL_Surface * surface, int flag, Uint32 key);
+int            SDL_SetColors(SDL_Surface *surface, SDL_Color *colors, int firstcolor, int ncolors);
+int            SDL_SetPalette(SDL_Surface *surface, int flags, SDL_Color *colors, int firstcolor, int ncolors);
+SDL_Surface *  SDL_SetVideoMode(int width, int height, int bpp, Uint32 flags);
+int            SDL_ShowCursor(int toggle);
+void           SDL_UnlockSurface(SDL_Surface * surface);
+void           SDL_UpdateRect(SDL_Surface *screen, Sint32 x, Sint32 y, Sint32 w, Sint32 h);
+int            SDL_VideoModeOK(int width, int height, int bpp, Uint32 flags);
+void           SDL_WarpMouse(Uint16 x, Uint16 y);
+void           SDL_WM_SetCaption(const char * s1, const char * s2);
+void           SDL_WM_SetIcon(SDL_Surface *icon, Uint8 *mask);
+
+void reset_video(void);
+void set_fake_modifiers(Uint32 fake_mods);
+void mod_prev_mouse_position(void);
+#endif
diff -ruN gfx2orig/src/SDL_image.h grafx2/src/SDL_image.h
--- gfx2orig/src/SDL_image.h	1969-12-31 18:00:00.000000000 -0600
+++ grafx2/src/SDL_image.h	2022-03-20 20:19:34.112495316 -0500
@@ -0,0 +1,6 @@
+#ifndef _SDL_IMAGE_H
+#define _SDL_IMAGE_H
+
+#include "SDL.h"
+
+#endif /* _SDL_IMAGE_H */
\ No newline at end of file
diff -ruN gfx2orig/src/sdlscreen.c grafx2/src/sdlscreen.c
--- gfx2orig/src/sdlscreen.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/sdlscreen.c	2022-03-20 20:19:34.112495316 -0500
@@ -66,7 +66,7 @@
   {
     DEBUG("Error: Unable to change video mode!",0);
   }
-  SDL_ShowCursor(0); // Hide the SDL mouse cursor, we use our own
+  SDL_ShowCursor(SDL_DISABLE); // Hide the SDL mouse cursor, we use our own
 }
 
 #if (UPDATE_METHOD == UPDATE_METHOD_CUMULATED)
@@ -162,6 +162,10 @@
   else
     remainder=0;
 
+#if defined(FDOS)
+    remainder = 0;
+#endif
+
   if (dest==NULL)
     dest=(byte *)malloc(source->w*source->h);
 
@@ -184,7 +188,7 @@
   color.r = Main_palette[index].R;
   color.g = Main_palette[index].G;
   color.b = Main_palette[index].B;
-  color.unused = 255;
+
   return color;
 }
 
diff -ruN gfx2orig/src/SDL_syswm.h grafx2/src/SDL_syswm.h
--- gfx2orig/src/SDL_syswm.h	1969-12-31 18:00:00.000000000 -0600
+++ grafx2/src/SDL_syswm.h	2022-03-20 20:19:34.108495316 -0500
@@ -0,0 +1 @@
+// This file only exists to satisfy '#include' directives in source files.
diff -ruN gfx2orig/src/SDL_video.h grafx2/src/SDL_video.h
--- gfx2orig/src/SDL_video.h	1969-12-31 18:00:00.000000000 -0600
+++ grafx2/src/SDL_video.h	2022-03-20 20:19:34.108495316 -0500
@@ -0,0 +1 @@
+// This file only exists to satisfy '#include' directives in source files.
diff -ruN gfx2orig/src/setup.c grafx2/src/setup.c
--- gfx2orig/src/setup.c	2010-03-17 15:31:10.000000000 -0500
+++ grafx2/src/setup.c	2022-03-20 20:19:34.108495316 -0500
@@ -188,15 +188,15 @@
         strcat(config_dir,Config_SubDir);
         if (Directory_exists(config_dir))
         {
-          // Répertoire trouvé, ok
+          // RÃ©pertoire trouvÃ©, ok
           strcat(config_dir,PATH_SEPARATOR);
         }
         else
         {
-          // Tentative de création
+          // Tentative de crÃ©ation
           if (!Create_ConfigDirectory(config_dir)) 
           {
-            // Réussi
+            // RÃ©ussi
             strcat(config_dir,PATH_SEPARATOR);
           }
           else
diff -ruN gfx2orig/src/shade.c grafx2/src/shade.c
--- gfx2orig/src/shade.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/shade.c	2022-03-20 20:19:34.112495316 -0500
@@ -110,7 +110,7 @@
     {
       // On regarde quel shade on va afficher en preview
       shade_processed=((y_pos-start_y)*nb_shades)/y_size;
-      // Si ce n'est pas le shade précédemment traité on calcule ses infos
+      // Si ce n'est pas le shade prÃ©cÃ©demment traitÃ© on calcule ses infos
       if (shade_processed>shade_processed_old)
       {
         // On commence par sauter tous les vides jusqu'au prochain shade
@@ -162,7 +162,7 @@
       x_pos=Window_pos_X+(Menu_factor_X*((column<<2)+8));
       y_pos=Window_pos_Y+(Menu_factor_Y*((line*7)+131));
 
-      // On regarde si la case est "disablée"
+      // On regarde si la case est "disablÃ©e"
       if (Shade_list[Shade_current].List[position]&0x8000)
       {
         if ((position>=selection_start) && (position<=selection_end))
@@ -173,7 +173,7 @@
         else
           Block(x_pos,y_pos,Menu_factor_X<<2,Menu_factor_Y<<1,MC_White);
       }
-      else // "enablée"
+      else // "enablÃ©e"
       {
         if ((position>=selection_start) && (position<=selection_end))
           Block(x_pos,y_pos,Menu_factor_X<<2,Menu_factor_Y<<1,MC_Black);
@@ -295,8 +295,8 @@
     first_color=temp;
   }
 
-  // Avant d'insérer quoi que ce soit, on efface les éventuelles couleurs que
-  // l'on va réinsérer:
+  // Avant d'insÃ©rer quoi que ce soit, on efface les Ã©ventuelles couleurs que
+  // l'on va rÃ©insÃ©rer:
   limit=512-selection_start;
   for (cursor=0; cursor<512; cursor++)
   {
@@ -306,7 +306,7 @@
           && ((Shade_list[Shade_current].List[cursor]&0xFF)==temp) )
           Shade_list[Shade_current].List[cursor]=(Shade_list[Shade_current].List[cursor]&0x8000)|0x0100;
   }
-  // Voilà... Maintenant on peut y aller peinard.
+  // VoilÃ ... Maintenant on peut y aller peinard.
 
   temp=1+last_color-first_color;
   limit=selection_start+temp;
@@ -384,7 +384,7 @@
   temp_shade=(word *)malloc(512*sizeof(word));
   memcpy(temp_shade,Shade_list[Shade_current].List,512*sizeof(word));
 
-  // On calcul les dernières couleurs de chaque bloc.
+  // On calcul les derniÃ¨res couleurs de chaque bloc.
   end_1=block_1_start+block_size-1;
   end_2=block_2_start+block_size-1;
 
@@ -395,7 +395,7 @@
     {
       // Il faut transformer la case pos_1 en pos_2:
       Shade_list[Shade_current].List[pos_1]=temp_shade[pos_2];
-      // On gère la mise à jour de pos_2
+      // On gÃ¨re la mise Ã  jour de pos_2
       if (pos_2==end_2)
         pos_2=block_1_start;
       else
@@ -405,12 +405,12 @@
   else
   if ((block_2_start<block_1_start) && (end_2>=block_1_start))
   {
-    // Le bloc destination déborde dans le bloc source.
+    // Le bloc destination dÃ©borde dans le bloc source.
     for (pos_1=block_2_start,pos_2=block_1_start;pos_1<=end_1;pos_1++)
     {
       // Il faut transformer la couleur pos_1 en pos_2:
       Shade_list[Shade_current].List[pos_1]=temp_shade[pos_2];
-      // On gère la mise à jour de pos_2
+      // On gÃ¨re la mise Ã  jour de pos_2
       if (pos_2==end_1)
         pos_2=block_2_start;
       else
@@ -422,7 +422,7 @@
     // Le bloc source et le bloc destination sont distincts.
     for (pos_1=block_1_start,pos_2=block_2_start;pos_1<=end_1;pos_1++,pos_2++)
     {
-      // On échange les cases
+      // On Ã©change les cases
       temp                                  =Shade_list[Shade_current].List[pos_1];
       Shade_list[Shade_current].List[pos_1]=Shade_list[Shade_current].List[pos_2];
       Shade_list[Shade_current].List[pos_2]=temp;
@@ -435,9 +435,9 @@
 
 int Menu_shade(void)
 {
-  short clicked_button; // Numéro du bouton sur lequel l'utilisateur a clické
-  char str[4]; // str d'affichage du n° de shade actif et du Pas
-  word old_mouse_x, old_mouse_x2; // Mémo. de l'ancienne pos. du curseur
+  short clicked_button; // NumÃ©ro du bouton sur lequel l'utilisateur a clickÃ©
+  char str[4]; // str d'affichage du nÂ° de shade actif et du Pas
+  word old_mouse_x, old_mouse_x2; // MÃ©mo. de l'ancienne pos. du curseur
   word old_mouse_y, old_mouse_y2;
   byte old_mouse_k, old_mouse_k2;
   byte temp_color; // Variables de gestion des clicks dans la palette
@@ -459,53 +459,53 @@
   undo_buffer  =(word *)malloc(512*sizeof(word));
   temp_ptr=(word *)malloc(512*sizeof(word));
 
-  // Ouverture de la fenêtre du menu
+  // Ouverture de la fenÃªtre du menu
   Open_window(310,190,"Shade");
 
-  // Déclaration & tracé du bouton de palette
+  // DÃ©claration & tracÃ© du bouton de palette
   Window_set_palette_button(5,16);                             // 1
 
-  // Déclaration & tracé du scroller de sélection du n° de dégradé
+  // DÃ©claration & tracÃ© du scroller de sÃ©lection du nÂ° de dÃ©gradÃ©
   Window_set_scroller_button(192,17,84,8,1,Shade_current);      // 2
 
-  // Déclaration & tracé de la zone de définition des dégradés
+  // DÃ©claration & tracÃ© de la zone de dÃ©finition des dÃ©gradÃ©s
   Window_set_special_button(8,127,256,53);                     // 3
 
-  // Déclaration & tracé des boutons de sortie
+  // DÃ©claration & tracÃ© des boutons de sortie
   Window_set_normal_button(207,17,51,14,"Cancel",0,1,KEY_ESC);   // 4
   Window_set_normal_button(261,17,43,14,"OK"    ,0,1,SDLK_RETURN);  // 5
 
-  // Déclaration & tracé des boutons de copie de shade
+  // DÃ©claration & tracÃ© des boutons de copie de shade
   Window_set_normal_button(206,87,27,14,"Cpy"   ,1,1,SDLK_c);  // 6
   Window_set_normal_button(234,87,43,14,"Paste" ,1,1,SDLK_p);  // 7
 
   // On tagge le bloc
   Tag_color_range(Fore_color,Fore_color);
 
-  // Tracé d'un cadre creux autour du bloc dégradé
+  // TracÃ© d'un cadre creux autour du bloc dÃ©gradÃ©
   Window_display_frame_in(171,26,18,66);
   Block(Window_pos_X+(Menu_factor_X*172),Window_pos_Y+(Menu_factor_Y*27),
         Menu_factor_X<<4,Menu_factor_Y<<6,MC_Black);
-  // Tracé d'un cadre creux autour de tous les dégradés
+  // TracÃ© d'un cadre creux autour de tous les dÃ©gradÃ©s
   Window_display_frame_in(223,34,66,50);
   Shade_draw_grad_ranges();
-  // Tracé d'un cadre autour de la zone de définition de dégradés
+  // TracÃ© d'un cadre autour de la zone de dÃ©finition de dÃ©gradÃ©s
   Window_display_frame(5,124,262,61);
   Display_all_shade(first_color,last_color,selection_start,selection_end);
 
-  // Déclaration & tracé des boutons d'édition de shade
+  // DÃ©claration & tracÃ© des boutons d'Ã©dition de shade
   Window_set_normal_button(  6,107,27,14,"Ins"  ,0,1,SDLK_INSERT);  // 8
   Window_set_normal_button( 38,107,27,14,"Del"  ,0,1,SDLK_DELETE);  // 9
   Window_set_normal_button( 66,107,43,14,"Blank",1,1,SDLK_b);  // 10
   Window_set_normal_button(110,107,27,14,"Inv"  ,1,1,SDLK_i);  // 11
   Window_set_normal_button(138,107,27,14,"Swp"  ,1,1,SDLK_s);  // 12
 
-  // Déclaration & tracé des boutons de taggage
+  // DÃ©claration & tracÃ© des boutons de taggage
   Print_in_window(268,123,"Disbl"/*"Dsabl"*/,MC_Dark,MC_Light);
   Window_set_normal_button(274,133,27,14,"Set"   ,0,1,SDLK_F1); // 13
   Window_set_normal_button(274,148,27,14,"Clr"   ,0,1,SDLK_F2); // 14
 
-  // Déclaration & tracé de la zone de saisie du pas
+  // DÃ©claration & tracÃ© de la zone de saisie du pas
   Print_in_window(272,165,"Step",MC_Dark,MC_Light);
   input_button = Window_set_input_button(274,174,3);          // 15
   Num2str(Shade_list[Shade_current].Step,str,3);
@@ -519,7 +519,7 @@
   // Button Mode
   Window_set_normal_button(244,107,60,14,"",0,1,SDLK_TAB);       // 18
 
-  // Affichage du n° de shade actif
+  // Affichage du nÂ° de shade actif
   Num2str(Shade_current+1,str,1);
   Print_in_window(210,55,str,MC_Black,MC_Light);
 
@@ -552,11 +552,11 @@
           if (!old_mouse_k)
           { // On vient de clicker
 
-            // On met à jour l'intervalle du Shade
+            // On met Ã  jour l'intervalle du Shade
             first_color=last_color=temp_color;
             // On tagge le bloc
             Tag_color_range(first_color,last_color);
-            // Tracé du bloc dégradé:
+            // TracÃ© du bloc dÃ©gradÃ©:
             Display_grad_block_in_window(172,27,first_color,last_color);
           }
           else
@@ -579,7 +579,7 @@
             }
           }
 
-          // On affiche le numéro de la couleur sélectionnée
+          // On affiche le numÃ©ro de la couleur sÃ©lectionnÃ©e
           Display_selected_color(first_color,last_color);
 
           Display_cursor();
@@ -589,20 +589,20 @@
       case  2 : // Gestion du changement de Shade (scroller)
         Hide_cursor();
         Shade_current=Window_attribute2;
-        // Affichade du n° de shade actif
+        // Affichade du nÂ° de shade actif
         Num2str(Shade_current+1,str,1);
         Print_in_window(210,55,str,MC_Black,MC_Light);
         // Affichade du Pas
         Num2str(Shade_list[Shade_current].Step,str,3);
         Print_in_window(276,176,str,MC_Black,MC_Light);
-        // Tracé du bloc dégradé:
+        // TracÃ© du bloc dÃ©gradÃ©:
         Display_all_shade(first_color,last_color,selection_start,selection_end);
         Display_cursor();
         // On place le nouveau shade dans le buffer du Undo
         memcpy(undo_buffer,Shade_list[Shade_current].List,512*sizeof(word));
         break;
 
-      case  3 : // Gestion de la zone de définition de shades
+      case  3 : // Gestion de la zone de dÃ©finition de shades
         if (((((Mouse_Y-Window_pos_Y)/Menu_factor_Y)-127)%7)<4)
         if ( (Mouse_X!=old_mouse_x2) || (Mouse_Y!=old_mouse_y2) || (Mouse_K!=old_mouse_k2) )
         {
@@ -647,12 +647,12 @@
         else
           temp=first_color-last_color;
 
-        if (selection_start==selection_end) // Une couleur sélectionnée
+        if (selection_start==selection_end) // Une couleur sÃ©lectionnÃ©e
         {
           if (Window_attribute1==2)
             Remove_shade(selection_start,selection_start+temp);
         }
-        else                          // Un bloc sélectionné
+        else                          // Un bloc sÃ©lectionnÃ©
         {
           Remove_shade(selection_start,selection_end);
 
@@ -679,7 +679,7 @@
         }
         Insert_shade(first_color,last_color,selection_start);
 
-        // On sélectionne la position juste après ce qu'on vient d'insérer
+        // On sÃ©lectionne la position juste aprÃ¨s ce qu'on vient d'insÃ©rer
         selection_start+=temp+1;
         if (selection_start>=512)
           selection_start=511;
@@ -784,7 +784,7 @@
           // On place le shade dans le buffer du Undo
           memcpy(undo_buffer,Shade_list[Shade_current].List,512*sizeof(word));
           // Et on le modifie
-          // On échange le bloc avec sa destination
+          // On Ã©change le bloc avec sa destination
           if (selection_start<=selection_end)
           {
             temp=(temp_cell+selection_end-selection_start<512)?selection_end+1-selection_start:512-temp_cell;
@@ -795,7 +795,7 @@
             temp=(temp_cell+selection_start-selection_end<512)?selection_start+1-selection_end:512-temp_cell;
             Swap_shade(selection_end,temp_cell,temp);
           }
-          // On place la sélection sur la nouvelle position du bloc
+          // On place la sÃ©lection sur la nouvelle position du bloc
           selection_start=temp_cell;
           selection_end=selection_start+temp-1;
           // Et on raffiche tout
@@ -885,8 +885,8 @@
     if (!Mouse_K)
     switch (Key)
     {
-      case SDLK_LEFTBRACKET : // Décaler couleur dans palette vers la gauche
-      case SDLK_RIGHTBRACKET : // Décaler couleur dans palette vers la droite
+      case SDLK_LEFTBRACKET : // DÃ©caler couleur dans palette vers la gauche
+      case SDLK_RIGHTBRACKET : // DÃ©caler couleur dans palette vers la droite
         if (first_color==last_color)
         {
           if (Key==SDLK_LEFTBRACKET)
@@ -904,7 +904,7 @@
           Block(Window_pos_X+(Menu_factor_X*172),
                 Window_pos_Y+(Menu_factor_Y*27),
                 Menu_factor_X<<4,Menu_factor_Y*64,first_color);
-          // On affiche le numéro de la couleur sélectionnée
+          // On affiche le numÃ©ro de la couleur sÃ©lectionnÃ©e
           Display_selected_color(first_color,last_color);
           Display_cursor();
         }
@@ -959,7 +959,7 @@
         Key=0;
         break;
 
-      case SDLK_BACKQUOTE : // Récupération d'une couleur derrière le menu
+      case SDLK_BACKQUOTE : // RÃ©cupÃ©ration d'une couleur derriÃ¨re le menu
       case SDLK_COMMA :
         Get_color_behind_window(&color,&click);
         if (click)
@@ -967,14 +967,14 @@
           Hide_cursor();
           temp_color=color;
 
-          // On met à jour l'intervalle du Shade
+          // On met Ã  jour l'intervalle du Shade
           first_color=last_color=temp_color;
           // On tagge le bloc
           Tag_color_range(first_color,last_color);
-          // Tracé du bloc dégradé:
+          // TracÃ© du bloc dÃ©gradÃ©:
           Display_grad_block_in_window(172,27,first_color,last_color);
 
-          // On affiche le numéro de la couleur sélectionnée
+          // On affiche le numÃ©ro de la couleur sÃ©lectionnÃ©e
           Display_selected_color(first_color,last_color);
 
           Display_cursor();
@@ -1006,11 +1006,11 @@
 /// @return true if user clicked ok, false if he cancelled
 int Shade_settings_menu(void)
 {
-  T_Shade * initial_shade_list; // Anciennes données des shades
-  byte old_shade; // old n° de shade actif
+  T_Shade * initial_shade_list; // Anciennes donnÃ©es des shades
+  byte old_shade; // old nÂ° de shade actif
   int return_code;
 
-  // Backup des anciennes données
+  // Backup des anciennes donnÃ©es
   initial_shade_list=(T_Shade *)malloc(sizeof(Shade_list));
   memcpy(initial_shade_list,Shade_list,sizeof(Shade_list));
   old_shade=Shade_current;
@@ -1054,7 +1054,7 @@
   int temp;
   char str[4];
   byte step_backup=Quick_shade_step; // Backup des
-  byte loop_backup=Quick_shade_loop; // anciennes données
+  byte loop_backup=Quick_shade_loop; // anciennes donnÃ©es
   T_Special_button * step_button;
 
   Open_window(142,56,"Quick-shade");
@@ -1064,7 +1064,7 @@
   Window_set_normal_button(76,18,60,14,"",0,1,SDLK_TAB);          // 3
   Display_shade_mode(83,21,Quick_shade_loop);
 
-  // Déclaration & tracé de la zone de saisie du pas
+  // DÃ©claration & tracÃ© de la zone de saisie du pas
   Print_in_window(5,21,"Step",MC_Dark,MC_Light);
   step_button = Window_set_input_button(40,19,3);                  // 4
   Num2str(Quick_shade_step,str,3);
@@ -1123,7 +1123,7 @@
   }
   else // OK
   {
-    // Si avant de rentrer dans le menu on n'était pas en mode Quick-Shade
+    // Si avant de rentrer dans le menu on n'Ã©tait pas en mode Quick-Shade
     if (!Quick_shade_mode)
       Button_Quick_shade_mode(); // => On y passe (cool!)
   }
diff -ruN gfx2orig/src/shim.c grafx2/src/shim.c
--- gfx2orig/src/shim.c	1969-12-31 18:00:00.000000000 -0600
+++ grafx2/src/shim.c	2022-03-20 20:19:34.112495316 -0500
@@ -0,0 +1,19 @@
+#include <stdio.h>  // vsnprintf
+#include <string.h> // strcpy
+#include <stdarg.h> // va_start
+#include <stddef.h> // size_t
+
+// The caller must ensure that the formatted string does not exceed buf.
+int snprintf(char* str, size_t size, const char* format, ...)
+{
+    char buf[400];
+    int r;
+
+    va_list args;
+    va_start(args, format);
+    r = vsprintf(buf, format, args);
+    va_end(args);
+    buf[size -1] = '\0';
+    strcpy(str, buf);
+    return r;
+}
diff -ruN gfx2orig/src/shim.h grafx2/src/shim.h
--- gfx2orig/src/shim.h	1969-12-31 18:00:00.000000000 -0600
+++ grafx2/src/shim.h	2022-03-20 20:19:34.108495316 -0500
@@ -0,0 +1,7 @@
+#ifdef _SHIM_H
+#define _SHIM_H
+
+int snprintf(char* str, size_t size, const char* format, ...);
+
+#endif
+
diff -ruN gfx2orig/src/special.c grafx2/src/special.c
--- gfx2orig/src/special.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/special.c	2022-03-20 20:19:34.108495316 -0500
@@ -35,7 +35,7 @@
 
 
 
-//---------------------- Modifier le pinceau spécial -------------------------
+//---------------------- Modifier le pinceau spÃ©cial -------------------------
 
 int Circle_squared_diameter(int diameter)
 {
@@ -310,7 +310,7 @@
   Display_cursor();
 }
 
-// ------------------- Scroller l'écran (pas en mode loupe) ------------------
+// ------------------- Scroller l'Ã©cran (pas en mode loupe) ------------------
 void Scroll_screen(short delta_x,short delta_y)
 {
   short temp_x_offset;
@@ -344,7 +344,7 @@
 }
 
 
-// ---------------------- Scroller la fenêtre de la loupe --------------------
+// ---------------------- Scroller la fenÃªtre de la loupe --------------------
 void Scroll_magnifier(short delta_x,short delta_y)
 {
   short temp_x_offset;
@@ -380,7 +380,7 @@
 }
 
 
-// -------------- Changer le Zoom (grâce aux touches [+] et [-]) -------------
+// -------------- Changer le Zoom (grÃ¢ce aux touches [+] et [-]) -------------
 void Zoom(short delta)
 {
   short index;
diff -ruN gfx2orig/src/struct.h grafx2/src/struct.h
--- gfx2orig/src/struct.h	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/struct.h	2022-03-20 20:19:34.112495316 -0500
@@ -323,11 +323,11 @@
   byte Grid_XOR_color;                   ///< XOR value to apply for grid color.
 } T_Config;
 
-// Structures utilisées pour les descriptions de pages et de liste de pages.
-// Lorsqu'on gèrera les animations, il faudra aussi des listes de listes de
+// Structures utilisÃ©es pour les descriptions de pages et de liste de pages.
+// Lorsqu'on gÃ¨rera les animations, il faudra aussi des listes de listes de
 // pages.
 
-// Ces structures sont manipulées à travers des fonctions de gestion du
+// Ces structures sont manipulÃ©es Ã  travers des fonctions de gestion du
 // backup dans "graph.c".
 
 /// This is the data for one step of Undo/Redo, for one image.
diff -ruN gfx2orig/src/text.c grafx2/src/text.c
--- gfx2orig/src/text.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/text.c	2022-03-20 20:19:34.112495316 -0500
@@ -21,7 +21,7 @@
     along with Grafx2; if not, see <http://www.gnu.org/licenses/>
 */
 
-// Pour désactiver le support TrueType, définir NOTTF
+// Pour dÃ©sactiver le support TrueType, dÃ©finir NOTTF
 // To disable TrueType support, define NOTTF
 
 #include <string.h>
@@ -64,15 +64,15 @@
   int    Is_bitmap;
   char   Label[22];
   
-  // Liste chainée simple
+  // Liste chainÃ©e simple
   struct T_Font * Next;
   struct T_Font * Previous;
 } T_Font;
-// Liste chainée des polices de texte
+// Liste chainÃ©e des polices de texte
 T_Font * font_list_start;
 int Nb_fonts;
 
-// Inspiré par Allegro
+// InspirÃ© par Allegro
 #define EXTID(a,b,c) ((((a)&255)<<16) | (((b)&255)<<8) | (((c)&255)))
 #define EXTID4(a,b,c,d) ((((a)&255)<<24) | (((b)&255)<<16) | (((c)&255)<<8) | (((d)&255)))
 
@@ -85,7 +85,7 @@
   return strcmp(font_1->Label, font_2->Label);
 }
 
-// Ajout d'une fonte à la liste.
+// Ajout d'une fonte Ã  la liste.
 void Add_font(const char *name)
 {
   char * font_name;
@@ -93,7 +93,7 @@
   int size=strlen(name)+1;
   int index;
   
-  // Détermination du type:
+  // DÃ©termination du type:
 
 #if defined(__macosx__)
 
@@ -205,7 +205,7 @@
       searched_font=font_list_start;
       while (searched_font->Next && (compare=Compare_fonts(font, searched_font->Next))>0)
         searched_font=searched_font->Next;
-      // Après searched_font
+      // AprÃ¨s searched_font
       if (compare==0 && strcmp(font->Name, searched_font->Next->Name)==0)
       {
         // Doublon
@@ -221,7 +221,7 @@
 }
 
 
-// Trouve le nom d'une fonte par son numéro
+// Trouve le nom d'une fonte par son numÃ©ro
 char * Font_name(int index)
 {
   T_Font *font = font_list_start;
@@ -233,7 +233,7 @@
 }
 
 
-// Trouve le libellé d'affichage d'une fonte par son numéro
+// Trouve le libellÃ© d'affichage d'une fonte par son numÃ©ro
 // Renvoie un pointeur sur un buffer statique de 20 caracteres.
 char * Font_label(int index)
 {
@@ -249,13 +249,13 @@
   while (index--)
     font = font->Next;
   
-  // Libellé
+  // LibellÃ©
   strcpy(label, font->Label);
   return label;
 }
 
 
-// Vérifie si une fonte donnée est TrueType
+// VÃ©rifie si une fonte donnÃ©e est TrueType
 int TrueType_font(int index)
 {
   T_Font *font = font_list_start;
@@ -268,7 +268,7 @@
 
 
 
-// Initialisation à faire une fois au début du programme
+// Initialisation Ã  faire une fois au dÃ©but du programme
 void Init_text(void)
 {
   char directory_name[MAX_PATH_CHARACTERS];
@@ -280,13 +280,13 @@
   // Initialisation des fontes
   font_list_start = NULL;
   Nb_fonts=0;
-  // Parcours du répertoire "fonts"
+  // Parcours du rÃ©pertoire "fonts"
   strcpy(directory_name, Data_directory);
   strcat(directory_name, "fonts");
   For_each_file(directory_name, Add_font);
   
   #if defined(__WIN32__)
-    // Parcours du répertoire systeme windows "fonts"
+    // Parcours du rÃ©pertoire systeme windows "fonts"
     #ifndef NOTTF
     {
       char * WindowsPath=getenv("windir");
@@ -298,7 +298,7 @@
     }
     #endif
   #elif defined(__macosx__)
-    // Récupération de la liste des fonts avec fontconfig
+    // RÃ©cupÃ©ration de la liste des fonts avec fontconfig
     #ifndef NOTTF
 
 
@@ -356,7 +356,7 @@
   #endif
 }
 
-// Informe si texte.c a été compilé avec l'option de support TrueType ou pas.
+// Informe si texte.c a Ã©tÃ© compilÃ© avec l'option de support TrueType ou pas.
 int TrueType_is_supported()
 {
   #ifdef NOTTF
@@ -406,7 +406,7 @@
   }
 
   
-  // Rendu du texte: crée une surface SDL RGB 24bits
+  // Rendu du texte: crÃ©e une surface SDL RGB 24bits
   if (antialias)
     TexteColore=TTF_RenderText_Shaded(font, str, Couleur_Avant, Couleur_Arriere );
   else
@@ -457,6 +457,10 @@
   SDL_Surface *Surface_fonte;
   byte * new_brush;
   SDL_Rect rectangle;
+#if defined(FDOS)
+  int i;
+  unsigned char* pxp;
+#endif
 
   // Chargement de la fonte
   Surface_fonte=IMG_Load(Font_name(font_number));
@@ -476,7 +480,19 @@
   *height=SFont_TextHeight(font);
   *width=SFont_TextWidth(font, str);
   // Allocation d'une surface SDL
+#if defined(FDOS)
+  // DOS only supports an 8-bit surface (i.e. 256 colors).
+  TexteColore=SDL_CreateRGBSurface(SDL_SWSURFACE, *width, *height, 8, 0, 0, 0, 0);
+  // Copy main palette to newly created surface.
+  for(i=0; i<256; i++) {
+     TexteColore->format->palette->colors[i].r = Main_palette[i].R;
+     TexteColore->format->palette->colors[i].g = Main_palette[i].G;
+     TexteColore->format->palette->colors[i].b = Main_palette[i].B;
+  }
+#else
   TexteColore=SDL_CreateRGBSurface(SDL_SWSURFACE, *width, *height, 24, 0, 0, 0, 0);
+#endif
+
   // Fill with backcolor
   rectangle.x=0;
   rectangle.y=0;
@@ -497,6 +513,15 @@
     return NULL;
   }
   
+#if defined(FDOS)
+  for (i=0; i<TexteColore->w * TexteColore->h; i++) {
+      pxp = TexteColore->pixels + i;
+      if (*pxp != Back_color) {
+          *pxp = Fore_color;
+      }
+  }
+#endif
+
   Texte8Bit=SDL_DisplayFormat(TexteColore);
   SDL_FreeSurface(TexteColore);
     
@@ -521,8 +546,8 @@
   #define TTFONLY
 #endif
 
-// Crée une brosse à partir des paramètres de texte demandés.
-// Si cela réussit, la fonction place les dimensions dans width et height, 
+// CrÃ©e une brosse Ã  partir des paramÃ¨tres de texte demandÃ©s.
+// Si cela rÃ©ussit, la fonction place les dimensions dans width et height, 
 // et retourne l'adresse du bloc d'octets.
 byte *Render_text(const char *str, int font_number, TTFONLY int size, int TTFONLY antialias, TTFONLY int bold, TTFONLY int italic, int *width, int *height)
 {
diff -ruN gfx2orig/src/transform.c grafx2/src/transform.c
--- gfx2orig/src/transform.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/transform.c	2022-03-20 20:19:34.108495316 -0500
@@ -121,9 +121,9 @@
   Window_set_normal_button( 17,140, 27,14,"Y\022" ,1,1,SDLK_y);  // 3
 
   Print_in_window( 84,114,"Rotate",MC_Dark,MC_Light);
-  Window_set_normal_button( 69,125, 37,14,"-90°"  ,0,1,SDLK_LAST); // 4
-  Window_set_normal_button(107,125, 37,14,"+90°"  ,0,1,SDLK_LAST); // 5
-  Window_set_normal_button( 69,140, 75,14,"180°"  ,0,1,SDLK_LAST); // 6
+  Window_set_normal_button( 69,125, 37,14,"-90\xB0"  ,0,1,SDLK_LAST); // 4
+  Window_set_normal_button(107,125, 37,14,"+90\xB0"  ,0,1,SDLK_LAST); // 5
+  Window_set_normal_button( 69,140, 75,14,"180\xB0"  ,0,1,SDLK_LAST); // 6
 
   Print_in_window( 87, 19,"Resize",MC_Dark,MC_Light);
   Window_set_normal_button( 80, 86, 60,14,"RESIZE",1,1,SDLK_r);    // 7
@@ -353,13 +353,13 @@
         break;
       case  2 : // Flip X
       case  3 : // Flip Y      
-      case  6 : // 180° Rotation
+      case  6 : // 180Â° Rotation
         new_width=Main_image_width;
         new_height=Main_image_height;
         break;
       
-      case  4 : // -90° Rotation
-      case  5 : // +90° Rotation
+      case  4 : // -90Â° Rotation
+      case  5 : // +90Â° Rotation
   
         new_width=Main_image_height;
         new_height=Main_image_width;  
@@ -395,19 +395,19 @@
             Flip_Y_lowlevel(Main_backups->Pages->Image[i], Main_image_width, Main_image_height);
           }
           break;
-        case  4 : // -90° Rotation
+        case  4 : // -90Â° Rotation
           for (i=0; i<Main_backups->Pages->Nb_layers; i++)
           {
             Rotate_270_deg_lowlevel(Main_backups->Pages->Next->Image[i], Main_backups->Pages->Image[i], old_width, old_height);
           }
           break;
-        case  5 : // +90° Rotation
+        case  5 : // +90Â° Rotation
           for (i=0; i<Main_backups->Pages->Nb_layers; i++)
           {
             Rotate_90_deg_lowlevel(Main_backups->Pages->Next->Image[i], Main_backups->Pages->Image[i], old_width, old_height);
           }
           break;
-        case  6 : // 180° Rotation
+        case  6 : // 180Â° Rotation
           for (i=0; i<Main_backups->Pages->Nb_layers; i++)
           {
             memcpy(Main_backups->Pages->Image[i],Main_backups->Pages->Next->Image[i],Main_image_width*Main_image_height);
diff -ruN gfx2orig/src/windows.c grafx2/src/windows.c
--- gfx2orig/src/windows.c	2010-03-08 04:15:51.000000000 -0600
+++ grafx2/src/windows.c	2022-03-20 20:19:34.108495316 -0500
@@ -42,9 +42,9 @@
 /// Width of one layer button, in pixels before scaling
 word Layer_button_width = 1;
 
-// L'encapsulation tente une percée...ou un dernier combat.
+// L'encapsulation tente une percÃ©e...ou un dernier combat.
 
-// Nombre de cellules réel dans la palette du menu
+// Nombre de cellules rÃ©el dans la palette du menu
 word Menu_cells_X;
 word Palette_cells_X()
 {
@@ -70,48 +70,48 @@
   Menu_bars[bar].Skin[y*Menu_bars[bar].Skin_width + x] = color;  
 }
 
-// Affichage d'un pixel dans la fenêtre (la fenêtre doit être visible)
+// Affichage d'un pixel dans la fenÃªtre (la fenÃªtre doit Ãªtre visible)
 void Pixel_in_window(word x,word y,byte color)
 {
     Block((x*Menu_factor_X)+Window_pos_X,(y*Menu_factor_Y)+Window_pos_Y,Menu_factor_X,Menu_factor_Y,color);
 }
 
-// Affichage d'un rectangle dans la fenêtre (la fenêtre doit être visible)
+// Affichage d'un rectangle dans la fenÃªtre (la fenÃªtre doit Ãªtre visible)
 void Window_rectangle(word x_pos,word y_pos,word width,word height,byte color)
 {
   Block((x_pos*Menu_factor_X)+Window_pos_X,(y_pos*Menu_factor_Y)+Window_pos_Y,width*Menu_factor_X,height*Menu_factor_Y,color);
 }
 
 
-// -- Affichages de différents cadres dans une fenêtre -----------------------
+// -- Affichages de diffÃ©rents cadres dans une fenÃªtre -----------------------
 
-  // -- Frame général avec couleurs paramètrables --
+  // -- Frame gÃ©nÃ©ral avec couleurs paramÃ¨trables --
 
 void Window_display_frame_generic(word x_pos,word y_pos,word width,word height,
                                     byte color_tl,byte color_br,byte color_s,byte color_tlc,byte color_brc)
-// Paramètres de couleurs:
+// ParamÃ¨tres de couleurs:
 // color_tl =Bords Haut et Gauche
 // color_br =Bords Bas et Droite
 // color_s  =Coins Haut-Droite et Bas-Gauche
 // color_tlc=Coin Haut-Gauche
 // color_brc=Coin Bas-Droite
 {
-  // Bord haut (sans les extrémités)
+  // Bord haut (sans les extrÃ©mitÃ©s)
   Block(Window_pos_X+((x_pos+1)*Menu_factor_X),
         Window_pos_Y+(y_pos*Menu_factor_Y),
         (width-2)*Menu_factor_X,Menu_factor_Y,color_tl);
 
-  // Bord bas (sans les extrémités)
+  // Bord bas (sans les extrÃ©mitÃ©s)
   Block(Window_pos_X+((x_pos+1)*Menu_factor_X),
         Window_pos_Y+((y_pos+height-1)*Menu_factor_Y),
         (width-2)*Menu_factor_X,Menu_factor_Y,color_br);
 
-  // Bord gauche (sans les extrémités)
+  // Bord gauche (sans les extrÃ©mitÃ©s)
   Block(Window_pos_X+(x_pos*Menu_factor_X),
         Window_pos_Y+((y_pos+1)*Menu_factor_Y),
         Menu_factor_X,(height-2)*Menu_factor_Y,color_tl);
 
-  // Bord droite (sans les extrémités)
+  // Bord droite (sans les extrÃ©mitÃ©s)
   Block(Window_pos_X+((x_pos+width-1)*Menu_factor_X),
         Window_pos_Y+((y_pos+1)*Menu_factor_Y),
         Menu_factor_X,(height-2)*Menu_factor_Y,color_br);
@@ -133,21 +133,21 @@
   Window_display_frame_generic(x_pos,y_pos,width,height,color,color,color,color,color);
 }
 
-  // -- Frame creux: foncé en haut-gauche et clair en bas-droite --
+  // -- Frame creux: foncÃ© en haut-gauche et clair en bas-droite --
 
 void Window_display_frame_in(word x_pos,word y_pos,word width,word height)
 {
   Window_display_frame_generic(x_pos,y_pos,width,height,MC_Dark,MC_White,MC_Light,MC_Dark,MC_White);
 }
 
-  // -- Frame bombé: clair en haut-gauche et foncé en bas-droite --
+  // -- Frame bombÃ©: clair en haut-gauche et foncÃ© en bas-droite --
 
 void Window_display_frame_out(word x_pos,word y_pos,word width,word height)
 {
   Window_display_frame_generic(x_pos,y_pos,width,height,MC_White,MC_Dark,MC_Light,MC_White,MC_Dark);
 }
 
-  // -- Frame de séparation: un cadre bombé dans un cadre creux (3D!!!) --
+  // -- Frame de sÃ©paration: un cadre bombÃ© dans un cadre creux (3D!!!) --
 
 void Window_display_frame(word x_pos,word y_pos,word width,word height)
 {
@@ -156,7 +156,7 @@
 }
 
 
-//-- Affichages relatifs à la palette dans le menu ---------------------------
+//-- Affichages relatifs Ã  la palette dans le menu ---------------------------
 
   // -- Affichage des couleurs courante (fore/back) de pinceau dans le menu --
 
@@ -395,35 +395,35 @@
   {
     Menu_palette_cell_width = ((Screen_width/Menu_factor_X)-(MENU_WIDTH+2)) / Menu_cells_X;
 
-    // Si ça tient, c'est bon. Sinon, on retente avec une colonne de moins
+    // Si Ã§a tient, c'est bon. Sinon, on retente avec une colonne de moins
     if (Menu_palette_cell_width>2)
       break;
     Menu_cells_X--;
   }
   
-  // Cale First_color_in_palette sur un multiple du nombre de cellules (arrondi inférieur)
+  // Cale First_color_in_palette sur un multiple du nombre de cellules (arrondi infÃ©rieur)
   if (Config.Palette_vertical)
     First_color_in_palette=First_color_in_palette/Menu_cells_X*Menu_cells_X;
   else
     First_color_in_palette=First_color_in_palette/Menu_cells_Y*Menu_cells_Y;
 
-  // Si le nombre de cellules a beaucoup augmenté et qu'on était près de
+  // Si le nombre de cellules a beaucoup augmentÃ© et qu'on Ã©tait prÃ¨s de
   // la fin, il faut reculer First_color_in_palette pour montrer plein
   // de couleurs.
   if ((int)First_color_in_palette+(Menu_cells_Y)*Menu_cells_X*2>=256)
     First_color_in_palette=255/Menu_cells_Y*Menu_cells_Y-(Menu_cells_X-1)*Menu_cells_Y;
 
-  // Mise à jour de la taille du bouton dans le menu. C'est pour pas que
+  // Mise Ã  jour de la taille du bouton dans le menu. C'est pour pas que
   // la bordure noire soit active.
   Buttons_Pool[BUTTON_CHOOSE_COL].Width=(Menu_palette_cell_width*Menu_cells_X)-1;
   Buttons_Pool[BUTTON_CHOOSE_COL].Height=(Menu_height-11)/Menu_cells_Y*Menu_cells_Y-1;
 }
 
 // Retrouve la couleur sur laquelle pointe le curseur souris.
-// Cette fonction suppose qu'on a déja vérifié que le curseur est dans
+// Cette fonction suppose qu'on a dÃ©ja vÃ©rifiÃ© que le curseur est dans
 // la zone rectangulaire du BUTTON_CHOOSE_COL
-// La fonction renvoie -1 si on est "trop à gauche" (pas possible)
-// ou après la couleur 255 (Ce qui peut arriver si la palette est affichée
+// La fonction renvoie -1 si on est "trop Ã  gauche" (pas possible)
+// ou aprÃ¨s la couleur 255 (Ce qui peut arriver si la palette est affichÃ©e
 // avec un nombre de lignes qui n'est pas une puissance de deux.)
 int Pick_color_in_palette()
 {
@@ -620,7 +620,7 @@
 
 // -- Affichage de texte -----------------------------------------------------
 
-  // -- Afficher une chaîne n'importe où à l'écran --
+  // -- Afficher une chaÃ®ne n'importe oÃ¹ Ã  l'Ã©cran --
 
 void Print_general(short x,short y,const char * str,byte text_color,byte background_color)
 {
@@ -639,7 +639,7 @@
     real_x=0; // Position dans le buffer
     for (index=0;str[index]!='\0';index++)
     {
-      // Pointeur sur le premier pixel du caractère
+      // Pointeur sur le premier pixel du caractÃ¨re
       font_pixel=Menu_font+(((unsigned char)str[index])<<6);
       for (x_pos=0;x_pos<8;x_pos+=1)
         for (repeat_menu_x_factor=0;repeat_menu_x_factor<Menu_factor_X*Pixel_width;repeat_menu_x_factor++)
@@ -657,7 +657,7 @@
   byte *pixel;
   x_pos=(x_pos*Menu_factor_X)+Window_pos_X;
   y_pos=(y_pos*Menu_factor_Y)+Window_pos_Y;
-  // Premier pixel du caractère
+  // Premier pixel du caractÃ¨re
   pixel=Menu_font + (c<<6);
   
   for (y=0;y<8;y++)
@@ -759,11 +759,11 @@
   Print_general(Screen_width-(string_size<<3)*Menu_factor_X,Menu_status_Y,display_string,MC_Black,MC_Light);
 }
 
-// Fonction d'affichage d'une chaine numérique avec une fonte très fine
-// Spécialisée pour les compteurs RGB
+// Fonction d'affichage d'une chaine numÃ©rique avec une fonte trÃ¨s fine
+// SpÃ©cialisÃ©e pour les compteurs RGB
 void Print_counter(short x,short y,const char * str,byte text_color,byte background_color)
 {
-  // Macros pour écrire des litteraux binaires.
+  // Macros pour Ã©crire des litteraux binaires.
   // Ex: Ob(11110000) == 0xF0
   #define Ob(x)  ((unsigned)Ob_(0 ## x ## uL))
   #define Ob_(x) ((x & 1) | (x >> 2 & 2) | (x >> 4 & 4) | (x >> 6 & 8) |                \
@@ -941,9 +941,11 @@
       case '-':
         char_number=12;
         break;
-      case '±':
+#if !defined(FDOS)
+      case 'Â±':
         char_number=13;
         break;
+#endif
     }
     for (y_pos=0;y_pos<8;y_pos++)
     {
@@ -1229,7 +1231,7 @@
         }
       break;
     default : // Pinceau
-      // On efface le pinceau précédent
+      // On efface le pinceau prÃ©cÃ©dent
       for (menu_y_pos=2,y_pos=0;y_pos<MENU_SPRITE_HEIGHT;menu_y_pos++,y_pos++)
         for (menu_x_pos=1,x_pos=0;x_pos<MENU_SPRITE_WIDTH;menu_x_pos++,x_pos++)
         {
@@ -1265,10 +1267,10 @@
     Update_rect(0,Menu_Y + Menu_bars[MENUBAR_TOOLS].Top*Menu_factor_Y,MENU_SPRITE_WIDTH*Menu_factor_X+3,MENU_SPRITE_HEIGHT*Menu_factor_Y+3);
 }
 
-  // -- Dessiner un pinceau prédéfini dans la fenêtre --
+  // -- Dessiner un pinceau prÃ©dÃ©fini dans la fenÃªtre --
 
 void Display_paintbrush_in_window(word x,word y,int number)
-  // Pinceau = 0..NB_PAINTBRUSH_SPRITES-1 : Pinceau prédéfini
+  // Pinceau = 0..NB_PAINTBRUSH_SPRITES-1 : Pinceau prÃ©dÃ©fini
 {
   word x_pos;
   word y_pos;
@@ -1293,7 +1295,7 @@
     for (window_x_pos=0,x_pos=0; x_pos<Gfx->Preset_paintbrush_width[number]; window_x_pos++,x_pos++)
       Block(origin_x+window_x_pos*x_size,origin_y+window_y_pos*y_size,x_size,y_size,(Gfx->Paintbrush_sprite[number][y_pos][x_pos])?MC_Black:MC_Light);
   // On n'utilise pas Pixel_in_window() car on ne dessine pas
-  // forcément avec la même taille de pixel.
+  // forcÃ©ment avec la mÃªme taille de pixel.
 
   Update_rect( ToWinX(origin_x), ToWinY(origin_y),
         ToWinL(Gfx->Preset_paintbrush_width[number]),
@@ -1316,16 +1318,16 @@
   Pixel_in_window(x,y+5,color);
 }
 
-  // -- Dessiner un bloc de couleurs dégradé verticalement
+  // -- Dessiner un bloc de couleurs dÃ©gradÃ© verticalement
 
 void Display_grad_block_in_window(word x_pos,word y_pos,word block_start,word block_end)
 {
-  word total_lines  =Menu_factor_Y<<6; // <=> à 64 lignes fct(Menu_Facteur)
+  word total_lines  =Menu_factor_Y<<6; // <=> Ã  64 lignes fct(Menu_Facteur)
   word nb_colors   =(block_start<=block_end)?block_end-block_start+1:block_start-block_end+1;
   word Selected_line_mode=(block_start<=block_end)?0:total_lines-1;
 
   word start_x       =Window_pos_X+(Menu_factor_X*x_pos);
-  word line_width =Menu_factor_X<<4; // <=> à 16 pixels fct(Menu_Facteur)
+  word line_width =Menu_factor_X<<4; // <=> Ã  16 pixels fct(Menu_Facteur)
 
   word start_y       =Window_pos_Y+(Menu_factor_Y*y_pos);
   word end_y         =start_y+total_lines;
@@ -1346,7 +1348,7 @@
 
 
 
-  // -- Dessiner un petit sprite représentant le type d'un drive --
+  // -- Dessiner un petit sprite reprÃ©sentant le type d'un drive --
 
 void Window_display_icon_sprite(word x_pos,word y_pos,byte type)
 {
@@ -1362,15 +1364,15 @@
 
 void Display_menu_palette_avoiding_window(byte * table)
 {
-  // On part du principe qu'il n'y a que le bas d'une fenêtre qui puisse
-  // empiéter sur la palette... Et c'est déjà pas mal!
+  // On part du principe qu'il n'y a que le bas d'une fenÃªtre qui puisse
+  // empiÃ©ter sur la palette... Et c'est dÃ©jÃ  pas mal!
   word color,real_color;
   word start_x,start_y;
   word end_x,end_y;
   word width;
   word height;
   word corner_x=Window_pos_X+Window_width*Menu_factor_X; // |_ Coin bas-droit
-  word corner_y=Window_pos_Y+Window_height*Menu_factor_Y; // |  de la fenêtre +1
+  word corner_y=Window_pos_Y+Window_height*Menu_factor_Y; // |  de la fenÃªtre +1
 
 
   if (Config.Separate_colors)
@@ -1393,8 +1395,8 @@
       end_x=start_x+width;
       end_y=start_y+height;
 
-      //   On affiche le bloc en entier si on peut, sinon on le découpe autour
-      // de la fenêtre.
+      //   On affiche le bloc en entier si on peut, sinon on le dÃ©coupe autour
+      // de la fenÃªtre.
       if ( (start_y>=corner_y) || (end_x<=Window_pos_X) || (start_x>=corner_x) )
         Block(start_x,start_y,width,height,real_color);
       else
@@ -1448,12 +1450,12 @@
       }
       {
         // Affichage du bloc directement dans le "buffer de fond" de la fenetre.
-        // Cela permet au bloc de couleur d'apparaitre si on déplace la fenetre.
+        // Cela permet au bloc de couleur d'apparaitre si on dÃ©place la fenetre.
         short x_pos;
         short y_pos;
-        short relative_x; // besoin d'une variable signée
-        short relative_y; // besoin d'une variable signée
-        // Attention aux unités
+        short relative_x; // besoin d'une variable signÃ©e
+        short relative_y; // besoin d'une variable signÃ©e
+        // Attention aux unitÃ©s
         relative_x = ((short)start_x - (short)Window_pos_X);
         relative_y = ((short)start_y - (short)Window_pos_Y);
 
@@ -1467,15 +1469,15 @@
   Update_rect(MENU_WIDTH*Menu_factor_X,Menu_Y_before_window,Screen_width-(MENU_WIDTH*Menu_factor_X),(Menu_height-11)*Menu_factor_Y);
 }
 
-// -------- Calcul des bornes de la partie d'image visible à l'écran ---------
+// -------- Calcul des bornes de la partie d'image visible Ã  l'Ã©cran ---------
 void Compute_limits(void)
 /*
-  Avant l'appel à cette fonction, les données de la loupe doivent être à jour.
+  Avant l'appel Ã  cette fonction, les donnÃ©es de la loupe doivent Ãªtre Ã  jour.
 */
 {
   if (Main_magnifier_mode)
   {
-    // -- Calcul des limites de la partie non zoomée de l'image --
+    // -- Calcul des limites de la partie non zoomÃ©e de l'image --
     Limit_top  =Main_offset_Y;
     Limit_left=Main_offset_X;
     Limit_visible_bottom   =Limit_top+Menu_Y-1;
@@ -1491,7 +1493,7 @@
     else
       Limit_right=Limit_visible_right;
 
-    // -- Calcul des limites de la partie zoomée de l'image --
+    // -- Calcul des limites de la partie zoomÃ©e de l'image --
     Limit_top_zoom  =Main_magnifier_offset_Y;
     Limit_left_zoom=Main_magnifier_offset_X;
     Limit_visible_bottom_zoom   =Limit_top_zoom+Main_magnifier_height-1;
@@ -1528,7 +1530,7 @@
 }
 
 
-// -- Calculer les coordonnées du pinceau en fonction du snap et de la loupe -
+// -- Calculer les coordonnÃ©es du pinceau en fonction du snap et de la loupe -
 void Compute_paintbrush_coordinates(void)
 {
   if ((Main_magnifier_mode) && (Mouse_X>=Main_X_zoom))
@@ -1605,7 +1607,7 @@
   bottom_is_visible   =Main_image_height<Menu_Y;
 
 
-  // On vérifie que la limite à droite est visible:
+  // On vÃ©rifie que la limite Ã  droite est visible:
   if (right_is_visible)
   {
     start=Limit_top;
@@ -1615,7 +1617,7 @@
     if (bottom_is_visible)
       end++;
 
-    // Juste le temps d'afficher les limites, on étend les limites de la loupe
+    // Juste le temps d'afficher les limites, on Ã©tend les limites de la loupe
     // aux limites visibles, car sinon Pixel_preview ne voudra pas afficher.
     old_zoom_limit=Limit_right_zoom;
     Limit_right_zoom=Limit_visible_right_zoom;
@@ -1628,14 +1630,14 @@
     Limit_right_zoom=old_zoom_limit;
   }
 
-  // On vérifie que la limite en bas est visible:
+  // On vÃ©rifie que la limite en bas est visible:
   if (bottom_is_visible)
   {
     start=Limit_left;
     end=(Limit_right<Main_image_width)?
         Limit_right:Main_image_width;
 
-    // On étend également les limites en bas (comme pour la limite droit)
+    // On Ã©tend Ã©galement les limites en bas (comme pour la limite droit)
     old_zoom_limit=Limit_bottom_zoom;
     Limit_bottom_zoom=Limit_visible_bottom_zoom;
 
@@ -1651,7 +1653,7 @@
 
 
 
-// -- Recadrer la partie non-zoomée de l'image par rapport à la partie zoomée
+// -- Recadrer la partie non-zoomÃ©e de l'image par rapport Ã  la partie zoomÃ©e
 //    lorsqu'on scrolle en mode Loupe --
 void Position_screen_according_to_zoom(void)
 {
@@ -1727,7 +1729,7 @@
 }
 
 
-// - Calcul des données du split en fonction de la proportion de chaque zone -
+// - Calcul des donnÃ©es du split en fonction de la proportion de chaque zone -
 void Compute_separator_data(void)
 {
   //short temp;
@@ -1736,13 +1738,13 @@
   Main_X_zoom=Screen_width-(((Screen_width+(Main_magnifier_factor>>1)-theoric_X)/Main_magnifier_factor)*Main_magnifier_factor);
   Main_separator_position=Main_X_zoom-(Menu_factor_X*SEPARATOR_WIDTH);
 
-  // Correction en cas de débordement sur la gauche
+  // Correction en cas de dÃ©bordement sur la gauche
   while (Main_separator_position*(Main_magnifier_factor+1)<Screen_width-(Menu_factor_X*SEPARATOR_WIDTH))
   {
     Main_separator_position+=Main_magnifier_factor;
     Main_X_zoom+=Main_magnifier_factor;
   }
-  // Correction en cas de débordement sur la droite
+  // Correction en cas de dÃ©bordement sur la droite
   theoric_X=Screen_width-((NB_ZOOMED_PIXELS_MIN-1)*Main_magnifier_factor);
   while (Main_X_zoom>=theoric_X)
   {
@@ -1756,7 +1758,7 @@
 // -------------------- Calcul des information de la loupe -------------------
 void Compute_magnifier_data(void)
 /*
-  Après modification des données de la loupe, il faut recalculer les limites.
+  AprÃ¨s modification des donnÃ©es de la loupe, il faut recalculer les limites.
 */
 {
   Compute_separator_data();
@@ -1858,7 +1860,7 @@
 
 
 
-  // -- Afficher la barre de séparation entre les parties zoomées ou non en
+  // -- Afficher la barre de sÃ©paration entre les parties zoomÃ©es ou non en
   //    mode Loupe --
 
 void Display_separator(void)
@@ -1882,11 +1884,11 @@
   Block(Main_separator_position+Menu_factor_X,Menu_factor_Y,
         Menu_factor_X,(Menu_Y-(Menu_factor_Y<<1)),MC_White);
 
-  // Bord droite (gris foncé)
+  // Bord droite (gris foncÃ©)
   Block(Main_X_zoom-(Menu_factor_X<<1),Menu_factor_Y,
         Menu_factor_X,(Menu_Y-(Menu_factor_Y<<1)),MC_Dark);
 
-  // Bord bas (gris foncé)
+  // Bord bas (gris foncÃ©)
   Block(Main_separator_position+(Menu_factor_X<<1),Menu_Y-Menu_factor_Y,
         (SEPARATOR_WIDTH-3)*Menu_factor_X,Menu_factor_Y,MC_Dark);
 
@@ -1897,7 +1899,7 @@
   Block(Main_X_zoom-(Menu_factor_X<<1),0,
         Menu_factor_X,Menu_factor_Y,MC_Light);
 
-  Update_rect(Main_separator_position,0,SEPARATOR_WIDTH*Menu_factor_X,Menu_Y); // On réaffiche toute la partie à gauche du split, ce qui permet d'effacer son ancienne position
+  Update_rect(Main_separator_position,0,SEPARATOR_WIDTH*Menu_factor_X,Menu_Y); // On rÃ©affiche toute la partie Ã  gauche du split, ce qui permet d'effacer son ancienne position
 }
 
 
@@ -1905,7 +1907,7 @@
 // -- Fonctions de manipulation du curseur -----------------------------------
 
 
-  // -- Afficher une barre horizontale XOR zoomée
+  // -- Afficher une barre horizontale XOR zoomÃ©e
 
 void Horizontal_XOR_line_zoom(short x_pos, short y_pos, short width)
 {
@@ -1922,7 +1924,7 @@
 }
 
 
-  // -- Afficher une barre verticale XOR zoomée
+  // -- Afficher une barre verticale XOR zoomÃ©e
 
 void Vertical_XOR_line_zoom(short x_pos, short y_pos, short height)
 {
@@ -1956,7 +1958,7 @@
   float cos_a,sin_a;
   short x1,y1,x2,y2,x3,y3,x4,y4;
 
-  // Si le curseur est dans le menu ou sur la barre de split, on affiche toujours une flèche.
+  // Si le curseur est dans le menu ou sur la barre de split, on affiche toujours une flÃ¨che.
   if ( ( (Mouse_Y<Menu_Y)
       && ( (!Main_magnifier_mode) || (Mouse_X<Main_separator_position) || (Mouse_X>=Main_X_zoom) ) )
     || (Windows_open) || (Cursor_shape==CURSOR_SHAPE_HOURGLASS) )
@@ -2042,7 +2044,7 @@
           if (end_y<3)
             Vertical_XOR_line  (Mouse_X,Mouse_Y+3,3-end_y);
 
-          // Petites barres aux extrémités
+          // Petites barres aux extrÃ©mitÃ©s
 
           start_x=(!Mouse_X);
           start_y=(!Mouse_Y);
@@ -2141,7 +2143,7 @@
       }
       break;
     case CURSOR_SHAPE_XOR_RECTANGLE :
-      // !!! Cette forme ne peut pas être utilisée en mode Loupe !!!
+      // !!! Cette forme ne peut pas Ãªtre utilisÃ©e en mode Loupe !!!
 
       // Petite croix au centre
       start_x=(Mouse_X-3);
@@ -2250,7 +2252,7 @@
 void Hide_cursor(void)
 {
   byte  shape;
-  int start_x; // int car sont parfois négatifs ! (quand on dessine sur un bord)
+  int start_x; // int car sont parfois nÃ©gatifs ! (quand on dessine sur un bord)
   int start_y;
   short end_x;
   short end_y;
@@ -2441,7 +2443,7 @@
 
       break;
     case CURSOR_SHAPE_XOR_RECTANGLE :
-      // !!! Cette forme ne peut pas être utilisée en mode Loupe !!!
+      // !!! Cette forme ne peut pas Ãªtre utilisÃ©e en mode Loupe !!!
 
       // Petite croix au centre
       start_x=(Mouse_X-3);
@@ -2557,7 +2559,7 @@
   word width;
   word height;
 
-  // ---/\/\/\  Partie non zoomée: /\/\/\---
+  // ---/\/\/\  Partie non zoomÃ©e: /\/\/\---
   if (Main_magnifier_mode)
   {
     if (Main_image_width<Main_separator_position)
@@ -2578,7 +2580,7 @@
     height=Menu_Y;
   Display_screen(width,height,Main_image_width);
 
-  // Effacement de la partie non-image dans la partie non zoomée:
+  // Effacement de la partie non-image dans la partie non zoomÃ©e:
   if (Main_magnifier_mode)
   {
     if (Main_image_width<Main_separator_position && Main_image_width < Screen_width)
@@ -2592,7 +2594,7 @@
   if (Main_image_height<Menu_Y)
     Block(0,Main_image_height,width,(Menu_Y-height),Main_backups->Pages->Transparent_color);
 
-  // ---/\/\/\  Partie zoomée: /\/\/\---
+  // ---/\/\/\  Partie zoomÃ©e: /\/\/\---
   if (Main_magnifier_mode)
   {
     // Affichage de la barre de split
@@ -2604,7 +2606,7 @@
     else
       width=Main_magnifier_width;
 
-    // Calcul du nombre de lignes visibles de l'image zoomée
+    // Calcul du nombre de lignes visibles de l'image zoomÃ©e
     if (Main_image_height<Main_magnifier_height)
       height=Main_image_height*Main_magnifier_factor;
     else
@@ -2612,7 +2614,7 @@
 
     Display_zoomed_screen(width,height,Main_image_width,Horizontal_line_buffer);
 
-    // Effacement de la partie non-image dans la partie zoomée:
+    // Effacement de la partie non-image dans la partie zoomÃ©e:
     if (Main_image_width<Main_magnifier_width)
       Block(Main_X_zoom+(Main_image_width*Main_magnifier_factor),0,
             (Main_magnifier_width-Main_image_width)*Main_magnifier_factor,
@@ -2624,7 +2626,7 @@
   // ---/\/\/\ Affichage des limites /\/\/\---
   if (Config.Display_image_limits)
     Display_image_limits();
-  Update_rect(0,0,Screen_width,Menu_Y); // TODO On peut faire plus fin, en évitant de mettre à jour la partie à droite du split quand on est en mode loupe. Mais c'est pas vraiment intéressant ?
+  Update_rect(0,0,Screen_width,Menu_Y); // TODO On peut faire plus fin, en Ã©vitant de mettre Ã  jour la partie Ã  droite du split quand on est en mode loupe. Mais c'est pas vraiment intÃ©ressant ?
 }
 
 
@@ -2764,7 +2766,7 @@
 void Remap_pixel(byte * pixel)
 {
   if (*pixel==Old_light)         // On commence par tester le Gris clair
-    *pixel=MC_Light;             // qui est pas mal utilisé.
+    *pixel=MC_Light;             // qui est pas mal utilisÃ©.
   else
   {
     if (*pixel==Old_black)        // Puis le Noir...
@@ -2798,7 +2800,7 @@
   if ( (MC_Light!=Old_light) || (MC_Dark!=Old_dark) || (MC_White!=Old_white) || (MC_Black !=Old_black )
     || (MC_Trans!=Old_trans) )
   {
-    // Création de la table de conversion
+    // CrÃ©ation de la table de conversion
     for (index=0; index<256; index++)
       conversion_table[index]=index;
 
@@ -2807,7 +2809,7 @@
     conversion_table[Old_light]=MC_Light;
     conversion_table[Old_white]=MC_White;
 
-    // Remappage de l'écran
+    // Remappage de l'Ã©cran
 
     temp=Window_height*Menu_factor_Y;
 
@@ -2824,11 +2826,11 @@
       // Remappage de la partie du fond de la fenetre qui cacherait le menu...
       Remap_window_backgrounds(conversion_table, Menu_Y_before_window, Screen_height);
       /*
-         Il faudrait peut-être remapper les pointillés délimitant l'image.
-         Mais ça va être chiant parce qu'ils peuvent être affichés en mode Loupe.
-         Mais de toutes façons, c'est franchement facultatif...
+         Il faudrait peut-Ãªtre remapper les pointillÃ©s dÃ©limitant l'image.
+         Mais Ã§a va Ãªtre chiant parce qu'ils peuvent Ãªtre affichÃ©s en mode Loupe.
+         Mais de toutes faÃ§ons, c'est franchement facultatif...
       */
-      // On passe la table juste pour ne rafficher que les couleurs modifiées
+      // On passe la table juste pour ne rafficher que les couleurs modifiÃ©es
       Display_menu_palette_avoiding_window(conversion_table);
     }
     Clear_border(MC_Black);
@@ -2875,7 +2877,7 @@
       MC_Light=table[2];
   }
 
-  // Recherche du gris foncé
+  // Recherche du gris foncÃ©
   Compute_4_best_colors_for_1_menu_color
     (Config.Fav_menu_colors[1].R, Config.Fav_menu_colors[1].G, Config.Fav_menu_colors[1].B,palette,table);
   if ( (MC_Black!=table[0]) && (MC_White!=table[0]) && (MC_Light!=table[0]) )
@@ -2893,7 +2895,7 @@
     }
   }
 
-  // C'est peu probable mais il est possible que MC_Light soit plus foncée que
+  // C'est peu probable mais il est possible que MC_Light soit plus foncÃ©e que
   // MC_Dark. Dans ce cas, on les inverse.
   if ( ((palette[MC_Light].R*30)+(palette[MC_Light].G*59)+(palette[MC_Light].B*11)) <
        ((palette[MC_Dark].R*30)+(palette[MC_Dark].G*59)+(palette[MC_Dark].B*11)) )
@@ -2901,7 +2903,7 @@
     SWAP_BYTES(MC_Light, MC_Dark);
   }
 
-  // On cherche une couleur de transparence différente des 4 autres.
+  // On cherche une couleur de transparence diffÃ©rente des 4 autres.
   for (MC_Trans=0; ((MC_Trans==MC_Black) || (MC_Trans==MC_Dark) ||
                    (MC_Trans==MC_Light) || (MC_Trans==MC_White)); MC_Trans++);
 
